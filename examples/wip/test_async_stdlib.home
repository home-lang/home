// Comprehensive test for async runtime and standard library expansion
// Tests all new features: async/await, actors, structured concurrency, collections, testing

use std::async::{Runtime, Channel, Actor, TaskScope};
use std::collections::{BloomFilter, SkipList, Trie, Rope, CircularBuffer};
use std::testing::{TestFramework, TestContext, PropertyTest};

// =============================================================================
// 1. ASYNC RUNTIME TESTS
// =============================================================================

async fn fetch_data(id: i32) -> Result<String, String> {
    // Simulate async I/O
    await sleep(Duration.fromMillis(10));
    return Ok("data_" + id.to_string());
}

async fn test_basic_async() {
    let result = await fetch_data(1);
    match result {
        Ok(data) => println("Fetched: " + data),
        Err(e) => println("Error: " + e),
    }
}

async fn test_concurrent_tasks() {
    let tasks = [];

    // Spawn multiple concurrent tasks
    for i in 0..10 {
        let task = spawn(fetch_data(i));
        tasks.push(task);
    }

    // Wait for all tasks to complete
    let results = await join_all(tasks);

    for result in results {
        match result {
            Ok(data) => println("Result: " + data),
            Err(e) => println("Error: " + e),
        }
    }
}

// =============================================================================
// 2. CHANNEL TESTS
// =============================================================================

async fn test_channels() {
    let (sender, receiver) = channel::<i32>(10);

    // Spawn producer
    spawn(async {
        for i in 0..5 {
            await sender.send(i);
            println("Sent: " + i.to_string());
        }
    });

    // Spawn consumer
    spawn(async {
        while true {
            match await receiver.recv() {
                Ok(val) => println("Received: " + val.to_string()),
                Err(_) => break,
            }
        }
    });
}

async fn test_oneshot_channel() {
    let (sender, receiver) = oneshot::<String>();

    spawn(async {
        await sleep(Duration.fromMillis(100));
        sender.send("Hello from oneshot!");
    });

    let message = await receiver.recv();
    println("Oneshot received: " + message);
}

// =============================================================================
// 3. ACTOR SYSTEM TESTS
// =============================================================================

struct Counter {
    value: i32,
}

enum CounterMessage {
    Increment,
    Decrement,
    GetValue(Sender<i32>),
    Reset,
}

impl Actor for Counter {
    type Message = CounterMessage;

    async fn handle(&mut self, msg: CounterMessage) {
        match msg {
            CounterMessage.Increment => {
                self.value += 1;
                println("Counter incremented to: " + self.value.to_string());
            },
            CounterMessage.Decrement => {
                self.value -= 1;
                println("Counter decremented to: " + self.value.to_string());
            },
            CounterMessage.GetValue(reply) => {
                reply.send(self.value);
            },
            CounterMessage.Reset => {
                self.value = 0;
                println("Counter reset");
            },
        }
    }
}

async fn test_actor_system() {
    let mut system = ActorSystem.new();

    // Spawn counter actor
    let counter = system.spawn(Counter { value: 0 });

    // Send messages
    counter.send(CounterMessage.Increment);
    counter.send(CounterMessage.Increment);
    counter.send(CounterMessage.Increment);

    // Get value
    let (sender, receiver) = oneshot();
    counter.send(CounterMessage.GetValue(sender));
    let value = await receiver.recv();

    println("Counter value: " + value.to_string());
    assert(value == 3, "Counter should be 3");
}

// =============================================================================
// 4. STRUCTURED CONCURRENCY TESTS
// =============================================================================

async fn test_task_scope() {
    let mut scope = TaskScope.new();

    // Spawn tasks in scope
    scope.spawn(async {
        await sleep(Duration.fromMillis(10));
        return 1;
    });

    scope.spawn(async {
        await sleep(Duration.fromMillis(20));
        return 2;
    });

    scope.spawn(async {
        await sleep(Duration.fromMillis(15));
        return 3;
    });

    // Wait for all tasks to complete
    let results = await scope.join();

    let sum = results.iter().sum();
    println("Sum of results: " + sum.to_string());
    assert(sum == 6, "Sum should be 6");
}

async fn test_nursery() {
    await with_nursery(async |nursery| {
        nursery.spawn(async {
            println("Task 1 started");
            await sleep(Duration.fromMillis(10));
            println("Task 1 completed");
        });

        nursery.spawn(async {
            println("Task 2 started");
            await sleep(Duration.fromMillis(20));
            println("Task 2 completed");
        });

        // All tasks automatically complete before nursery closes
    });

    println("All nursery tasks completed");
}

async fn test_parallel_operations() {
    let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    // Parallel map
    let doubled = await parallel_map(numbers, |x| x * 2);
    println("Doubled: " + doubled.to_string());

    // Parallel filter
    let evens = await parallel_filter(numbers, |x| x % 2 == 0);
    println("Evens: " + evens.to_string());

    assert(doubled.len() == 10, "Doubled should have 10 elements");
    assert(evens.len() == 5, "Evens should have 5 elements");
}

// =============================================================================
// 5. ADVANCED COLLECTIONS TESTS
// =============================================================================

fn test_bloom_filter() {
    let mut filter = BloomFilter.<1000>.new();

    // Insert items
    filter.insert("apple");
    filter.insert("banana");
    filter.insert("cherry");

    // Test membership
    assert(filter.contains("apple"), "Should contain apple");
    assert(filter.contains("banana"), "Should contain banana");
    assert(!filter.contains("grape"), "Should not contain grape");

    println("Bloom filter false positive rate: " +
        filter.false_positive_rate().to_string());
}

fn test_skip_list() {
    let mut list = SkipList.<i32, String>.new();

    list.insert(1, "one");
    list.insert(2, "two");
    list.insert(3, "three");
    list.insert(5, "five");

    assert(list.get(2) == Some("two"), "Should find 'two'");
    assert(list.get(4) == None, "Should not find 4");

    println("Skip list test passed");
}

fn test_trie() {
    let mut trie = Trie.new();

    trie.insert("apple");
    trie.insert("application");
    trie.insert("apply");
    trie.insert("banana");
    trie.insert("bandana");

    assert(trie.contains("apple"), "Should contain apple");
    assert(!trie.contains("app"), "Should not contain app");
    assert(trie.starts_with("app"), "Should have prefix app");

    // Find all words with prefix
    let words = trie.find_with_prefix("app");
    println("Words with prefix 'app': " + words.to_string());
    assert(words.len() == 3, "Should find 3 words");
}

fn test_rope() {
    let mut rope1 = Rope.fromString("Hello, ");
    let mut rope2 = Rope.fromString("World!");

    let concatenated = rope1.concat(rope2);
    let result = concatenated.to_string();

    assert(result == "Hello, World!", "Rope concatenation failed");
    assert(concatenated.length() == 13, "Rope length should be 13");

    println("Rope test passed: " + result);
}

fn test_circular_buffer() {
    let mut buffer = CircularBuffer.<i32>.new(5);

    // Fill buffer
    for i in 0..5 {
        buffer.push(i);
    }

    assert(buffer.is_full(), "Buffer should be full");

    // Overwrites oldest
    buffer.push(5);
    buffer.push(6);

    // Pop all
    let values = [];
    while let Some(val) = buffer.pop() {
        values.push(val);
    }

    println("Circular buffer values: " + values.to_string());
    assert(values == [2, 3, 4, 5, 6], "Circular buffer order incorrect");
}

// =============================================================================
// 6. TESTING FRAMEWORK DEMONSTRATION
// =============================================================================

fn test_framework_demo() {
    let mut framework = TestFramework.new();

    // Add unit tests
    framework.add_test("arithmetic", |ctx| {
        ctx.assert_equal(i32, 2 + 2, 4);
        ctx.assert_not_equal(i32, 2 + 2, 5);
        ctx.assert_true(10 > 5, "10 should be greater than 5");
    });

    framework.add_test("string operations", |ctx| {
        let s = "Hello";
        ctx.assert_equal(String, s.to_uppercase(), "HELLO");
        ctx.assert_true(s.starts_with("Hel"), "Should start with 'Hel'");
    });

    framework.add_test("error handling", |ctx| {
        fn failing_function() -> Result<(), String> {
            return Err("Expected error");
        }

        ctx.assert_error(error.ExpectedError, failing_function);
    });

    // Run all tests
    let results = framework.run_tests();

    if results.success() {
        println("All tests passed!");
    } else {
        println("Some tests failed!");
    }
}

fn test_property_based() {
    let mut prop_test = PropertyTest.new(12345);

    // Property: reversing twice should equal original
    prop_test.for_all(
        Vec<i32>,
        |rng| generate_random_vec(rng, 10),
        |vec| {
            let reversed = vec.reverse();
            let double_reversed = reversed.reverse();
            return vec == double_reversed;
        }
    );

    println("Property-based test passed");
}

fn test_benchmarks() {
    let mut framework = TestFramework.new();

    framework.add_benchmark("vec push", |bench| {
        let mut v = Vec.<i32>.new();
        bench.run_n(1000, || {
            v.push(42);
        });
    });

    framework.add_benchmark("hashmap insert", |bench| {
        let mut map = HashMap.<String, i32>.new();
        let mut counter = 0;
        bench.run_n(1000, || {
            map.insert("key" + counter.to_string(), counter);
            counter += 1;
        });
    });

    framework.run_benchmarks();
}

// =============================================================================
// 7. COMPREHENSIVE INTEGRATION TEST
// =============================================================================

async fn comprehensive_integration_test() {
    println("\n=== Running Comprehensive Integration Test ===\n");

    // 1. Async runtime with multiple tasks
    println("1. Testing async runtime...");
    await test_concurrent_tasks();

    // 2. Channels for communication
    println("\n2. Testing channels...");
    await test_channels();
    await test_oneshot_channel();

    // 3. Actor system
    println("\n3. Testing actor system...");
    await test_actor_system();

    // 4. Structured concurrency
    println("\n4. Testing structured concurrency...");
    await test_task_scope();
    await test_nursery();
    await test_parallel_operations();

    // 5. Advanced collections
    println("\n5. Testing advanced collections...");
    test_bloom_filter();
    test_skip_list();
    test_trie();
    test_rope();
    test_circular_buffer();

    // 6. Testing framework
    println("\n6. Testing framework...");
    test_framework_demo();
    test_property_based();
    test_benchmarks();

    println("\n=== All Integration Tests Passed! ===\n");
}

// =============================================================================
// MAIN ENTRY POINT
// =============================================================================

fn main() {
    let runtime = Runtime.new(num_cpus());

    runtime.block_on(async {
        await comprehensive_integration_test();
    });
}

// Test: Run with `home run examples/test_async_stdlib.home`
// Expected: All tests should pass with detailed output
// Features tested:
// - Async/await with work-stealing scheduler
// - Multi-producer multi-consumer channels
// - Actor system with supervision
// - Structured concurrency with scopes and nurseries
// - Advanced data structures (Bloom filter, Skip list, Trie, Rope, Circular buffer)
// - Unit testing, property-based testing, benchmarking
// - Error handling and resource cleanup
