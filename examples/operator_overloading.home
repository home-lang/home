// Operator Overloading Examples in Home

// ============================================================================
// Example 1: Vector2D with arithmetic operators
// ============================================================================

struct Vector2D {
    x: f64,
    y: f64,
}

// Implement Add trait for vector addition
impl Add for Vector2D {
    type Output = Vector2D
    
    fn add(self, rhs: Vector2D): Vector2D {
        Vector2D {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

// Implement Sub trait for vector subtraction
impl Sub for Vector2D {
    type Output = Vector2D
    
    fn sub(self, rhs: Vector2D): Vector2D {
        Vector2D {
            x: self.x - rhs.x,
            y: self.y - rhs.y,
        }
    }
}

// Implement Mul for scalar multiplication
impl Mul<f64> for Vector2D {
    type Output = Vector2D
    
    fn mul(self, scalar: f64): Vector2D {
        Vector2D {
            x: self.x * scalar,
            y: self.y * scalar,
        }
    }
}

// Implement Neg for negation
impl Neg for Vector2D {
    type Output = Vector2D
    
    fn neg(self): Vector2D {
        Vector2D {
            x: -self.x,
            y: -self.y,
        }
    }
}

// Implement AddAssign for in-place addition
impl AddAssign for Vector2D {
    fn add_assign(&mut self, rhs: Vector2D): void {
        self.x += rhs.x
        self.y += rhs.y
    }
}

fn test_vector_ops(): void {
    let v1 = Vector2D { x: 1.0, y: 2.0 }
    let v2 = Vector2D { x: 3.0, y: 4.0 }
    
    // Addition
    let v3 = v1 + v2
    println("v1 + v2 = ({}, {})", v3.x, v3.y)
    
    // Subtraction
    let v4 = v1 - v2
    println("v1 - v2 = ({}, {})", v4.x, v4.y)
    
    // Scalar multiplication
    let v5 = v1 * 2.0
    println("v1 * 2.0 = ({}, {})", v5.x, v5.y)
    
    // Negation
    let v6 = -v1
    println("-v1 = ({}, {})", v6.x, v6.y)
    
    // Compound assignment
    let mut v7 = v1
    v7 += v2
    println("v1 += v2 = ({}, {})", v7.x, v7.y)
}

// ============================================================================
// Example 2: Complex numbers
// ============================================================================

struct Complex {
    real: f64,
    imag: f64,
}

impl Add for Complex {
    type Output = Complex
    
    fn add(self, rhs: Complex): Complex {
        Complex {
            real: self.real + rhs.real,
            imag: self.imag + rhs.imag,
        }
    }
}

impl Mul for Complex {
    type Output = Complex
    
    fn mul(self, rhs: Complex): Complex {
        // (a + bi) * (c + di) = (ac - bd) + (ad + bc)i
        Complex {
            real: self.real * rhs.real - self.imag * rhs.imag,
            imag: self.real * rhs.imag + self.imag * rhs.real,
        }
    }
}

impl Display for Complex {
    fn fmt(&self, f: &mut Formatter): Result {
        if self.imag >= 0.0 {
            write!(f, "{} + {}i", self.real, self.imag)
        } else {
            write!(f, "{} - {}i", self.real, -self.imag)
        }
    }
}

fn test_complex_ops(): void {
    let c1 = Complex { real: 3.0, imag: 4.0 }
    let c2 = Complex { real: 1.0, imag: 2.0 }
    
    let c3 = c1 + c2
    println("({}) + ({}) = {}", c1, c2, c3)
    
    let c4 = c1 * c2
    println("({}) * ({}) = {}", c1, c2, c4)
}

// ============================================================================
// Example 3: Matrix operations
// ============================================================================

struct Matrix2x2 {
    data: [[f64; 2]; 2],
}

impl Add for Matrix2x2 {
    type Output = Matrix2x2
    
    fn add(self, rhs: Matrix2x2): Matrix2x2 {
        Matrix2x2 {
            data: [
                [self.data[0][0] + rhs.data[0][0], self.data[0][1] + rhs.data[0][1]],
                [self.data[1][0] + rhs.data[1][0], self.data[1][1] + rhs.data[1][1]],
            ],
        }
    }
}

impl Mul for Matrix2x2 {
    type Output = Matrix2x2
    
    fn mul(self, rhs: Matrix2x2): Matrix2x2 {
        // Matrix multiplication
        Matrix2x2 {
            data: [
                [
                    self.data[0][0] * rhs.data[0][0] + self.data[0][1] * rhs.data[1][0],
                    self.data[0][0] * rhs.data[0][1] + self.data[0][1] * rhs.data[1][1],
                ],
                [
                    self.data[1][0] * rhs.data[0][0] + self.data[1][1] * rhs.data[1][0],
                    self.data[1][0] * rhs.data[0][1] + self.data[1][1] * rhs.data[1][1],
                ],
            ],
        }
    }
}

impl Index<usize> for Matrix2x2 {
    type Output = [f64; 2]
    
    fn index(&self, row: usize): &[f64; 2] {
        &self.data[row]
    }
}

impl IndexMut<usize> for Matrix2x2 {
    fn index_mut(&mut self, row: usize): &mut [f64; 2] {
        &mut self.data[row]
    }
}

fn test_matrix_ops(): void {
    let m1 = Matrix2x2 {
        data: [[1.0, 2.0], [3.0, 4.0]],
    }
    let m2 = Matrix2x2 {
        data: [[5.0, 6.0], [7.0, 8.0]],
    }
    
    // Matrix addition
    let m3 = m1 + m2
    
    // Matrix multiplication
    let m4 = m1 * m2
    
    // Indexing
    let row = m1[0]
    println("First row: [{}, {}]", row[0], row[1])
    
    // Mutable indexing
    let mut m5 = m1
    m5[0][0] = 10.0
}

// ============================================================================
// Example 4: Custom string type with concatenation
// ============================================================================

struct MyString {
    data: string,
}

impl Add for MyString {
    type Output = MyString
    
    fn add(self, rhs: MyString): MyString {
        MyString {
            data: self.data + rhs.data,
        }
    }
}

impl AddAssign for MyString {
    fn add_assign(&mut self, rhs: MyString): void {
        self.data += rhs.data
    }
}

fn test_string_ops(): void {
    let s1 = MyString { data: "Hello, " }
    let s2 = MyString { data: "World!" }
    
    let s3 = s1 + s2
    println("{}", s3.data)
    
    let mut s4 = MyString { data: "Foo" }
    s4 += MyString { data: "Bar" }
    println("{}", s4.data)
}

// ============================================================================
// Example 5: Bitwise operations for flags
// ============================================================================

struct Permissions {
    bits: u32,
}

const READ: Permissions = Permissions { bits: 0b001 }
const WRITE: Permissions = Permissions { bits: 0b010 }
const EXECUTE: Permissions = Permissions { bits: 0b100 }

impl BitOr for Permissions {
    type Output = Permissions
    
    fn bitor(self, rhs: Permissions): Permissions {
        Permissions {
            bits: self.bits | rhs.bits,
        }
    }
}

impl BitAnd for Permissions {
    type Output = Permissions
    
    fn bitand(self, rhs: Permissions): Permissions {
        Permissions {
            bits: self.bits & rhs.bits,
        }
    }
}

impl Permissions {
    fn has(&self, perm: Permissions): bool {
        (self.bits & perm.bits) == perm.bits
    }
}

fn test_permission_ops(): void {
    let perms = READ | WRITE
    
    if perms.has(READ) {
        println("Has read permission")
    }
    
    if perms.has(EXECUTE) {
        println("Has execute permission")
    } else {
        println("No execute permission")
    }
}

// ============================================================================
// Example 6: Generic operator implementation
// ============================================================================

fn add_generic<T>(a: T, b: T): T::Output 
where 
    T: Add<T>
{
    a + b
}

fn test_generic_ops(): void {
    let v1 = Vector2D { x: 1.0, y: 2.0 }
    let v2 = Vector2D { x: 3.0, y: 4.0 }
    let v3 = add_generic(v1, v2)
    
    let c1 = Complex { real: 1.0, imag: 2.0 }
    let c2 = Complex { real: 3.0, imag: 4.0 }
    let c3 = add_generic(c1, c2)
}

// ============================================================================
// Main
// ============================================================================

fn main(): void {
    println("=== Vector Operations ===")
    test_vector_ops()
    
    println("\n=== Complex Number Operations ===")
    test_complex_ops()
    
    println("\n=== Matrix Operations ===")
    test_matrix_ops()
    
    println("\n=== String Operations ===")
    test_string_ops()
    
    println("\n=== Permission Operations ===")
    test_permission_ops()
    
    println("\n=== Generic Operations ===")
    test_generic_ops()
}
