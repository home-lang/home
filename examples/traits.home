// Comprehensive Traits Examples in Home

// ============================================================================
// Example 1: Basic Trait Definition and Implementation
// ============================================================================

trait Animal {
    fn make_sound(&self): string
    fn get_name(&self): string
}

struct Dog {
    name: string,
}

struct Cat {
    name: string,
}

impl Animal for Dog {
    fn make_sound(&self): string {
        "Woof!"
    }
    
    fn get_name(&self): string {
        self.name
    }
}

impl Animal for Cat {
    fn make_sound(&self): string {
        "Meow!"
    }
    
    fn get_name(&self): string {
        self.name
    }
}

fn test_basic_traits(): void {
    let dog = Dog { name: "Buddy" }
    let cat = Cat { name: "Whiskers" }
    
    println("{} says {}", dog.get_name(), dog.make_sound())
    println("{} says {}", cat.get_name(), cat.make_sound())
}

// ============================================================================
// Example 2: Trait with Associated Types
// ============================================================================

trait Iterator {
    type Item
    
    fn next(&mut self): Option<Self::Item>
}

struct Counter {
    count: u32,
    max: u32,
}

impl Iterator for Counter {
    type Item = u32
    
    fn next(&mut self): Option<u32> {
        if self.count < self.max {
            self.count += 1
            Some(self.count)
        } else {
            None
        }
    }
}

fn test_associated_types(): void {
    let mut counter = Counter { count: 0, max: 5 }
    
    while let Some(num) = counter.next() {
        println("Count: {}", num)
    }
}

// ============================================================================
// Example 3: Trait with Default Implementation
// ============================================================================

trait Summary {
    fn summarize_author(&self): string
    
    // Default implementation
    fn summarize(&self): string {
        "Read more from " + self.summarize_author() + "..."
    }
}

struct Article {
    author: string,
    title: string,
    content: string,
}

struct Tweet {
    username: string,
    content: string,
}

impl Summary for Article {
    fn summarize_author(&self): string {
        self.author
    }
    
    // Override default
    fn summarize(&self): string {
        self.title + " by " + self.author
    }
}

impl Summary for Tweet {
    fn summarize_author(&self): string {
        "@" + self.username
    }
    // Uses default implementation
}

fn test_default_implementations(): void {
    let article = Article {
        author: "Alice",
        title: "Traits in Home",
        content: "...",
    }
    
    let tweet = Tweet {
        username: "bob",
        content: "Hello, world!",
    }
    
    println("{}", article.summarize())
    println("{}", tweet.summarize())
}

// ============================================================================
// Example 4: Trait Inheritance (Super Traits)
// ============================================================================

trait Shape {
    fn area(&self): f64
}

trait Colored {
    fn color(&self): string
}

trait ColoredShape: Shape + Colored {
    fn describe(&self): string {
        "A " + self.color() + " shape with area " + self.area().to_string()
    }
}

struct ColoredCircle {
    radius: f64,
    color: string,
}

impl Shape for ColoredCircle {
    fn area(&self): f64 {
        3.14159 * self.radius * self.radius
    }
}

impl Colored for ColoredCircle {
    fn color(&self): string {
        self.color
    }
}

impl ColoredShape for ColoredCircle {}

fn test_trait_inheritance(): void {
    let circle = ColoredCircle {
        radius: 5.0,
        color: "red",
    }
    
    println("{}", circle.describe())
}

// ============================================================================
// Example 5: Generic Traits
// ============================================================================

trait Add<Rhs = Self> {
    type Output
    fn add(self, rhs: Rhs): Self::Output
}

struct Point {
    x: f64,
    y: f64,
}

// Point + Point
impl Add for Point {
    type Output = Point
    
    fn add(self, rhs: Point): Point {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}

// Point + f64 (scalar)
impl Add<f64> for Point {
    type Output = Point
    
    fn add(self, scalar: f64): Point {
        Point {
            x: self.x + scalar,
            y: self.y + scalar,
        }
    }
}

fn test_generic_traits(): void {
    let p1 = Point { x: 1.0, y: 2.0 }
    let p2 = Point { x: 3.0, y: 4.0 }
    
    let p3 = p1 + p2  // Point + Point
    let p4 = p1 + 5.0  // Point + f64
    
    println("p3: ({}, {})", p3.x, p3.y)
    println("p4: ({}, {})", p4.x, p4.y)
}

// ============================================================================
// Example 6: Trait Bounds on Functions
// ============================================================================

fn print_summary<T: Summary>(item: &T): void {
    println("Summary: {}", item.summarize())
}

fn print_multiple<T: Summary + Display>(item: &T): void {
    println("Display: {}", item)
    println("Summary: {}", item.summarize())
}

// ============================================================================
// Example 7: Where Clauses
// ============================================================================

fn complex_function<T, U>(t: T, u: U): void
where
    T: Clone + Debug,
    U: Clone + Debug
{
    let t_copy = t.clone()
    let u_copy = u.clone()
    
    println("T: {:?}", t_copy)
    println("U: {:?}", u_copy)
}

// Where clause with associated types
fn process_iterator<I>(mut iter: I): void
where
    I: Iterator,
    I::Item: Display
{
    while let Some(item) = iter.next() {
        println("{}", item)
    }
}

// ============================================================================
// Example 8: Trait Objects (Dynamic Dispatch)
// ============================================================================

trait Drawable {
    fn draw(&self): void
}

struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

struct Rectangle {
    x: f64,
    y: f64,
    width: f64,
    height: f64,
}

impl Drawable for Circle {
    fn draw(&self): void {
        println("Drawing circle at ({}, {}) with radius {}", self.x, self.y, self.radius)
    }
}

impl Drawable for Rectangle {
    fn draw(&self): void {
        println("Drawing rectangle at ({}, {}) with size {}x{}", 
                self.x, self.y, self.width, self.height)
    }
}

fn render_all(shapes: &[dyn Drawable]): void {
    for shape in shapes {
        shape.draw()
    }
}

fn test_trait_objects(): void {
    let shapes: Vec<dyn Drawable> = vec![
        Circle { x: 0.0, y: 0.0, radius: 5.0 },
        Rectangle { x: 10.0, y: 10.0, width: 20.0, height: 15.0 },
        Circle { x: 30.0, y: 30.0, radius: 10.0 },
    ]
    
    render_all(&shapes)
}

// ============================================================================
// Example 9: Builder Pattern with Traits
// ============================================================================

trait Builder {
    type Output
    fn build(self): Self::Output
}

struct UserBuilder {
    name: Option<string>,
    email: Option<string>,
    age: Option<u32>,
}

impl UserBuilder {
    fn new(): UserBuilder {
        UserBuilder {
            name: None,
            email: None,
            age: None,
        }
    }
    
    fn name(mut self, name: string): UserBuilder {
        self.name = Some(name)
        self
    }
    
    fn email(mut self, email: string): UserBuilder {
        self.email = Some(email)
        self
    }
    
    fn age(mut self, age: u32): UserBuilder {
        self.age = Some(age)
        self
    }
}

struct User {
    name: string,
    email: string,
    age: u32,
}

impl Builder for UserBuilder {
    type Output = Result<User, string>
    
    fn build(self): Result<User, string> {
        let name = self.name.ok_or("Name is required")?
        let email = self.email.ok_or("Email is required")?
        let age = self.age.unwrap_or(0)
        
        Ok(User { name, email, age })
    }
}

fn test_builder_pattern(): void {
    let user = UserBuilder::new()
        .name("Alice")
        .email("alice@example.com")
        .age(30)
        .build()
        .unwrap()
    
    println("User: {} <{}>, age {}", user.name, user.email, user.age)
}

// ============================================================================
// Example 10: Repository Pattern with Traits
// ============================================================================

trait Repository<T> {
    fn find_by_id(&self, id: u64): Option<T>
    fn save(&mut self, entity: T): Result<(), string>
    fn delete(&mut self, id: u64): Result<(), string>
    fn find_all(&self): Vec<T>
}

struct InMemoryRepository<T> {
    data: HashMap<u64, T>,
    next_id: u64,
}

impl<T: Clone> InMemoryRepository<T> {
    fn new(): InMemoryRepository<T> {
        InMemoryRepository {
            data: HashMap::new(),
            next_id: 1,
        }
    }
}

impl<T: Clone> Repository<T> for InMemoryRepository<T> {
    fn find_by_id(&self, id: u64): Option<T> {
        self.data.get(&id).cloned()
    }
    
    fn save(&mut self, entity: T): Result<(), string> {
        let id = self.next_id
        self.next_id += 1
        self.data.insert(id, entity)
        Ok(())
    }
    
    fn delete(&mut self, id: u64): Result<(), string> {
        self.data.remove(&id)
            .map(|_| ())
            .ok_or("Entity not found")
    }
    
    fn find_all(&self): Vec<T> {
        self.data.values().cloned().collect()
    }
}

// ============================================================================
// Example 11: From/Into Conversion Traits
// ============================================================================

trait From<T> {
    fn from(value: T): Self
}

trait Into<T> {
    fn into(self): T
}

// Blanket implementation: Into is automatically implemented for types that implement From
impl<T, U> Into<U> for T where U: From<T> {
    fn into(self): U {
        U::from(self)
    }
}

struct Celsius(f64)
struct Fahrenheit(f64)

impl From<Fahrenheit> for Celsius {
    fn from(f: Fahrenheit): Celsius {
        Celsius((f.0 - 32.0) * 5.0 / 9.0)
    }
}

impl From<Celsius> for Fahrenheit {
    fn from(c: Celsius): Fahrenheit {
        Fahrenheit(c.0 * 9.0 / 5.0 + 32.0)
    }
}

fn test_conversion_traits(): void {
    let f = Fahrenheit(98.6)
    let c: Celsius = f.into()  // Uses Into trait
    
    let c2 = Celsius(100.0)
    let f2 = Fahrenheit::from(c2)  // Uses From trait
    
    println("{}째F = {}째C", 98.6, c.0)
    println("{}째C = {}째F", 100.0, f2.0)
}

// ============================================================================
// Main
// ============================================================================

fn main(): void {
    println("=== Basic Traits ===")
    test_basic_traits()
    
    println("\n=== Associated Types ===")
    test_associated_types()
    
    println("\n=== Default Implementations ===")
    test_default_implementations()
    
    println("\n=== Trait Inheritance ===")
    test_trait_inheritance()
    
    println("\n=== Generic Traits ===")
    test_generic_traits()
    
    println("\n=== Trait Objects ===")
    test_trait_objects()
    
    println("\n=== Builder Pattern ===")
    test_builder_pattern()
    
    println("\n=== Conversion Traits ===")
    test_conversion_traits()
}
