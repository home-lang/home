// Comprehensive Multiple Dispatch Examples in Home

// ============================================================================
// Example 1: Basic Multiple Dispatch
// ============================================================================

fn process(data: string) -> string {
    "Processing string: " + data
}

fn process(data: i32) -> string {
    "Processing integer: " + data.to_string()
}

fn process(data: f64) -> string {
    "Processing float: " + data.to_string()
}

fn test_basic_dispatch() -> void {
    println("=== Basic Multiple Dispatch ===")
    
    println(process("hello"))
    println(process(42))
    println(process(3.14))
}

// ============================================================================
// Example 2: Multiple Parameters
// ============================================================================

fn combine(a: string, b: string) -> string {
    a + b
}

fn combine(a: string, b: i32) -> string {
    a + b.to_string()
}

fn combine(a: i32, b: string) -> string {
    a.to_string() + b
}

fn combine(a: i32, b: i32) -> i32 {
    a + b
}

fn test_multiple_parameters() -> void {
    println("\n=== Multiple Parameters ===")
    
    println("combine('hello', 'world') = {}", combine("hello", "world"))
    println("combine('count: ', 42) = {}", combine("count: ", 42))
    println("combine(10, ' items') = {}", combine(10, " items"))
    println("combine(5, 10) = {}", combine(5, 10))
}

// ============================================================================
// Example 3: Collision Detection
// ============================================================================

struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

struct Rectangle {
    x: f64,
    y: f64,
    width: f64,
    height: f64,
}

struct Point {
    x: f64,
    y: f64,
}

fn collides(a: Circle, b: Circle) -> bool {
    let dx = a.x - b.x
    let dy = a.y - b.y
    let distance = (dx * dx + dy * dy).sqrt()
    distance < (a.radius + b.radius)
}

fn collides(a: Circle, b: Rectangle) -> bool {
    // Find closest point on rectangle to circle center
    let closest_x = a.x.clamp(b.x, b.x + b.width)
    let closest_y = a.y.clamp(b.y, b.y + b.height)
    
    let dx = a.x - closest_x
    let dy = a.y - closest_y
    let distance = (dx * dx + dy * dy).sqrt()
    
    distance < a.radius
}

fn collides(a: Rectangle, b: Circle) -> bool {
    collides(b, a)  // Symmetric - reuse Circle-Rectangle
}

fn collides(a: Rectangle, b: Rectangle) -> bool {
    a.x < b.x + b.width &&
    a.x + a.width > b.x &&
    a.y < b.y + b.height &&
    a.y + a.height > b.y
}

fn collides(a: Point, b: Circle) -> bool {
    let dx = a.x - b.x
    let dy = a.y - b.y
    let distance = (dx * dx + dy * dy).sqrt()
    distance < b.radius
}

fn test_collision_detection() -> void {
    println("\n=== Collision Detection ===")
    
    let c1 = Circle { x: 0.0, y: 0.0, radius: 5.0 }
    let c2 = Circle { x: 8.0, y: 0.0, radius: 5.0 }
    let r1 = Rectangle { x: 10.0, y: 10.0, width: 20.0, height: 15.0 }
    let p1 = Point { x: 3.0, y: 0.0 }
    
    println("Circle-Circle collision: {}", collides(c1, c2))
    println("Circle-Rectangle collision: {}", collides(c1, r1))
    println("Point-Circle collision: {}", collides(p1, c1))
}

// ============================================================================
// Example 4: Mathematical Operations
// ============================================================================

struct Matrix {
    rows: usize,
    cols: usize,
    data: Vec<f64>,
}

struct Vector {
    size: usize,
    data: Vec<f64>,
}

type Scalar = f64;

fn multiply(a: Matrix, b: Matrix) -> Matrix {
    // Matrix-matrix multiplication
    println("Matrix × Matrix")
    // Implementation...
    a
}

fn multiply(a: Matrix, b: Vector) -> Vector {
    // Matrix-vector multiplication
    println("Matrix × Vector")
    // Implementation...
    b
}

fn multiply(a: Matrix, b: Scalar) -> Matrix {
    // Scalar multiplication
    println("Matrix × Scalar")
    // Implementation...
    a
}

fn multiply(a: Vector, b: Vector) -> Scalar {
    // Dot product
    println("Vector · Vector (dot product)")
    // Implementation...
    0.0
}

fn test_mathematical_operations() -> void {
    println("\n=== Mathematical Operations ===")
    
    let m = Matrix { rows: 3, cols: 3, data: vec![1.0; 9] }
    let v = Vector { size: 3, data: vec![1.0, 2.0, 3.0] }
    let s: Scalar = 2.0
    
    multiply(m, m)
    multiply(m, v)
    multiply(m, s)
    multiply(v, v)
}

// ============================================================================
// Example 5: Serialization
// ============================================================================

struct User {
    name: string,
    age: i32,
    email: string,
}

struct Post {
    title: string,
    content: string,
    author: string,
}

enum Format {
    JSON,
    XML,
    Binary,
}

fn serialize(data: User, format: Format::JSON) -> string {
    format!("{{\"name\":\"{}\",\"age\":{},\"email\":\"{}\"}}", 
            data.name, data.age, data.email)
}

fn serialize(data: User, format: Format::XML) -> string {
    format!("<user><name>{}</name><age>{}</age><email>{}</email></user>",
            data.name, data.age, data.email)
}

fn serialize(data: Post, format: Format::JSON) -> string {
    format!("{{\"title\":\"{}\",\"content\":\"{}\",\"author\":\"{}\"}}",
            data.title, data.content, data.author)
}

fn serialize(data: Post, format: Format::XML) -> string {
    format!("<post><title>{}</title><content>{}</content><author>{}</author></post>",
            data.title, data.content, data.author)
}

fn test_serialization() -> void {
    println("\n=== Serialization ===")
    
    let user = User {
        name: "Alice",
        age: 30,
        email: "alice@example.com",
    }
    
    let post = Post {
        title: "Hello World",
        content: "This is a post",
        author: "Alice",
    }
    
    println("User as JSON: {}", serialize(user, Format::JSON))
    println("User as XML: {}", serialize(user, Format::XML))
    println("Post as JSON: {}", serialize(post, Format::JSON))
    println("Post as XML: {}", serialize(post, Format::XML))
}

// ============================================================================
// Example 6: Event Handling
// ============================================================================

enum Event {
    MouseClick { x: i32, y: i32 },
    KeyPress { key: string },
    Scroll { delta: i32 },
}

struct Button {
    label: string,
}

struct TextInput {
    text: string,
}

struct Canvas {
    width: i32,
    height: i32,
}

fn handle(event: Event::MouseClick, target: Button) -> void {
    println("Button '{}' clicked at ({}, {})", 
            target.label, event.x, event.y)
}

fn handle(event: Event::MouseClick, target: TextInput) -> void {
    println("TextInput focused at ({}, {})", event.x, event.y)
}

fn handle(event: Event::KeyPress, target: TextInput) -> void {
    println("TextInput received key: {}", event.key)
}

fn handle(event: Event::KeyPress, target: Canvas) -> void {
    println("Canvas shortcut: {}", event.key)
}

fn handle(event: Event::Scroll, target: Canvas) -> void {
    println("Canvas scrolled by: {}", event.delta)
}

fn test_event_handling() -> void {
    println("\n=== Event Handling ===")
    
    let button = Button { label: "Submit" }
    let input = TextInput { text: "" }
    let canvas = Canvas { width: 800, height: 600 }
    
    handle(Event::MouseClick { x: 100, y: 200 }, button)
    handle(Event::MouseClick { x: 50, y: 75 }, input)
    handle(Event::KeyPress { key: "a" }, input)
    handle(Event::KeyPress { key: "Ctrl+S" }, canvas)
    handle(Event::Scroll { delta: 10 }, canvas)
}

// ============================================================================
// Example 7: Protocol Negotiation
// ============================================================================

struct HTTP1Client;
struct HTTP2Client;
struct HTTP1Server;
struct HTTP2Server;

enum Connection {
    HTTP1,
    HTTP2,
}

fn connect(client: HTTP1Client, server: HTTP1Server) -> Connection {
    println("HTTP/1.1 connection established")
    Connection::HTTP1
}

fn connect(client: HTTP2Client, server: HTTP2Server) -> Connection {
    println("HTTP/2 connection established")
    Connection::HTTP2
}

fn connect(client: HTTP2Client, server: HTTP1Server) -> Connection {
    println("Downgrading to HTTP/1.1")
    Connection::HTTP1
}

fn connect(client: HTTP1Client, server: HTTP2Server) -> Connection {
    println("Upgrading to HTTP/2")
    Connection::HTTP2
}

fn test_protocol_negotiation() -> void {
    println("\n=== Protocol Negotiation ===")
    
    let h1_client = HTTP1Client;
    let h2_client = HTTP2Client;
    let h1_server = HTTP1Server;
    let h2_server = HTTP2Server;
    
    connect(h1_client, h1_server)
    connect(h2_client, h2_server)
    connect(h2_client, h1_server)
    connect(h1_client, h2_server)
}

// ============================================================================
// Example 8: Type Conversion
// ============================================================================

fn convert(from: string, to: Type::Int) -> i32 {
    from.parse().unwrap_or(0)
}

fn convert(from: string, to: Type::Float) -> f64 {
    from.parse().unwrap_or(0.0)
}

fn convert(from: i32, to: Type::String) -> string {
    from.to_string()
}

fn convert(from: f64, to: Type::String) -> string {
    from.to_string()
}

fn convert(from: i32, to: Type::Float) -> f64 {
    from as f64
}

fn convert(from: f64, to: Type::Int) -> i32 {
    from as i32
}

enum Type {
    Int,
    Float,
    String,
}

fn test_type_conversion() -> void {
    println("\n=== Type Conversion ===")
    
    println("'42' to int: {}", convert("42", Type::Int))
    println("'3.14' to float: {}", convert("3.14", Type::Float))
    println("42 to string: {}", convert(42, Type::String))
    println("3.14 to string: {}", convert(3.14, Type::String))
    println("42 to float: {}", convert(42, Type::Float))
    println("3.14 to int: {}", convert(3.14, Type::Int))
}

// ============================================================================
// Example 9: Distance Calculations
// ============================================================================

fn distance(a: Point, b: Point) -> f64 {
    let dx = a.x - b.x
    let dy = a.y - b.y
    (dx * dx + dy * dy).sqrt()
}

fn distance(p: Point, c: Circle) -> f64 {
    let dx = p.x - c.x
    let dy = p.y - c.y
    let dist = (dx * dx + dy * dy).sqrt()
    (dist - c.radius).max(0.0)
}

fn distance(p: Point, r: Rectangle) -> f64 {
    let closest_x = p.x.clamp(r.x, r.x + r.width)
    let closest_y = p.y.clamp(r.y, r.y + r.height)
    let dx = p.x - closest_x
    let dy = p.y - closest_y
    (dx * dx + dy * dy).sqrt()
}

fn test_distance_calculations() -> void {
    println("\n=== Distance Calculations ===")
    
    let p1 = Point { x: 0.0, y: 0.0 }
    let p2 = Point { x: 3.0, y: 4.0 }
    let c = Circle { x: 10.0, y: 0.0, radius: 5.0 }
    let r = Rectangle { x: 20.0, y: 20.0, width: 10.0, height: 10.0 }
    
    println("Point to Point: {}", distance(p1, p2))
    println("Point to Circle: {}", distance(p1, c))
    println("Point to Rectangle: {}", distance(p1, r))
}

// ============================================================================
// Example 10: Rendering System
// ============================================================================

enum RenderTarget {
    Screen,
    Texture,
    SVG,
}

fn render(shape: Circle, target: RenderTarget::Screen) -> void {
    println("Drawing circle on screen at ({}, {}) radius {}",
            shape.x, shape.y, shape.radius)
}

fn render(shape: Circle, target: RenderTarget::SVG) -> void {
    println("<circle cx=\"{}\" cy=\"{}\" r=\"{}\" />",
            shape.x, shape.y, shape.radius)
}

fn render(shape: Rectangle, target: RenderTarget::Screen) -> void {
    println("Drawing rectangle on screen at ({}, {}) size {}x{}",
            shape.x, shape.y, shape.width, shape.height)
}

fn render(shape: Rectangle, target: RenderTarget::SVG) -> void {
    println("<rect x=\"{}\" y=\"{}\" width=\"{}\" height=\"{}\" />",
            shape.x, shape.y, shape.width, shape.height)
}

fn test_rendering() -> void {
    println("\n=== Rendering System ===")
    
    let circle = Circle { x: 50.0, y: 50.0, radius: 25.0 }
    let rect = Rectangle { x: 100.0, y: 100.0, width: 50.0, height: 30.0 }
    
    render(circle, RenderTarget::Screen)
    render(circle, RenderTarget::SVG)
    render(rect, RenderTarget::Screen)
    render(rect, RenderTarget::SVG)
}

// ============================================================================
// Main
// ============================================================================

fn main() -> void {
    test_basic_dispatch()
    test_multiple_parameters()
    test_collision_detection()
    test_mathematical_operations()
    test_serialization()
    test_event_handling()
    test_protocol_negotiation()
    test_type_conversion()
    test_distance_calculations()
    test_rendering()
    
    println("\n=== All multiple dispatch examples completed! ===")
}
