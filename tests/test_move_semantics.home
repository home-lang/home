// Comprehensive tests for move semantics and ownership checking

// Test 1: Basic move
fn test_basic_move(): i32 {
    let s = "Hello";  // String is Move type
    let t = s;        // s is moved to t
    // Cannot use s here - would be use-after-move error
    return 0;
}

// Test 2: Copy type does not move
fn test_copy_type(): i32 {
    let x = 42;       // i32 is Copy type
    let y = x;        // x is copied, not moved
    let z = x + y;    // x is still usable
    return z;
}

// Test 3: Use after move (should error)
fn test_use_after_move(): i32 {
    let s = "Hello";
    let t = s;        // s is moved
    // let u = s;     // ERROR: use of moved value
    return 0;
}

// Test 4: Move in function call
fn consume(s: string): i32 {
    // s is owned by this function
    return 0;
}

fn test_move_to_function(): i32 {
    let s = "Hello";
    let result = consume(s);  // s is moved into function
    // Cannot use s here
    return result;
}

// Test 5: Conditional move
fn test_conditional_move(): i32 {
    let s = "Hello";

    if (true) {
        let t = s;    // s moved in then branch
    } else {
        let u = s;    // s moved in else branch
    }

    // s is conditionally moved (cannot use here)
    return 0;
}

// Test 6: Partial move of struct fields
struct Point {
    x: i32,
    y: i32,
}

fn test_partial_move(): i32 {
    let p = Point { x: 10, y: 20 };
    let x = p.x;      // Move field x (if x is Move type)
    let y = p.y;      // Move field y
    // Cannot use p as a whole anymore
    return x + y;
}

// Test 7: Reinitialize after move
fn test_reinitialize(): i32 {
    let s = "Hello";
    let t = s;        // s is moved

    let s = "World";  // Reinitialize s with new value
    let u = s;        // Can use s again
    return 0;
}

// Test 8: Move in loop
fn test_move_in_loop(): i32 {
    let arr = ["a", "b", "c"];

    for (item in arr) {
        // Each iteration moves an element
        // item is owned in this scope
    }

    return 0;
}

// Test 9: Move with pattern matching
enum Option {
    Some(string),
    None,
}

fn test_move_in_match(): i32 {
    let opt = Option.Some("value");

    match opt {
        Option.Some(s) => {
            // s is moved out of opt
            return 1;
        },
        Option.None => {
            return 0;
        },
    }

    // opt cannot be used here (partially moved)
}

// Test 10: Copy types in different contexts
fn test_copy_semantics(): i32 {
    // All primitives are Copy
    let a: i32 = 42;
    let b: i64 = 100;
    let c: f32 = 3.14;
    let d: bool = true;

    let a2 = a;  // Copy
    let b2 = b;  // Copy
    let c2 = c;  // Copy
    let d2 = d;  // Copy

    // All original variables still usable
    return a + b2 as i32;
}

// Test 11: Move array
fn test_move_array(): i32 {
    let arr = [1, 2, 3];  // Array is Move type
    let arr2 = arr;       // arr is moved
    // Cannot use arr here
    return arr2[0];
}

// Test 12: Return moves ownership
fn create_string(): string {
    let s = "Created";
    return s;  // s is moved to caller
}

fn test_return_move(): i32 {
    let s = create_string();  // Ownership transferred
    return 0;
}

// Main test runner
fn main(): i32 {
    print("Testing move semantics...\n");

    test_basic_move();
    test_copy_type();
    test_move_to_function();
    test_conditional_move();
    test_partial_move();
    test_reinitialize();
    test_move_in_loop();
    test_move_in_match();
    test_copy_semantics();
    test_move_array();
    test_return_move();

    print("All move semantics tests completed!\n");
    return 0;
}
