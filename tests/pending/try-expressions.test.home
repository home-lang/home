// Try Expression Test Suite
// Tests ? operator for error propagation

// ============================================================================
// BASIC TRY EXPRESSIONS
// ============================================================================

it("should propagate Ok value") {
    fn safe_div(a: i32, b: i32): Result<i32, string> {
        if (b == 0) {
            return Err("division by zero");
        }
        return Ok(a / b);
    }

    fn compute(): Result<i32, string> {
        let x = safe_div(10, 2)?;
        return Ok(x * 2);
    }

    let result = compute();
    assert(result == Ok(10));
}

it("should propagate Err immediately") {
    fn safe_div(a: i32, b: i32): Result<i32, string> {
        if (b == 0) {
            return Err("division by zero");
        }
        return Ok(a / b);
    }

    fn compute(): Result<i32, string> {
        let x = safe_div(10, 0)?;
        return Ok(x * 2);
    }

    let result = compute();
    assert(result == Err("division by zero"));
}

// ============================================================================
// TRY WITH ELSE
// ============================================================================

it("should use else on error") {
    fn may_fail(x: i32): Result<i32, string> {
        if (x < 0) {
            return Err("negative");
        }
        return Ok(x);
    }

    let result = may_fail(-5) else 0;
    assert(result == 0);
}

it("should use value on success") {
    fn may_fail(x: i32): Result<i32, string> {
        if (x < 0) {
            return Err("negative");
        }
        return Ok(x);
    }

    let result = may_fail(10) else 0;
    assert(result == 10);
}

// ============================================================================
// CHAINED TRY OPERATIONS
// ============================================================================

it("should chain try operations") {
    fn parse_int(s: string): Result<i32, string> {
        if (s == "42") {
            return Ok(42);
        }
        return Err("invalid");
    }

    fn double_parsed(s: string): Result<i32, string> {
        let n = parse_int(s)?;
        return Ok(n * 2);
    }

    let result = double_parsed("42");
    assert(result == Ok(84));
}

it("should fail fast on first error") {
    fn step1(x: i32): Result<i32, string> {
        if (x < 0) { return Err("step1 failed"); }
        return Ok(x + 1);
    }

    fn step2(x: i32): Result<i32, string> {
        if (x > 100) { return Err("step2 failed"); }
        return Ok(x * 2);
    }

    fn pipeline(x: i32): Result<i32, string> {
        let a = step1(x)?;
        let b = step2(a)?;
        return Ok(b);
    }

    let result = pipeline(-5);
    assert(result == Err("step1 failed"));
}

// ============================================================================
// TRY WITH OPTIONS
// ============================================================================

it("should unwrap Some value") {
    fn find_positive(arr: [i32]): Option<i32> {
        let mut i = 0;
        while (i < arr.len()) {
            if (arr[i] > 0) {
                return Some(arr[i]);
            }
            i = i + 1;
        }
        return None;
    }

    let arr = [-1, -2, 5, -3];
    let result = find_positive(arr) else 0;
    assert(result == 5);
}

it("should use default on None") {
    fn find_positive(arr: [i32]): Option<i32> {
        let mut i = 0;
        while (i < arr.len()) {
            if (arr[i] > 0) {
                return Some(arr[i]);
            }
            i = i + 1;
        }
        return None;
    }

    let arr = [-1, -2, -3];
    let result = find_positive(arr) else 99;
    assert(result == 99);
}

