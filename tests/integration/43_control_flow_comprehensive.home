// Comprehensive Control Flow Tests
// Tests: if/else, while, for, match, break, continue

// ============================================
// Test 1: Basic if/else
// ============================================
fn test_basic_if_else(): i32 {
    let x = 10;

    if (x > 5) {
        if (x > 15) {
            return 1;  // Should not reach
        }
    }

    if (x == 10) {
        return 0;  // Success
    } else {
        return 2;
    }
}

// ============================================
// Test 2: Chained if/else if/else
// ============================================
fn classify_number(n: i32): string {
    if (n < 0) {
        return "negative";
    } else if (n == 0) {
        return "zero";
    } else if (n < 10) {
        return "small";
    } else if (n < 100) {
        return "medium";
    } else {
        return "large";
    }
}

fn test_chained_if(): i32 {
    if (classify_number(-5) != "negative") { return 1; }
    if (classify_number(0) != "zero") { return 2; }
    if (classify_number(5) != "small") { return 3; }
    if (classify_number(50) != "medium") { return 4; }
    if (classify_number(500) != "large") { return 5; }
    return 0;
}

// ============================================
// Test 3: If expressions
// ============================================
fn test_if_expressions(): i32 {
    let x = 10;
    let result = if (x > 5) { 100 } else { 0 };
    if (result != 100) { return 1; }

    let sign = if (x > 0) { 1 } else if (x < 0) { -1 } else { 0 };
    if (sign != 1) { return 2; }

    let nested = if (x > 0) {
        if (x > 5) { "big positive" } else { "small positive" }
    } else {
        "not positive"
    };
    if (nested != "big positive") { return 3; }

    return 0;
}

// ============================================
// Test 4: While loops
// ============================================
fn test_while_loops(): i32 {
    // Simple counter
    let mut i = 0;
    let mut sum = 0;
    while (i < 10) {
        sum = sum + i;
        i = i + 1;
    }
    if (sum != 45) { return 1; }

    // Nested while
    let mut outer = 0;
    let mut total = 0;
    while (outer < 3) {
        let mut inner = 0;
        while (inner < 3) {
            total = total + 1;
            inner = inner + 1;
        }
        outer = outer + 1;
    }
    if (total != 9) { return 2; }

    return 0;
}

// ============================================
// Test 5: Do-while loops
// ============================================
fn test_do_while(): i32 {
    // Executes at least once
    let mut count = 0;
    do {
        count = count + 1;
    } while (count < 5);

    if (count != 5) { return 1; }

    // Even when condition is initially false
    let mut executed = false;
    do {
        executed = true;
    } while (false);

    if (executed != true) { return 2; }

    return 0;
}

// ============================================
// Test 6: For loops
// ============================================
fn test_for_loops(): i32 {
    // Range-based for
    let mut sum = 0;
    for (i in 0..10) {
        sum = sum + i;
    }
    if (sum != 45) { return 1; }

    // Inclusive range
    let mut product = 1;
    for (i in 1..=5) {
        product = product * i;
    }
    if (product != 120) { return 2; }

    // For over array
    let arr = [1, 2, 3, 4, 5];
    let mut arr_sum = 0;
    for (item in arr) {
        arr_sum = arr_sum + item;
    }
    if (arr_sum != 15) { return 3; }

    return 0;
}

// ============================================
// Test 7: Break statements
// ============================================
fn test_break(): i32 {
    // Break from while
    let mut i = 0;
    while (true) {
        if (i >= 5) {
            break;
        }
        i = i + 1;
    }
    if (i != 5) { return 1; }

    // Break from nested loops (breaks inner only)
    let mut outer_count = 0;
    let mut total = 0;
    while (outer_count < 3) {
        let mut inner_count = 0;
        while (true) {
            if (inner_count >= 2) {
                break;
            }
            total = total + 1;
            inner_count = inner_count + 1;
        }
        outer_count = outer_count + 1;
    }
    if (total != 6) { return 2; }

    return 0;
}

// ============================================
// Test 8: Continue statements
// ============================================
fn test_continue(): i32 {
    // Skip even numbers
    let mut sum = 0;
    let mut i = 0;
    while (i < 10) {
        i = i + 1;
        if (i % 2 == 0) {
            continue;
        }
        sum = sum + i;
    }
    // 1 + 3 + 5 + 7 + 9 = 25
    if (sum != 25) { return 1; }

    return 0;
}

// ============================================
// Test 9: Match expressions - basic
// ============================================
fn test_match_basic(): i32 {
    let x = 5;
    let result = match x {
        1 => 100,
        2 => 200,
        5 => 500,
        _ => 0,
    };
    if (result != 500) { return 1; }

    let b = true;
    let bool_result = match b {
        true => 1,
        false => 0,
    };
    if (bool_result != 1) { return 2; }

    return 0;
}

// ============================================
// Test 10: Match with guards
// ============================================
fn test_match_guards(): i32 {
    let x = 42;

    let result = match x {
        n if n < 0 => "negative",
        n if n == 0 => "zero",
        n if n < 50 => "small",
        n if n < 100 => "medium",
        _ => "large",
    };

    if (result != "small") { return 1; }

    let y = 75;
    let result2 = match y {
        n if n < 50 => "small",
        n if n < 100 => "medium",
        _ => "large",
    };

    if (result2 != "medium") { return 2; }

    return 0;
}

// ============================================
// Test 11: Match with or-patterns
// ============================================
fn test_match_or_patterns(): i32 {
    let status = 200;

    let category = match status {
        200 | 201 | 204 => "success",
        400 | 404 | 422 => "client_error",
        500 | 502 | 503 => "server_error",
        _ => "unknown",
    };

    if (category != "success") { return 1; }

    let day = 6;  // Saturday
    let is_weekend = match day {
        0 | 6 => true,
        _ => false,
    };

    if (is_weekend != true) { return 2; }

    return 0;
}

// ============================================
// Test 12: Match with enums
// ============================================
enum Status {
    Active,
    Inactive,
    Pending(i32)
}

fn get_status_code(s: Status): i32 {
    match s {
        Status.Active => 1,
        Status.Inactive => 0,
        Status.Pending(n) => n,
    }
}

fn test_match_enums(): i32 {
    let s1 = Status.Active;
    let s2 = Status.Inactive;
    let s3 = Status.Pending(42);

    if (get_status_code(s1) != 1) { return 1; }
    if (get_status_code(s2) != 0) { return 2; }
    if (get_status_code(s3) != 42) { return 3; }

    return 0;
}

// ============================================
// Test 13: Complex control flow
// ============================================
fn collatz_steps(mut n: i32): i32 {
    let mut steps = 0;
    while (n != 1) {
        if (n % 2 == 0) {
            n = n / 2;
        } else {
            n = n * 3 + 1;
        }
        steps = steps + 1;
    }
    return steps;
}

fn test_complex_control_flow(): i32 {
    // Collatz sequence for 6: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1 (8 steps)
    let steps = collatz_steps(6);
    if (steps != 8) { return 1; }

    return 0;
}

// ============================================
// Main test runner
// ============================================
fn main(): i32 {
    let t1 = test_basic_if_else();
    if (t1 != 0) {
        print("test_basic_if_else failed\n");
        return 1;
    }

    let t2 = test_chained_if();
    if (t2 != 0) {
        print("test_chained_if failed\n");
        return 2;
    }

    let t3 = test_if_expressions();
    if (t3 != 0) {
        print("test_if_expressions failed\n");
        return 3;
    }

    let t4 = test_while_loops();
    if (t4 != 0) {
        print("test_while_loops failed\n");
        return 4;
    }

    let t5 = test_do_while();
    if (t5 != 0) {
        print("test_do_while failed\n");
        return 5;
    }

    let t6 = test_for_loops();
    if (t6 != 0) {
        print("test_for_loops failed\n");
        return 6;
    }

    let t7 = test_break();
    if (t7 != 0) {
        print("test_break failed\n");
        return 7;
    }

    let t8 = test_continue();
    if (t8 != 0) {
        print("test_continue failed\n");
        return 8;
    }

    let t9 = test_match_basic();
    if (t9 != 0) {
        print("test_match_basic failed\n");
        return 9;
    }

    let t10 = test_match_guards();
    if (t10 != 0) {
        print("test_match_guards failed\n");
        return 10;
    }

    let t11 = test_match_or_patterns();
    if (t11 != 0) {
        print("test_match_or_patterns failed\n");
        return 11;
    }

    let t12 = test_match_enums();
    if (t12 != 0) {
        print("test_match_enums failed\n");
        return 12;
    }

    let t13 = test_complex_control_flow();
    if (t13 != 0) {
        print("test_complex_control_flow failed\n");
        return 13;
    }

    print("All control flow tests passed!\n");
    return 0;
}
