// Pipe Operator Tests
// Tests function composition and data flow

// Test 1: Simple pipe
fn addOne(n: int) -> int {
    return n + 1;
}

fn double(n: int) -> int {
    return n * 2;
}

let result1 = 5 |> addOne;
assert(result1 == 6);

// Test 2: Chained pipes
let result2 = 5 |> addOne |> double;
assert(result2 == 12);

// Test 3: Three-stage pipe
fn triple(n: int) -> int {
    return n * 3;
}

let result3 = 2 |> double |> addOne |> triple;
assert(result3 == 15);

// Test 4: Pipe with subtraction
fn subtractTwo(n: int) -> int {
    return n - 2;
}

let result4 = 10 |> subtractTwo |> double;
assert(result4 == 16);

// Test 5: Long pipe chain
fn increment(n: int) -> int {
    return n + 1;
}

let result5 = 1 |> increment |> increment |> increment |> increment;
assert(result5 == 5);

// Test 6: Pipe with complex function
fn square(n: int) -> int {
    return n * n;
}

let result6 = 3 |> square |> addOne;
assert(result6 == 10);

// Test 7: Mixed operations
fn halve(n: int) -> int {
    return n / 2;
}

let result7 = 20 |> halve |> addOne |> double;
assert(result7 == 22);

// Test 8: Pipe in expression
let computed = (10 |> double) + (5 |> triple);
assert(computed == 35);

// Test 9: Nested pipe usage
fn quadruple(n: int) -> int {
    let temp = n |> double;
    return temp |> double;
}

let result9 = 3 |> quadruple;
assert(result9 == 12);

// Test 10: Pipe with multiple transformations
let result10 = 7 |> addOne |> double |> subtractTwo |> triple;
assert(result10 == 42);

print("âœ“ All pipe operator tests passed!");
