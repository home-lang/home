// Comprehensive Async/Await Tests
// Tests: async functions, await expressions, futures, concurrent execution

// ============================================
// Test 1: Basic async functions
// ============================================
async fn simple_async(): i32 {
    return 42;
}

async fn delayed_value(val: i32): i32 {
    // Simulates some async work
    return val * 2;
}

fn test_basic_async(): i32 {
    // Await async function
    let result = await simple_async();
    if (result != 42) { return 1; }

    let doubled = await delayed_value(21);
    if (doubled != 42) { return 2; }

    return 0;
}

// ============================================
// Test 2: Async functions with Result
// ============================================
enum AsyncResult {
    Ok(i32),
    Err(string)
}

async fn fetch_data(id: i32): AsyncResult {
    if (id < 0) {
        return AsyncResult.Err("Invalid ID");
    }
    return AsyncResult.Ok(id * 10);
}

fn test_async_result(): i32 {
    let result = await fetch_data(5);
    match result {
        AsyncResult.Ok(val) => {
            if (val != 50) { return 1; }
        },
        AsyncResult.Err(e) => return 2,
    }

    let error = await fetch_data(-1);
    match error {
        AsyncResult.Ok(val) => return 3,
        AsyncResult.Err(e) => { /* expected */ },
    }

    return 0;
}

// ============================================
// Test 3: Chained async calls
// ============================================
async fn step1(x: i32): i32 {
    return x + 10;
}

async fn step2(x: i32): i32 {
    return x * 2;
}

async fn step3(x: i32): i32 {
    return x - 5;
}

async fn pipeline(start: i32): i32 {
    let a = await step1(start);  // 10 + 10 = 20
    let b = await step2(a);      // 20 * 2 = 40
    let c = await step3(b);      // 40 - 5 = 35
    return c;
}

fn test_chained_async(): i32 {
    let result = await pipeline(10);
    if (result != 35) { return 1; }

    return 0;
}

// ============================================
// Test 4: Concurrent async with join
// ============================================
async fn task_a(): i32 {
    return 10;
}

async fn task_b(): i32 {
    return 20;
}

async fn task_c(): i32 {
    return 30;
}

fn test_concurrent_join(): i32 {
    // Run multiple async tasks concurrently
    let (a, b, c) = await join!(task_a(), task_b(), task_c());

    if (a != 10) { return 1; }
    if (b != 20) { return 2; }
    if (c != 30) { return 3; }

    let sum = a + b + c;
    if (sum != 60) { return 4; }

    return 0;
}

// ============================================
// Test 5: Select/race first completion
// ============================================
async fn slow_task(): i32 {
    // Simulates slow operation
    return 100;
}

async fn fast_task(): i32 {
    // Simulates fast operation
    return 42;
}

fn test_select_race(): i32 {
    // Get first completed result
    let first = await select! {
        result = fast_task() => result,
        result = slow_task() => result,
    };

    // fast_task should complete first
    if (first != 42) { return 1; }

    return 0;
}

// ============================================
// Test 6: Async closures
// ============================================
fn test_async_closures(): i32 {
    let async_add = async fn(a: i32, b: i32): i32 {
        return a + b;
    };

    let result = await async_add(15, 27);
    if (result != 42) { return 1; }

    // Capture variables
    let factor = 10;
    let async_scale = async fn(x: i32): i32 {
        return x * factor;
    };

    let scaled = await async_scale(5);
    if (scaled != 50) { return 2; }

    return 0;
}

// ============================================
// Test 7: Async with loops
// ============================================
async fn process_item(item: i32): i32 {
    return item * 2;
}

fn test_async_loops(): i32 {
    let items = [1, 2, 3, 4, 5];
    let mut total = 0;

    for (item in items) {
        let processed = await process_item(item);
        total = total + processed;
    }

    // 2 + 4 + 6 + 8 + 10 = 30
    if (total != 30) { return 1; }

    return 0;
}

// ============================================
// Test 8: Async error handling with try
// ============================================
async fn may_fail(should_fail: bool): AsyncResult {
    if (should_fail) {
        return AsyncResult.Err("Operation failed");
    }
    return AsyncResult.Ok(42);
}

async fn operation_with_fallback(): i32 {
    let result = await may_fail(true);
    match result {
        AsyncResult.Ok(val) => return val,
        AsyncResult.Err(e) => {
            // Try fallback
            let fallback = await may_fail(false);
            match fallback {
                AsyncResult.Ok(val) => return val,
                AsyncResult.Err(e) => return -1,
            }
        },
    }
}

fn test_async_error_handling(): i32 {
    let result = await operation_with_fallback();
    if (result != 42) { return 1; }

    return 0;
}

// ============================================
// Test 9: Timeouts
// ============================================
async fn long_running_task(): i32 {
    // Simulates long operation
    return 100;
}

fn test_timeout(): i32 {
    let result = await timeout!(long_running_task(), 1000);  // 1 second timeout

    match result {
        AsyncResult.Ok(val) => {
            if (val != 100) { return 1; }
        },
        AsyncResult.Err(e) => {
            // Timeout occurred
            return 2;
        },
    }

    return 0;
}

// ============================================
// Test 10: Async streams
// ============================================
async fn* generate_numbers(count: i32): i32 {
    let mut i = 0;
    while (i < count) {
        yield i;
        i = i + 1;
    }
}

fn test_async_streams(): i32 {
    let mut sum = 0;

    for await (num in generate_numbers(5)) {
        sum = sum + num;
    }

    // 0 + 1 + 2 + 3 + 4 = 10
    if (sum != 10) { return 1; }

    return 0;
}

// ============================================
// Test 11: Parallel map
// ============================================
async fn square(x: i32): i32 {
    return x * x;
}

fn test_parallel_map(): i32 {
    let items = [1, 2, 3, 4, 5];

    // Process all items in parallel
    let squared = await items.map_async(square);

    if (squared[0] != 1) { return 1; }
    if (squared[1] != 4) { return 2; }
    if (squared[2] != 9) { return 3; }
    if (squared[3] != 16) { return 4; }
    if (squared[4] != 25) { return 5; }

    return 0;
}

// ============================================
// Test 12: Async mutex/synchronization
// ============================================
struct AsyncMutex<T> {
    value: T,
    locked: bool
}

fn new_mutex<T>(value: T): AsyncMutex<T> {
    return AsyncMutex { value: value, locked: false };
}

async fn with_lock<T>(mutex: &mut AsyncMutex<T>, f: fn(&mut T): i32): i32 {
    // Wait for lock
    while (mutex.locked) {
        await yield();
    }
    mutex.locked = true;

    let result = f(&mut mutex.value);

    mutex.locked = false;
    return result;
}

fn test_async_mutex(): i32 {
    let mut counter = new_mutex(0);

    let increment = fn(val: &mut i32): i32 {
        *val = *val + 1;
        return *val;
    };

    let r1 = await with_lock(&mut counter, increment);
    let r2 = await with_lock(&mut counter, increment);
    let r3 = await with_lock(&mut counter, increment);

    if (r1 != 1) { return 1; }
    if (r2 != 2) { return 2; }
    if (r3 != 3) { return 3; }

    return 0;
}

// ============================================
// Main test runner
// ============================================
fn main(): i32 {
    let t1 = test_basic_async();
    if (t1 != 0) { print("test_basic_async failed\n"); return 1; }

    let t2 = test_async_result();
    if (t2 != 0) { print("test_async_result failed\n"); return 2; }

    let t3 = test_chained_async();
    if (t3 != 0) { print("test_chained_async failed\n"); return 3; }

    let t4 = test_concurrent_join();
    if (t4 != 0) { print("test_concurrent_join failed\n"); return 4; }

    let t5 = test_select_race();
    if (t5 != 0) { print("test_select_race failed\n"); return 5; }

    let t6 = test_async_closures();
    if (t6 != 0) { print("test_async_closures failed\n"); return 6; }

    let t7 = test_async_loops();
    if (t7 != 0) { print("test_async_loops failed\n"); return 7; }

    let t8 = test_async_error_handling();
    if (t8 != 0) { print("test_async_error_handling failed\n"); return 8; }

    let t9 = test_timeout();
    if (t9 != 0) { print("test_timeout failed\n"); return 9; }

    let t10 = test_async_streams();
    if (t10 != 0) { print("test_async_streams failed\n"); return 10; }

    let t11 = test_parallel_map();
    if (t11 != 0) { print("test_parallel_map failed\n"); return 11; }

    let t12 = test_async_mutex();
    if (t12 != 0) { print("test_async_mutex failed\n"); return 12; }

    print("All async/await tests passed!\n");
    return 0;
}
