// Async/Await and Concurrency Test
// Tests the complete async runtime implementation

// Test 1: Simple async function
async fn fetchValue() -> int {
    return 42;
}

let value = await fetchValue();
assert(value == 42);

// Test 2: Async function with operations
async fn calculate(a: int, b: int) -> int {
    let sum = a + b;
    return sum * 2;
}

let result = await calculate(10, 20);
assert(result == 60);

// Test 3: Chained async operations
async fn double(n: int) -> int {
    return n * 2;
}

async fn addTen(n: int) -> int {
    return n + 10;
}

let step1 = await double(5);
let step2 = await addTen(step1);
assert(step2 == 20);

// Test 4: Async with ternary
async fn conditional(flag: int) -> int {
    return flag > 0 ? 100 : 200;
}

let choice = await conditional(1);
assert(choice == 100);

// Test 5: Async with null coalescing
async fn getOrDefault(value: int) -> int {
    return value ?? 999;
}

let withDefault = await getOrDefault(0);
assert(withDefault == 999);

// Test 6: Multiple awaits
async fn process(n: int) -> int {
    let doubled = await double(n);
    let final = await addTen(doubled);
    return final;
}

let processed = await process(15);
assert(processed == 40);

// Test 7: Async in expressions
async fn getValue() -> int {
    return 30;
}

let computed = (await getValue()) + 12;
assert(computed == 42);

// Test 8: Async with generics
async fn identity<T>(value: T) -> T {
    return value;
}

let generic_result = await identity(42);
assert(generic_result == 42);

// Test 9: Async function composition
async fn transform(n: int) -> int {
    let a = await double(n);
    let b = await double(a);
    return b;
}

let transformed = await transform(10);
assert(transformed == 40);

// Test 10: Async with error handling
async fn safeDivide(a: int, b: int) -> int {
    return a > 0 ? a : 0;
}

let safe = await safeDivide(100, 2);
assert(safe == 100);

print("âœ“ All async tests passed!");
