// Comprehensive Syntax Test Suite
// Tests the core TypeScript-like features that are currently supported

// ============================================
// Test 1: Variable declarations
// ============================================
fn test_variables(): i32 {
    let x = 42;
    let y = x + 10;
    let mut z = 0;
    z = z + 1;
    z = z + 1;

    if (x != 42) { return 1; }
    if (y != 52) { return 2; }
    if (z != 2) { return 3; }

    return 0;
}

// ============================================
// Test 2: Constants
// ============================================
const MAX_VALUE = 100;
const MIN_VALUE = 0;

fn test_constants(): i32 {
    if (MAX_VALUE != 100) { return 1; }
    if (MIN_VALUE != 0) { return 2; }
    return 0;
}

// ============================================
// Test 3: Arithmetic operations
// ============================================
fn test_arithmetic(): i32 {
    let a = 10;
    let b = 3;

    let sum = a + b;
    let diff = a - b;
    let prod = a * b;
    let quot = a / b;
    let rem = a % b;

    if (sum != 13) { return 1; }
    if (diff != 7) { return 2; }
    if (prod != 30) { return 3; }
    if (quot != 3) { return 4; }
    if (rem != 1) { return 5; }

    return 0;
}

// ============================================
// Test 4: Comparison operators
// ============================================
fn test_comparisons(): i32 {
    let a = 10;
    let b = 20;

    if ((a < b) != true) { return 1; }
    if ((a > b) != false) { return 2; }
    if ((a == 10) != true) { return 3; }
    if ((a != b) != true) { return 4; }
    if ((a <= 10) != true) { return 5; }
    if ((b >= 20) != true) { return 6; }

    return 0;
}

// ============================================
// Test 5: Logical operators
// ============================================
fn test_logical(): i32 {
    let t = true;
    let f = false;

    if ((t and t) != true) { return 1; }
    if ((t and f) != false) { return 2; }
    if ((t or f) != true) { return 3; }
    if ((f or f) != false) { return 4; }
    if ((!t) != false) { return 5; }
    if ((!f) != true) { return 6; }

    return 0;
}

// ============================================
// Test 6: Control flow - if/else
// ============================================
fn test_if_else(): i32 {
    let x = 10;
    let mut result = 0;

    if (x > 5) {
        result = 1;
    } else {
        result = 2;
    }
    if (result != 1) { return 1; }

    if (x < 5) {
        result = 3;
    } else if (x < 15) {
        result = 4;
    } else {
        result = 5;
    }
    if (result != 4) { return 2; }

    return 0;
}

// ============================================
// Test 7: Control flow - while loops
// ============================================
fn test_while(): i32 {
    let mut sum = 0;
    let mut i = 0;

    while (i < 10) {
        sum = sum + i;
        i = i + 1;
    }

    if (sum != 45) { return 1; }
    if (i != 10) { return 2; }

    return 0;
}

// ============================================
// Test 8: Functions with parameters
// ============================================
fn add(a: i32, b: i32): i32 {
    return a + b;
}

fn multiply(a: i32, b: i32): i32 {
    return a * b;
}

fn test_functions(): i32 {
    let r1 = add(5, 3);
    let r2 = multiply(4, 7);
    let r3 = add(r1, r2);

    if (r1 != 8) { return 1; }
    if (r2 != 28) { return 2; }
    if (r3 != 36) { return 3; }

    return 0;
}

// ============================================
// Test 9: Recursive functions
// ============================================
fn factorial(n: i32): i32 {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

fn fibonacci(n: i32): i32 {
    if (n <= 0) { return 0; }
    if (n == 1) { return 1; }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

fn test_recursion(): i32 {
    let f5 = factorial(5);
    if (f5 != 120) { return 1; }

    let fib6 = fibonacci(6);
    if (fib6 != 8) { return 2; }

    return 0;
}

// ============================================
// Test 10: Arrays
// ============================================
fn test_arrays(): i32 {
    let arr = [1, 2, 3, 4, 5];

    if (arr[0] != 1) { return 1; }
    if (arr[4] != 5) { return 2; }

    // Array sum
    let mut sum = 0;
    let mut i = 0;
    while (i < 5) {
        sum = sum + arr[i];
        i = i + 1;
    }
    if (sum != 15) { return 3; }

    return 0;
}

// ============================================
// Test 11: Strings
// ============================================
fn test_strings(): i32 {
    let s1 = "Hello";
    let s2 = "World";
    let combined = s1 + ", " + s2 + "!";

    if (s1 != "Hello") { return 1; }
    if (combined != "Hello, World!") { return 2; }

    return 0;
}

// ============================================
// Test 12: Structs
// ============================================
struct Point {
    x: i32,
    y: i32
}

fn test_structs(): i32 {
    let p = Point { x: 10, y: 20 };

    if (p.x != 10) { return 1; }
    if (p.y != 20) { return 2; }

    let sum = p.x + p.y;
    if (sum != 30) { return 3; }

    return 0;
}

// ============================================
// Test 13: Enums
// ============================================
enum Color {
    Red,
    Green,
    Blue
}

fn test_enums(): i32 {
    let c = Color.Red;

    match c {
        Color.Red => return 0,
        Color.Green => return 1,
        Color.Blue => return 2,
    }
}

// ============================================
// Test 14: Enums with data
// ============================================
enum Option {
    Some(i32),
    None
}

fn test_option_enum(): i32 {
    let some_val = Option.Some(42);
    let none_val = Option.None;

    match some_val {
        Option.Some(v) => {
            if (v != 42) { return 1; }
        },
        Option.None => return 2,
    }

    match none_val {
        Option.Some(v) => return 3,
        Option.None => { /* ok */ },
    }

    return 0;
}

// ============================================
// Test 15: Pattern matching with guards
// ============================================
fn classify(n: i32): i32 {
    match n {
        x if x < 0 => return 0 - 1,
        0 => return 0,
        x if x < 10 => return 1,
        x if x < 100 => return 2,
        _ => return 3,
    }
}

fn test_pattern_guards(): i32 {
    if (classify(0 - 5) != 0 - 1) { return 1; }
    if (classify(0) != 0) { return 2; }
    if (classify(5) != 1) { return 3; }
    if (classify(50) != 2) { return 4; }
    if (classify(500) != 3) { return 5; }

    return 0;
}

// ============================================
// Test 16: Conditional expressions
// ============================================
fn max_val(a: i32, b: i32): i32 {
    if (a > b) {
        return a;
    }
    return b;
}

fn min_val(a: i32, b: i32): i32 {
    if (a < b) {
        return a;
    }
    return b;
}

fn test_conditionals(): i32 {
    let a = 10;
    let b = 20;

    let max = max_val(a, b);
    if (max != 20) { return 1; }

    let min = min_val(a, b);
    if (min != 10) { return 2; }

    return 0;
}

// ============================================
// Test 17: Bitwise operators
// ============================================
fn test_bitwise(): i32 {
    let a = 0b1010;
    let b = 0b1100;

    let and_result = a & b;
    if (and_result != 8) { return 1; }

    let or_result = a | b;
    if (or_result != 14) { return 2; }

    let xor_result = a ^ b;
    if (xor_result != 6) { return 3; }

    let lshift = a << 2;
    if (lshift != 40) { return 4; }

    let rshift = a >> 1;
    if (rshift != 5) { return 5; }

    return 0;
}

// ============================================
// Test 18: Nested control flow
// ============================================
fn test_nested_control(): i32 {
    let mut total = 0;
    let mut i = 0;

    while (i < 3) {
        let mut j = 0;
        while (j < 3) {
            total = total + 1;
            j = j + 1;
        }
        i = i + 1;
    }

    if (total != 9) { return 1; }
    return 0;
}

// ============================================
// Test 19: Function composition
// ============================================
fn double(x: i32): i32 {
    return x * 2;
}

fn increment(x: i32): i32 {
    return x + 1;
}

fn test_composition(): i32 {
    let x = 5;
    let r1 = double(increment(x));  // (5 + 1) * 2 = 12
    let r2 = increment(double(x));  // (5 * 2) + 1 = 11

    if (r1 != 12) { return 1; }
    if (r2 != 11) { return 2; }

    return 0;
}

// ============================================
// Test 20: Complex expressions
// ============================================
fn categorize(x: i32): i32 {
    if (x < 0) {
        return 0 - 1;
    } else if (x == 0) {
        return 0;
    } else {
        return 1;
    }
}

fn test_complex_expressions(): i32 {
    let a = 2;
    let b = 3;
    let c = 4;

    // Test operator precedence
    let r1 = a + b * c;  // 2 + 12 = 14
    if (r1 != 14) { return 1; }

    let r2 = (a + b) * c;  // 5 * 4 = 20
    if (r2 != 20) { return 2; }

    // Categorization
    let x = 5;
    let category = categorize(x);
    if (category != 1) { return 3; }

    return 0;
}

// ============================================
// Main test runner
// ============================================
fn main(): i32 {
    let t1 = test_variables();
    if (t1 != 0) { print("test_variables failed\n"); return 1; }

    let t2 = test_constants();
    if (t2 != 0) { print("test_constants failed\n"); return 2; }

    let t3 = test_arithmetic();
    if (t3 != 0) { print("test_arithmetic failed\n"); return 3; }

    let t4 = test_comparisons();
    if (t4 != 0) { print("test_comparisons failed\n"); return 4; }

    let t5 = test_logical();
    if (t5 != 0) { print("test_logical failed\n"); return 5; }

    let t6 = test_if_else();
    if (t6 != 0) { print("test_if_else failed\n"); return 6; }

    let t7 = test_while();
    if (t7 != 0) { print("test_while failed\n"); return 7; }

    let t8 = test_functions();
    if (t8 != 0) { print("test_functions failed\n"); return 8; }

    let t9 = test_recursion();
    if (t9 != 0) { print("test_recursion failed\n"); return 9; }

    let t10 = test_arrays();
    if (t10 != 0) { print("test_arrays failed\n"); return 10; }

    let t11 = test_strings();
    if (t11 != 0) { print("test_strings failed\n"); return 11; }

    let t12 = test_structs();
    if (t12 != 0) { print("test_structs failed\n"); return 12; }

    let t13 = test_enums();
    if (t13 != 0) { print("test_enums failed\n"); return 13; }

    let t14 = test_option_enum();
    if (t14 != 0) { print("test_option_enum failed\n"); return 14; }

    let t15 = test_pattern_guards();
    if (t15 != 0) { print("test_pattern_guards failed\n"); return 15; }

    let t16 = test_conditionals();
    if (t16 != 0) { print("test_conditionals failed\n"); return 16; }

    let t17 = test_bitwise();
    if (t17 != 0) { print("test_bitwise failed\n"); return 17; }

    let t18 = test_nested_control();
    if (t18 != 0) { print("test_nested_control failed\n"); return 18; }

    let t19 = test_composition();
    if (t19 != 0) { print("test_composition failed\n"); return 19; }

    let t20 = test_complex_expressions();
    if (t20 != 0) { print("test_complex_expressions failed\n"); return 20; }

    print("All 20 comprehensive syntax tests passed!\n");
    return 0;
}
