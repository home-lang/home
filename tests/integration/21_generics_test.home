// Generic Functions and Structs Test
// Tests the complete generics implementation

// Test 1: Simple generic function
fn identity<T>(value: T) -> T {
    return value;
}

let num = identity(42);
assert(num == 42);

let text = identity(100);
assert(text == 100);

// Test 2: Generic function with multiple type parameters
fn pair<T, U>(first: T, second: U) -> int {
    return first + second;
}

let result = pair(10, 20);
assert(result == 30);

// Test 3: Generic struct
struct Box<T> {
    value: T
}

// Test 4: Generic function with constraints (simulated)
fn max<T>(a: T, b: T) -> T {
    return a > b ? a : b;
}

let maximum = max(5, 10);
assert(maximum == 10);

// Test 5: Nested generics
fn transform<T>(input: T) -> T {
    return input * 2;
}

let doubled = transform(21);
assert(doubled == 42);

// Test 6: Generic with tuple
fn makeP air<T>(a: T, b: T) -> int {
    let sum = a + b;
    return sum;
}

let pairSum = makePair(15, 27);
assert(pairSum == 42);

// Test 7: Multiple generic functions
fn add<T>(a: T, b: T) -> T {
    return a + b;
}

fn multiply<T>(a: T, b: T) -> T {
    return a * b;
}

let sum = add(5, 10);
assert(sum == 15);

let product = multiply(6, 7);
assert(product == 42);

// Test 8: Generic with ternary
fn conditional<T>(flag: int, ifTrue: T, ifFalse: T) -> T {
    return flag > 0 ? ifTrue : ifFalse;
}

let choice = conditional(1, 100, 200);
assert(choice == 100);

// Test 9: Generic chain
fn increment<T>(n: T) -> T {
    return n + 1;
}

fn decrement<T>(n: T) -> T {
    return n - 1;
}

let val = increment(41);
assert(val == 42);

val = decrement(43);
assert(val == 42);

// Test 10: Generic with null coalescing
fn getOrDefault<T>(value: T, default: T) -> T {
    return value ?? default;
}

let withDefault = getOrDefault(0, 42);
assert(withDefault == 42);

print("âœ“ All generics tests passed!");
