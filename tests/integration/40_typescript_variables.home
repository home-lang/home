// Comprehensive TypeScript-like Variable Declaration Tests
// Tests: let, const, mut, type annotations, initialization

// ============================================
// Test 1: Basic let declarations
// ============================================
fn test_let_declarations(): i32 {
    // Immutable by default (like const in TS)
    let x = 42;
    let y: i32 = 100;
    let z = x + y;

    if (z != 142) {
        return 1;
    }
    return 0;
}

// ============================================
// Test 2: Mutable let declarations
// ============================================
fn test_mutable_declarations(): i32 {
    let mut counter = 0;
    counter = counter + 1;
    counter = counter + 1;
    counter = counter + 1;

    if (counter != 3) {
        return 1;
    }
    return 0;
}

// ============================================
// Test 3: Const declarations (compile-time constants)
// ============================================
const PI = 3;
const MAX_SIZE = 100;
const GREETING = "Hello";

fn test_const_declarations(): i32 {
    let area = PI * 10;
    if (area != 30) {
        return 1;
    }

    if (MAX_SIZE != 100) {
        return 2;
    }

    return 0;
}

// ============================================
// Test 4: Type annotations
// ============================================
fn test_type_annotations(): i32 {
    let a: i32 = 42;
    let b: i64 = 1000000000000;
    let c: bool = true;
    let d: string = "test";
    let e: f64 = 3.14159;

    if (a != 42) {
        return 1;
    }

    if (c != true) {
        return 2;
    }

    return 0;
}

// ============================================
// Test 5: Type inference
// ============================================
fn test_type_inference(): i32 {
    let inferred_int = 42;          // Inferred as i32
    let inferred_float = 3.14;      // Inferred as f64
    let inferred_bool = true;       // Inferred as bool
    let inferred_string = "hello";  // Inferred as string

    // Arithmetic should work with inferred types
    let result = inferred_int * 2;

    if (result != 84) {
        return 1;
    }

    return 0;
}

// ============================================
// Test 6: Multiple declarations
// ============================================
fn test_multiple_declarations(): i32 {
    let a = 1;
    let b = 2;
    let c = 3;
    let d = 4;
    let e = 5;

    let sum = a + b + c + d + e;

    if (sum != 15) {
        return 1;
    }

    return 0;
}

// ============================================
// Test 7: Shadowing (re-declaration in same scope)
// ============================================
fn test_shadowing(): i32 {
    let x = 5;
    let x = x * 2;  // Shadowing x with new value
    let x = x + 10; // Shadowing again

    if (x != 20) {
        return 1;
    }

    return 0;
}

// ============================================
// Test 8: Block scoping
// ============================================
fn test_block_scoping(): i32 {
    let outer = 10;

    {
        let inner = 20;
        let result = outer + inner;
        if (result != 30) {
            return 1;
        }
    }

    // inner is not accessible here (block scoped)
    if (outer != 10) {
        return 2;
    }

    return 0;
}

// ============================================
// Test 9: Nested scope shadowing
// ============================================
fn test_nested_shadowing(): i32 {
    let x = 1;
    {
        let x = 2;
        {
            let x = 3;
            if (x != 3) {
                return 1;
            }
        }
        if (x != 2) {
            return 2;
        }
    }
    if (x != 1) {
        return 3;
    }
    return 0;
}

// ============================================
// Test 10: Initialization from expressions
// ============================================
fn test_expression_initialization(): i32 {
    let a = 10 + 5;
    let b = a * 2;
    let c = if (b > 20) { 100 } else { 0 };
    let d = compute_value(5);

    if (a != 15) { return 1; }
    if (b != 30) { return 2; }
    if (c != 100) { return 3; }
    if (d != 25) { return 4; }

    return 0;
}

fn compute_value(x: i32): i32 {
    return x * 5;
}

// ============================================
// Main test runner
// ============================================
fn main(): i32 {
    let t1 = test_let_declarations();
    if (t1 != 0) {
        print("test_let_declarations failed\n");
        return 1;
    }

    let t2 = test_mutable_declarations();
    if (t2 != 0) {
        print("test_mutable_declarations failed\n");
        return 2;
    }

    let t3 = test_const_declarations();
    if (t3 != 0) {
        print("test_const_declarations failed\n");
        return 3;
    }

    let t4 = test_type_annotations();
    if (t4 != 0) {
        print("test_type_annotations failed\n");
        return 4;
    }

    let t5 = test_type_inference();
    if (t5 != 0) {
        print("test_type_inference failed\n");
        return 5;
    }

    let t6 = test_multiple_declarations();
    if (t6 != 0) {
        print("test_multiple_declarations failed\n");
        return 6;
    }

    let t7 = test_shadowing();
    if (t7 != 0) {
        print("test_shadowing failed\n");
        return 7;
    }

    let t8 = test_block_scoping();
    if (t8 != 0) {
        print("test_block_scoping failed\n");
        return 8;
    }

    let t9 = test_nested_shadowing();
    if (t9 != 0) {
        print("test_nested_shadowing failed\n");
        return 9;
    }

    let t10 = test_expression_initialization();
    if (t10 != 0) {
        print("test_expression_initialization failed\n");
        return 10;
    }

    print("All variable declaration tests passed!\n");
    return 0;
}
