// Advanced Try-Catch-Finally Tests
// Tests exception handling, finally blocks, and nested try-catch

// Test 1: Basic try-catch
try {
    let value = 10;
    assert(value == 10);
} catch (err) {
    print("Should not reach here");
}

// Test 2: Try-catch-finally all blocks
let executed = 0;
try {
    executed = executed + 1;
} catch (err) {
    executed = executed + 10;
} finally {
    executed = executed + 100;
}
assert(executed == 101);

// Test 3: Finally always executes
let counter = 0;
try {
    counter = counter + 1;
} finally {
    counter = counter + 10;
}
assert(counter == 11);

// Test 4: Multiple catch blocks
try {
    let val = 42;
} catch (NetworkError) {
    print("Network error");
} catch (ValueError) {
    print("Value error");
} catch {
    print("Other error");
}

// Test 5: Nested try-catch
try {
    try {
        let inner = 5;
    } catch {
        print("Inner catch");
    }
} catch {
    print("Outer catch");
}

// Test 6: Try-catch in function
fn safeDivide(a: int, b: int): int {
    try {
        return a / b;
    } catch {
        return 0;
    }
}

let result6 = safeDivide(10, 2);
assert(result6 == 5);

// Test 7: Try-catch with variable modification
let mutable = 5;
try {
    mutable = mutable * 2;
} catch {
    mutable = 0;
} finally {
    mutable = mutable + 1;
}
assert(mutable == 11);

// Test 8: Multiple try-catch blocks in sequence
let seq = 0;
try {
    seq = seq + 1;
} catch {
    seq = seq + 10;
}

try {
    seq = seq + 2;
} catch {
    seq = seq + 20;
}

assert(seq == 3);

// Test 9: Try-catch with complex logic
let complex = 0;
try {
    let temp = 5;
    complex = temp * 2;
    complex = complex + 10;
} catch (err) {
    complex = 999;
} finally {
    complex = complex + 1;
}
assert(complex == 21);

// Test 10: Try-catch-finally with all paths
fn testAllPaths(flag: int): int {
    let result = 0;
    try {
        result = result + 1;
    } catch {
        result = result + 10;
    } finally {
        result = result + 100;
    }
    return result;
}

assert(testAllPaths(1) == 101);

// Test 11: Deeply nested try-catch
try {
    try {
        try {
            let deep = 123;
        } catch {
            print("Level 3");
        }
    } catch {
        print("Level 2");
    }
} catch {
    print("Level 1");
}

// Test 12: Try-finally without catch
let noC catch = 0;
try {
    noCatch = 77;
} finally {
    noCatch = noCatch + 3;
}
assert(noCatch == 80);

// Test 13: Try-catch with arithmetic
try {
    let a = 10;
    let b = 20;
    let c = a + b;
    assert(c == 30);
} catch {
    print("Arithmetic failed");
}

// Test 14: Multiple finally blocks
let multi = 0;
try {
    multi = multi + 1;
} finally {
    multi = multi + 5;
}

try {
    multi = multi + 2;
} finally {
    multi = multi + 10;
}

assert(multi == 18);

// Test 15: Try-catch with function calls
fn mayFail(n: int): int {
    return n * 2;
}

try {
    let res = mayFail(21);
    assert(res == 42);
} catch {
    print("Function failed");
}

print("âœ“ All advanced try-catch tests passed!");
