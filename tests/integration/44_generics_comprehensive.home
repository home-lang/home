// Comprehensive Generics and Traits Tests
// Tests: generic functions, generic structs, trait definitions, trait implementations

// ============================================
// Test 1: Simple generic functions
// ============================================
fn identity<T>(value: T): T {
    return value;
}

fn first<T>(a: T, b: T): T {
    return a;
}

fn second<T>(a: T, b: T): T {
    return b;
}

fn test_simple_generics(): i32 {
    let int_id = identity(42);
    if (int_id != 42) { return 1; }

    let str_id = identity(100);
    if (str_id != 100) { return 2; }

    let f = first(10, 20);
    if (f != 10) { return 3; }

    let s = second(10, 20);
    if (s != 20) { return 4; }

    return 0;
}

// ============================================
// Test 2: Generic functions with multiple type params
// ============================================
fn swap<T, U>(a: T, b: U): (U, T) {
    return (b, a);
}

fn pair_sum<T>(a: T, b: T): T {
    return a + b;
}

fn test_multi_type_params(): i32 {
    let sum = pair_sum(10, 20);
    if (sum != 30) { return 1; }

    let product = pair_sum(5, 7);
    if (product != 12) { return 2; }

    return 0;
}

// ============================================
// Test 3: Generic structs
// ============================================
struct Box<T> {
    value: T
}

struct Pair<T, U> {
    first: T,
    second: U
}

struct Triple<T> {
    a: T,
    b: T,
    c: T
}

fn test_generic_structs(): i32 {
    let int_box = Box { value: 42 };
    if (int_box.value != 42) { return 1; }

    let pair = Pair { first: 10, second: 20 };
    if (pair.first != 10) { return 2; }
    if (pair.second != 20) { return 3; }

    let triple = Triple { a: 1, b: 2, c: 3 };
    if (triple.a + triple.b + triple.c != 6) { return 4; }

    return 0;
}

// ============================================
// Test 4: Generic enums
// ============================================
enum Option<T> {
    Some(T),
    None
}

enum Result<T, E> {
    Ok(T),
    Err(E)
}

fn test_generic_enums(): i32 {
    let some_val: Option<i32> = Option.Some(42);
    let none_val: Option<i32> = Option.None;

    match some_val {
        Option.Some(v) => {
            if (v != 42) { return 1; }
        },
        Option.None => return 2,
    }

    match none_val {
        Option.Some(v) => return 3,
        Option.None => { /* expected */ },
    }

    let ok_result: Result<i32, string> = Result.Ok(100);
    let err_result: Result<i32, string> = Result.Err("error");

    match ok_result {
        Result.Ok(v) => {
            if (v != 100) { return 4; }
        },
        Result.Err(e) => return 5,
    }

    match err_result {
        Result.Ok(v) => return 6,
        Result.Err(e) => { /* expected */ },
    }

    return 0;
}

// ============================================
// Test 5: Trait definitions
// ============================================
trait Printable {
    fn to_string(self): string;
}

trait Comparable {
    fn compare(self, other: Self): i32;
}

trait Numeric {
    fn zero(): Self;
    fn add(self, other: Self): Self;
    fn multiply(self, other: Self): Self;
}

fn test_trait_definitions(): i32 {
    // Traits are defined, this test just verifies compilation
    return 0;
}

// ============================================
// Test 6: Trait implementations
// ============================================
struct Point {
    x: i32,
    y: i32
}

impl Printable for Point {
    fn to_string(self): string {
        return "Point";
    }
}

impl Comparable for Point {
    fn compare(self, other: Point): i32 {
        let self_dist = self.x * self.x + self.y * self.y;
        let other_dist = other.x * other.x + other.y * other.y;
        if (self_dist < other_dist) {
            return -1;
        } else if (self_dist > other_dist) {
            return 1;
        }
        return 0;
    }
}

fn test_trait_impl(): i32 {
    let p1 = Point { x: 3, y: 4 };
    let p2 = Point { x: 1, y: 1 };

    let cmp = p1.compare(p2);
    // p1 distance = 25, p2 distance = 2, so p1 > p2
    if (cmp != 1) { return 1; }

    let p3 = Point { x: 3, y: 4 };
    let cmp2 = p1.compare(p3);
    if (cmp2 != 0) { return 2; }

    return 0;
}

// ============================================
// Test 7: Generic functions with trait bounds
// ============================================
fn max<T: Comparable>(a: T, b: T): T {
    if (a.compare(b) > 0) {
        return a;
    }
    return b;
}

fn min<T: Comparable>(a: T, b: T): T {
    if (a.compare(b) < 0) {
        return a;
    }
    return b;
}

fn test_trait_bounds(): i32 {
    let p1 = Point { x: 5, y: 0 };
    let p2 = Point { x: 3, y: 0 };

    let bigger = max(p1, p2);
    if (bigger.x != 5) { return 1; }

    let smaller = min(p1, p2);
    if (smaller.x != 3) { return 2; }

    return 0;
}

// ============================================
// Test 8: Default trait methods
// ============================================
trait Describable {
    fn name(self): string;

    fn describe(self): string {
        return "Object: " + self.name();
    }
}

struct Animal {
    species: string
}

impl Describable for Animal {
    fn name(self): string {
        return self.species;
    }
    // Uses default describe() implementation
}

fn test_default_trait_methods(): i32 {
    let dog = Animal { species: "Dog" };
    let name = dog.name();
    if (name != "Dog") { return 1; }

    let desc = dog.describe();
    if (desc != "Object: Dog") { return 2; }

    return 0;
}

// ============================================
// Test 9: Multiple trait bounds
// ============================================
trait Addable {
    fn add_to(self, other: Self): Self;
}

trait Subtractable {
    fn subtract_from(self, other: Self): Self;
}

struct Number {
    value: i32
}

impl Addable for Number {
    fn add_to(self, other: Number): Number {
        return Number { value: self.value + other.value };
    }
}

impl Subtractable for Number {
    fn subtract_from(self, other: Number): Number {
        return Number { value: self.value - other.value };
    }
}

fn calculate<T: Addable + Subtractable>(a: T, b: T, c: T): T {
    let sum = a.add_to(b);
    return sum.subtract_from(c);
}

fn test_multiple_trait_bounds(): i32 {
    let n1 = Number { value: 10 };
    let n2 = Number { value: 5 };
    let n3 = Number { value: 3 };

    let result = calculate(n1, n2, n3);
    // (10 + 5) - 3 = 12
    if (result.value != 12) { return 1; }

    return 0;
}

// ============================================
// Test 10: Associated types in traits
// ============================================
trait Container {
    type Item;

    fn get(self): Self.Item;
    fn set(self, item: Self.Item): Self;
}

struct IntBox {
    value: i32
}

impl Container for IntBox {
    type Item = i32;

    fn get(self): i32 {
        return self.value;
    }

    fn set(self, item: i32): IntBox {
        return IntBox { value: item };
    }
}

fn test_associated_types(): i32 {
    let box1 = IntBox { value: 42 };
    let val = box1.get();
    if (val != 42) { return 1; }

    let box2 = box1.set(100);
    if (box2.value != 100) { return 2; }

    return 0;
}

// ============================================
// Main test runner
// ============================================
fn main(): i32 {
    let t1 = test_simple_generics();
    if (t1 != 0) {
        print("test_simple_generics failed\n");
        return 1;
    }

    let t2 = test_multi_type_params();
    if (t2 != 0) {
        print("test_multi_type_params failed\n");
        return 2;
    }

    let t3 = test_generic_structs();
    if (t3 != 0) {
        print("test_generic_structs failed\n");
        return 3;
    }

    let t4 = test_generic_enums();
    if (t4 != 0) {
        print("test_generic_enums failed\n");
        return 4;
    }

    let t5 = test_trait_definitions();
    if (t5 != 0) {
        print("test_trait_definitions failed\n");
        return 5;
    }

    let t6 = test_trait_impl();
    if (t6 != 0) {
        print("test_trait_impl failed\n");
        return 6;
    }

    let t7 = test_trait_bounds();
    if (t7 != 0) {
        print("test_trait_bounds failed\n");
        return 7;
    }

    let t8 = test_default_trait_methods();
    if (t8 != 0) {
        print("test_default_trait_methods failed\n");
        return 8;
    }

    let t9 = test_multiple_trait_bounds();
    if (t9 != 0) {
        print("test_multiple_trait_bounds failed\n");
        return 9;
    }

    let t10 = test_associated_types();
    if (t10 != 0) {
        print("test_associated_types failed\n");
        return 10;
    }

    print("All generics and traits tests passed!\n");
    return 0;
}
