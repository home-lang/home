// Comprehensive Function Tests
// Tests: declarations, parameters, return types, closures, higher-order functions

// ============================================
// Test 1: Basic function declarations
// ============================================
fn simple_function(): i32 {
    return 42;
}

fn function_with_params(a: i32, b: i32): i32 {
    return a + b;
}

fn function_with_body(x: i32): i32 {
    let doubled = x * 2;
    let result = doubled + 10;
    return result;
}

fn test_basic_functions(): i32 {
    let r1 = simple_function();
    if (r1 != 42) { return 1; }

    let r2 = function_with_params(10, 20);
    if (r2 != 30) { return 2; }

    let r3 = function_with_body(5);
    if (r3 != 20) { return 3; }

    return 0;
}

// ============================================
// Test 2: Multiple parameters
// ============================================
fn three_params(a: i32, b: i32, c: i32): i32 {
    return a + b + c;
}

fn five_params(a: i32, b: i32, c: i32, d: i32, e: i32): i32 {
    return a + b + c + d + e;
}

fn mixed_types(x: i32, flag: bool, name: string): i32 {
    if (flag) {
        return x * 2;
    }
    return x;
}

fn test_multiple_params(): i32 {
    let r1 = three_params(1, 2, 3);
    if (r1 != 6) { return 1; }

    let r2 = five_params(1, 2, 3, 4, 5);
    if (r2 != 15) { return 2; }

    let r3 = mixed_types(10, true, "test");
    if (r3 != 20) { return 3; }

    let r4 = mixed_types(10, false, "test");
    if (r4 != 10) { return 4; }

    return 0;
}

// ============================================
// Test 3: Default parameters
// ============================================
fn greet(name: string = "World"): string {
    return "Hello, " + name + "!";
}

fn calculate(a: i32, b: i32 = 10, c: i32 = 1): i32 {
    return (a + b) * c;
}

fn test_default_params(): i32 {
    let r1 = calculate(5, 10, 2);
    if (r1 != 30) { return 1; }

    let r2 = calculate(5, 15, 1);
    if (r2 != 20) { return 2; }

    let r3 = calculate(5, 5, 3);
    if (r3 != 30) { return 3; }

    return 0;
}

// ============================================
// Test 4: Recursive functions
// ============================================
fn factorial(n: i32): i32 {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

fn fibonacci(n: i32): i32 {
    if (n <= 0) { return 0; }
    if (n == 1) { return 1; }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

fn sum_to_n(n: i32): i32 {
    if (n <= 0) { return 0; }
    return n + sum_to_n(n - 1);
}

fn test_recursive_functions(): i32 {
    let f5 = factorial(5);
    if (f5 != 120) { return 1; }

    let fib6 = fibonacci(6);
    if (fib6 != 8) { return 2; }

    let sum10 = sum_to_n(10);
    if (sum10 != 55) { return 3; }

    return 0;
}

// ============================================
// Test 5: Higher-order functions
// ============================================
fn apply_twice(f: fn(i32): i32, x: i32): i32 {
    return f(f(x));
}

fn compose(f: fn(i32): i32, g: fn(i32): i32, x: i32): i32 {
    return f(g(x));
}

fn double(x: i32): i32 {
    return x * 2;
}

fn increment(x: i32): i32 {
    return x + 1;
}

fn square(x: i32): i32 {
    return x * x;
}

fn test_higher_order(): i32 {
    // apply_twice(double, 3) = double(double(3)) = double(6) = 12
    let r1 = apply_twice(double, 3);
    if (r1 != 12) { return 1; }

    // compose(double, increment, 5) = double(increment(5)) = double(6) = 12
    let r2 = compose(double, increment, 5);
    if (r2 != 12) { return 2; }

    // compose(increment, double, 5) = increment(double(5)) = increment(10) = 11
    let r3 = compose(increment, double, 5);
    if (r3 != 11) { return 3; }

    return 0;
}

// ============================================
// Test 6: Functions returning functions
// ============================================
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x: i32): i32 { return x + n; };
}

fn make_multiplier(n: i32): fn(i32): i32 {
    return fn(x: i32): i32 { return x * n; };
}

fn test_returning_functions(): i32 {
    let add5 = make_adder(5);
    let result1 = add5(10);
    if (result1 != 15) { return 1; }

    let times3 = make_multiplier(3);
    let result2 = times3(7);
    if (result2 != 21) { return 2; }

    return 0;
}

// ============================================
// Test 7: Closures capturing variables
// ============================================
fn create_counter(): fn(): i32 {
    let mut count = 0;
    return fn(): i32 {
        count = count + 1;
        return count;
    };
}

fn test_closures(): i32 {
    let counter = create_counter();

    let c1 = counter();
    if (c1 != 1) { return 1; }

    let c2 = counter();
    if (c2 != 2) { return 2; }

    let c3 = counter();
    if (c3 != 3) { return 3; }

    return 0;
}

// ============================================
// Test 8: Lambda expressions
// ============================================
fn test_lambdas(): i32 {
    // Simple lambda
    let add = fn(a: i32, b: i32): i32 { return a + b; };
    let r1 = add(3, 4);
    if (r1 != 7) { return 1; }

    // Lambda with captured variable
    let factor = 10;
    let scale = fn(x: i32): i32 { return x * factor; };
    let r2 = scale(5);
    if (r2 != 50) { return 2; }

    // Nested lambdas
    let outer = fn(x: i32): fn(i32): i32 {
        return fn(y: i32): i32 { return x + y; };
    };
    let inner = outer(10);
    let r3 = inner(5);
    if (r3 != 15) { return 3; }

    return 0;
}

// ============================================
// Test 9: Early returns
// ============================================
fn find_first_even(arr: [i32]): i32 {
    let i = 0;
    while (i < 5) {
        if (arr[i] % 2 == 0) {
            return arr[i];
        }
        i = i + 1;
    }
    return -1;
}

fn validate_positive(x: i32): bool {
    if (x <= 0) {
        return false;
    }
    return true;
}

fn test_early_returns(): i32 {
    let arr = [1, 3, 4, 7, 9];
    let first_even = find_first_even(arr);
    if (first_even != 4) { return 1; }

    let arr2 = [1, 3, 5, 7, 9];
    let no_even = find_first_even(arr2);
    if (no_even != -1) { return 2; }

    if (validate_positive(5) != true) { return 3; }
    if (validate_positive(-1) != false) { return 4; }

    return 0;
}

// ============================================
// Test 10: Mutually recursive functions
// ============================================
fn is_even(n: i32): bool {
    if (n == 0) { return true; }
    return is_odd(n - 1);
}

fn is_odd(n: i32): bool {
    if (n == 0) { return false; }
    return is_even(n - 1);
}

fn test_mutual_recursion(): i32 {
    if (is_even(4) != true) { return 1; }
    if (is_even(5) != false) { return 2; }
    if (is_odd(3) != true) { return 3; }
    if (is_odd(4) != false) { return 4; }

    return 0;
}

// ============================================
// Main test runner
// ============================================
fn main(): i32 {
    let t1 = test_basic_functions();
    if (t1 != 0) {
        print("test_basic_functions failed\n");
        return 1;
    }

    let t2 = test_multiple_params();
    if (t2 != 0) {
        print("test_multiple_params failed\n");
        return 2;
    }

    let t3 = test_default_params();
    if (t3 != 0) {
        print("test_default_params failed\n");
        return 3;
    }

    let t4 = test_recursive_functions();
    if (t4 != 0) {
        print("test_recursive_functions failed\n");
        return 4;
    }

    let t5 = test_higher_order();
    if (t5 != 0) {
        print("test_higher_order failed\n");
        return 5;
    }

    let t6 = test_returning_functions();
    if (t6 != 0) {
        print("test_returning_functions failed\n");
        return 6;
    }

    let t7 = test_closures();
    if (t7 != 0) {
        print("test_closures failed\n");
        return 7;
    }

    let t8 = test_lambdas();
    if (t8 != 0) {
        print("test_lambdas failed\n");
        return 8;
    }

    let t9 = test_early_returns();
    if (t9 != 0) {
        print("test_early_returns failed\n");
        return 9;
    }

    let t10 = test_mutual_recursion();
    if (t10 != 0) {
        print("test_mutual_recursion failed\n");
        return 10;
    }

    print("All function tests passed!\n");
    return 0;
}
