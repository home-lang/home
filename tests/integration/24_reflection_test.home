// Reflection Test
// Tests the complete reflection API implementation

// Test 1: @TypeOf with integer
let x = 42;
let type_x = @TypeOf(x);
// Type checking would verify this is int

// Test 2: @TypeOf with string
let name = "Home";
let type_name = @TypeOf(name);
// Type checking would verify this is string

// Test 3: @sizeOf built-in types
const INT_SIZE = @sizeOf(int);
assert(INT_SIZE == 8);

const FLOAT_SIZE = @sizeOf(float);
assert(FLOAT_SIZE == 8);

const BOOL_SIZE = @sizeOf(bool);
assert(BOOL_SIZE == 1);

// Test 4: @alignOf built-in types
const INT_ALIGN = @alignOf(int);
assert(INT_ALIGN == 8);

const FLOAT_ALIGN = @alignOf(float);
assert(FLOAT_ALIGN == 8);

// Test 5: Struct reflection
struct Point {
    x: int,
    y: int,
}

const POINT_SIZE = @sizeOf(Point);
assert(POINT_SIZE == 16);

// Test 6: @offsetOf
const X_OFFSET = @offsetOf(Point, "x");
assert(X_OFFSET == 0);

const Y_OFFSET = @offsetOf(Point, "y");
assert(Y_OFFSET == 8);

// Test 7: @typeInfo
struct User {
    id: int,
    name: string,
    age: int,
}

let user_type = @typeInfo(User);
// Would return metadata about User struct

// Test 8: @fieldName
let first_field = @fieldName(User, 0);
// Would return "id"

// Test 9: @fieldType
let id_type = @fieldType(User, "id");
// Would return int type

// Test 10: Nested struct reflection
struct Address {
    street: string,
    city: string,
}

struct Person {
    name: string,
    address: Address,
}

const PERSON_SIZE = @sizeOf(Person);
// Size would include nested struct

print("âœ“ All reflection tests passed!");
