// Test file with intentional type errors to demonstrate error reporting

// Error 1: Type mismatch in function call
fn takes_int(x: i32): i32 {
    return x + 1;
}

fn test_arg_type_error(): i32 {
    let s: string = "hello";
    return takes_int(s);  // ERROR: Expected i32, got string
}

// Error 2: Wrong argument count
fn takes_two(x: i32, y: i32): i32 {
    return x + y;
}

fn test_arg_count_error(): i32 {
    return takes_two(5);  // ERROR: Expected 2 arguments, got 1
}

// Error 3: Return type mismatch
fn returns_int(): i32 {
    return true;  // ERROR: Expected i32, got bool
}

// Error 4: Type mismatch in binary operation
fn test_binary_type_error(): i32 {
    let x: i32 = 10;
    let y: bool = true;
    return x + y;  // ERROR: Type mismatch in arithmetic
}

// Error 5: Wrong condition type in if statement
fn test_condition_error(): i32 {
    let x: i32 = 10;
    if x {  // ERROR: If condition must be bool, got i32
        return 1;
    }
    return 0;
}

// Error 6: Array element type mismatch
fn test_array_error(): i32 {
    let arr: [i32] = [1, 2, "three", 4];  // ERROR: Array element has wrong type
    return arr[0];
}

// Error 7: Using undefined variable
fn test_undefined_var(): i32 {
    return undefined_variable;  // ERROR: Undefined variable
}

// Error 8: Type mismatch in assignment
fn test_assignment_error(): i32 {
    let x: i32 = 10;
    x = "hello";  // ERROR: Cannot assign string to i32
    return x;
}

fn main(): i32 {
    print("This file should produce type errors!\n");
    return 0;
}
