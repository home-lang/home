// List Comprehensions Test Suite
// Tests array comprehensions with various patterns

// ============================================================================
// BASIC ARRAY COMPREHENSIONS
// ============================================================================

it("should create array with simple comprehension") {
    let arr = [x for x in 0..5];
    assert(arr.len() == 5);
    assert(arr[0] == 0);
    assert(arr[4] == 4);
}

it("should transform elements in comprehension") {
    let arr = [x * 2 for x in 0..5];
    assert(arr[0] == 0);
    assert(arr[1] == 2);
    assert(arr[2] == 4);
    assert(arr[3] == 6);
    assert(arr[4] == 8);
}

it("should filter elements in comprehension") {
    let arr = [x for x in 0..10 if x % 2 == 0];
    assert(arr.len() == 5);
    assert(arr[0] == 0);
    assert(arr[1] == 2);
    assert(arr[2] == 4);
}

it("should transform and filter") {
    let arr = [x * x for x in 0..10 if x % 2 == 1];
    assert(arr.len() == 5);
    assert(arr[0] == 1);   // 1*1
    assert(arr[1] == 9);   // 3*3
    assert(arr[2] == 25);  // 5*5
    assert(arr[3] == 49);  // 7*7
    assert(arr[4] == 81);  // 9*9
}

// ============================================================================
// COMPREHENSION WITH EXISTING ARRAY
// ============================================================================

it("should comprehend from existing array") {
    let source = [1, 2, 3, 4, 5];
    let doubled = [x * 2 for x in source];
    assert(doubled.len() == 5);
    assert(doubled[0] == 2);
    assert(doubled[4] == 10);
}

it("should filter from existing array") {
    let source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let evens = [x for x in source if x % 2 == 0];
    assert(evens.len() == 5);
    assert(evens[0] == 2);
    assert(evens[4] == 10);
}

// ============================================================================
// COMPREHENSION WITH COMPLEX EXPRESSIONS
// ============================================================================

it("should use complex expression in comprehension") {
    let arr = [x * x + 2 * x + 1 for x in 0..5];  // (x+1)^2
    assert(arr[0] == 1);   // 1
    assert(arr[1] == 4);   // 4
    assert(arr[2] == 9);   // 9
    assert(arr[3] == 16);  // 16
    assert(arr[4] == 25);  // 25
}

it("should use function call in comprehension") {
    fn square(x: i32): i32 { return x * x; }
    let arr = [square(x) for x in 1..6];
    assert(arr[0] == 1);
    assert(arr[1] == 4);
    assert(arr[2] == 9);
    assert(arr[3] == 16);
    assert(arr[4] == 25);
}

// ============================================================================
// COMPREHENSION WITH CONDITIONALS
// ============================================================================

it("should use complex filter condition") {
    let arr = [x for x in 0..100 if x % 3 == 0 and x % 5 == 0];
    assert(arr[0] == 0);
    assert(arr[1] == 15);
    assert(arr[2] == 30);
    assert(arr[3] == 45);
}

it("should use or condition in filter") {
    let arr = [x for x in 0..20 if x % 3 == 0 or x % 5 == 0];
    assert(arr.contains(0));
    assert(arr.contains(3));
    assert(arr.contains(5));
    assert(arr.contains(15));
}

// ============================================================================
// COMPREHENSION EDGE CASES
// ============================================================================

it("should handle empty range comprehension") {
    let arr = [x for x in 0..0];
    assert(arr.len() == 0);
}

it("should handle filter that removes all") {
    let arr = [x for x in 0..10 if x > 100];
    assert(arr.len() == 0);
}

it("should handle single element comprehension") {
    let arr = [x for x in 0..1];
    assert(arr.len() == 1);
    assert(arr[0] == 0);
}

it("should handle comprehension with negative range") {
    let arr = [x for x in -5..0];
    assert(arr.len() == 5);
    assert(arr[0] == -5);
    assert(arr[4] == -1);
}

// ============================================================================
// COMPREHENSION IN FUNCTIONS
// ============================================================================

fn generate_squares(n: i32): [i32] {
    return [x * x for x in 0..n];
}

it("should use comprehension in function") {
    let squares = generate_squares(5);
    assert(squares[0] == 0);
    assert(squares[1] == 1);
    assert(squares[2] == 4);
    assert(squares[3] == 9);
    assert(squares[4] == 16);
}

fn filter_positives(arr: [i32]): [i32] {
    return [x for x in arr if x > 0];
}

it("should filter with comprehension in function") {
    let result = filter_positives([-1, 0, 1, 2, -3, 4]);
    assert(result.len() == 3);
    assert(result[0] == 1);
    assert(result[1] == 2);
    assert(result[2] == 4);
}

// ============================================================================
// PRACTICAL EXAMPLES
// ============================================================================

it("should generate fibonacci-like sequence") {
    let fibs = [x + (x - 1) for x in 1..6];  // 1, 3, 5, 7, 9
    assert(fibs[0] == 1);
    assert(fibs[4] == 9);
}

it("should filter primes manually") {
    // Simple prime check for small range
    fn is_prime(n: i32): bool {
        if (n < 2) { return false; }
        if (n == 2) { return true; }
        if (n % 2 == 0) { return false; }
        let i = 3;
        while (i * i <= n) {
            if (n % i == 0) { return false; }
            i = i + 2;
        }
        return true;
    }
    let primes = [x for x in 2..20 if is_prime(x)];
    assert(primes[0] == 2);
    assert(primes[1] == 3);
    assert(primes[2] == 5);
    assert(primes[3] == 7);
}
