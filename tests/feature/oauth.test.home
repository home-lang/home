// OAuth Authentication Test Suite

// ============================================================================
// OAUTH 2.0 CLIENT
// ============================================================================

it("should create OAuth client") {
    let config = {
        client_id: "my-client-id",
        client_secret: "my-client-secret",
        redirect_uri: "https://myapp.com/callback",
    }
    let client = oauth::Client::new(config)
    assert(client != null)
}

it("should configure authorization endpoint") {
    let config = {
        client_id: "my-client-id",
        authorization_url: "https://auth.example.com/authorize",
        token_url: "https://auth.example.com/token",
    }
    let client = oauth::Client::new(config)
}

// ============================================================================
// AUTHORIZATION CODE FLOW
// ============================================================================

it("should generate authorization URL") {
    let config = {
        client_id: "my-client-id",
        authorization_url: "https://auth.example.com/authorize",
        redirect_uri: "https://myapp.com/callback",
    }
    let client = oauth::Client::new(config)

    let scopes = ["openid", "profile", "email"]
    let url = client.authorization_url_with_scope(scopes)
    assert(url.contains("client_id=my-client-id"))
    assert(url.contains("response_type=code"))
}

it("should include state parameter") {
    let config = { client_id: "id" }
    let client = oauth::Client::new(config)
    let state = oauth::generate_state()
    let url = client.authorization_url_with_state(state)
    assert(url.contains("state="))
}

it("should include PKCE challenge") {
    let config = { client_id: "id" }
    let client = oauth::Client::new(config)
    let verifier = oauth::pkce::generate_verifier()
    let challenge = oauth::pkce::generate_challenge(verifier)

    let pkce_config = {
        code_challenge: challenge,
        code_challenge_method: "S256"
    }
    let url = client.authorization_url_with_pkce(pkce_config)
    assert(url.contains("code_challenge="))
}

it("should exchange code for tokens") {
    let config = {
        client_id: "id",
        client_secret: "secret",
        token_url: "https://auth.example.com/token",
    }
    let client = oauth::Client::new(config)

    // Mock exchange
    let tokens = client.exchange_code("authorization_code_here")
    assert(tokens.access_token != null or tokens.is_err())
}

it("should exchange code with PKCE verifier") {
    let config = { client_id: "id" }
    let client = oauth::Client::new(config)
    let verifier = "original_verifier"
    let tokens = client.exchange_code_with_verifier("code", verifier)
}

// ============================================================================
// CLIENT CREDENTIALS FLOW
// ============================================================================

it("should get token with client credentials") {
    let config = {
        client_id: "id",
        client_secret: "secret",
        token_url: "https://auth.example.com/token",
    }
    let client = oauth::Client::new(config)

    let scopes = ["api:read"]
    let tokens = client.client_credentials(scopes)
    assert(tokens.access_token != null or tokens.is_err())
}

// ============================================================================
// REFRESH TOKEN FLOW
// ============================================================================

it("should refresh access token") {
    let config = {
        client_id: "id",
        client_secret: "secret",
        token_url: "https://auth.example.com/token",
    }
    let client = oauth::Client::new(config)

    let new_tokens = client.refresh_token("refresh_token_here")
    assert(new_tokens.access_token != null or new_tokens.is_err())
}

it("should handle token rotation") {
    let tokens = oauth::Tokens {
        access_token: "old_access",
        refresh_token: "old_refresh",
        expires_at: time::now() - 3600,
    }

    let config = { client_id: "id" }
    let client = oauth::Client::new(config)
    let new_tokens = client.refresh_if_needed(tokens)
}

// ============================================================================
// IMPLICIT FLOW
// ============================================================================

it("should generate implicit flow URL") {
    let config = {
        client_id: "id",
        authorization_url: "https://auth.example.com/authorize",
    }
    let client = oauth::Client::new(config)

    let scopes = ["openid"]
    let url = client.implicit_url(scopes)
    assert(url.contains("response_type=token"))
}

it("should parse implicit response") {
    let fragment = "access_token=abc123&token_type=bearer&expires_in=3600"
    let tokens = oauth::parse_implicit_response(fragment)
    assert(tokens.access_token == "abc123")
}

// ============================================================================
// DEVICE CODE FLOW
// ============================================================================

it("should request device code") {
    let config = {
        client_id: "id",
        device_authorization_url: "https://auth.example.com/device",
    }
    let client = oauth::Client::new(config)

    let scopes = ["profile"]
    let device = client.request_device_code(scopes)
    assert(device.device_code != null or device.is_err())
    assert(device.user_code != null or device.is_err())
    assert(device.verification_uri != null or device.is_err())
}

it("should poll for device token") {
    let config = { client_id: "id" }
    let client = oauth::Client::new(config)
    let device_code = "device_code_here"
    let interval = 5

    let tokens = client.poll_device_token(device_code, interval)
}

// ============================================================================
// TOKEN MANAGEMENT
// ============================================================================

it("should create token response") {
    let tokens = oauth::Tokens {
        access_token: "access_token_value",
        token_type: "Bearer",
        expires_in: 3600,
        refresh_token: "refresh_token_value",
        scope: ["openid", "profile"],
    }

    assert(tokens.access_token == "access_token_value")
}

it("should check token expiration") {
    let tokens = oauth::Tokens {
        access_token: "token",
        expires_at: time::now() + 3600,
    }

    assert(tokens.is_expired() == false)
}

it("should check token expiring soon") {
    let tokens = oauth::Tokens {
        access_token: "token",
        expires_at: time::now() + 60,
    }

    let threshold = 300
    assert(tokens.expires_soon(threshold) == true)
}

// ============================================================================
// TOKEN INTROSPECTION
// ============================================================================

it("should introspect token") {
    let config = {
        client_id: "id",
        introspection_url: "https://auth.example.com/introspect",
    }
    let client = oauth::Client::new(config)

    let info = client.introspect("access_token_here")
    assert(info.active == true or info.active == false)
}

// ============================================================================
// TOKEN REVOCATION
// ============================================================================

it("should revoke token") {
    let config = {
        client_id: "id",
        revocation_url: "https://auth.example.com/revoke",
    }
    let client = oauth::Client::new(config)

    let result = client.revoke("access_token_here")
    assert(result.success == true or result.is_err())
}

it("should revoke refresh token") {
    let config = { client_id: "id" }
    let client = oauth::Client::new(config)
    client.revoke_with_hint("refresh_token_here", "refresh_token")
}

// ============================================================================
// OPENID CONNECT
// ============================================================================

it("should discover OIDC configuration") {
    let discovery = oauth::oidc::discover("https://auth.example.com")
    assert(discovery.authorization_endpoint != null)
    assert(discovery.token_endpoint != null)
    assert(discovery.userinfo_endpoint != null)
}

it("should request ID token") {
    let config = { client_id: "id" }
    let client = oauth::Client::new(config)
    let opts = {
        scope: ["openid", "profile"],
        response_type: "code id_token"
    }
    let url = client.authorization_url_with_options(opts)
}

it("should validate ID token") {
    let config = { client_id: "id" }
    let client = oauth::Client::new(config)
    let id_token = "eyJ..."
    let claims = client.validate_id_token(id_token)
    assert(claims.sub != null or claims.is_err())
}

it("should get userinfo") {
    let config = {
        userinfo_url: "https://auth.example.com/userinfo",
    }
    let client = oauth::Client::new(config)

    let user = client.userinfo("access_token_here")
    assert(user.sub != null or user.is_err())
}

it("should verify nonce") {
    let config = { client_id: "id" }
    let client = oauth::Client::new(config)
    let nonce = oauth::generate_nonce()

    let id_token = "..."
    let valid = client.verify_nonce(id_token, nonce)
}

// ============================================================================
// JWT HANDLING
// ============================================================================

it("should decode access token") {
    let token = "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9..."
    let decoded = oauth::decode_jwt(token)
    assert(decoded.header != null)
    assert(decoded.payload != null)
}

it("should verify token signature") {
    let config = {
        jwks_uri: "https://auth.example.com/.well-known/jwks.json",
    }
    let client = oauth::Client::new(config)

    let token = "..."
    let valid = client.verify_signature(token)
}

// ============================================================================
// PROVIDERS
// ============================================================================

it("should use Google provider") {
    let config = {
        client_id: "google-client-id",
        client_secret: "google-client-secret",
    }
    let client = oauth::providers::google(config)

    let scopes = ["email", "profile"]
    let url = client.authorization_url_with_scope(scopes)
    assert(url.contains("accounts.google.com"))
}

it("should use GitHub provider") {
    let config = {
        client_id: "github-client-id",
        client_secret: "github-client-secret",
    }
    let client = oauth::providers::github(config)

    let scopes = ["user", "repo"]
    let url = client.authorization_url_with_scope(scopes)
    assert(url.contains("github.com"))
}

it("should use Microsoft provider") {
    let config = {
        client_id: "ms-client-id",
        tenant: "common",
    }
    let client = oauth::providers::microsoft(config)
}

it("should use Apple provider") {
    let config = {
        client_id: "apple-client-id",
        team_id: "TEAM123",
        key_id: "KEY456",
    }
    let client = oauth::providers::apple(config)
}

// ============================================================================
// STATE AND CSRF
// ============================================================================

it("should generate secure state") {
    let state = oauth::generate_state()
    assert(state.len() >= 32)
}

it("should verify state") {
    let original = oauth::generate_state()
    let returned = original
    assert(oauth::verify_state(original, returned) == true)
}

it("should detect state mismatch") {
    let original = oauth::generate_state()
    let different = oauth::generate_state()
    assert(oauth::verify_state(original, different) == false)
}

// ============================================================================
// ERROR HANDLING
// ============================================================================

it("should parse error response") {
    let response = {
        error: "invalid_grant",
        error_description: "The authorization code has expired",
    }

    let err = oauth::parse_error(response)
    assert(err.code == "invalid_grant")
}

it("should handle authorization denied") {
    let callback = "https://myapp.com/callback?error=access_denied"
    let result = oauth::parse_callback(callback)
    assert(result.is_err() == true)
    assert(result.error == "access_denied")
}

// ============================================================================
// TOKEN STORAGE
// ============================================================================

it("should store tokens securely") {
    let storage = oauth::TokenStorage::new("myapp")
    let tokens = oauth::Tokens { access_token: "token" }

    storage.save("user123", tokens)
    let loaded = storage.load("user123")
    assert(loaded.access_token == "token")
}

it("should encrypt stored tokens") {
    let config = { encryption_key: "secret" }
    let storage = oauth::TokenStorage::new_with_config("myapp", config)
    let tokens = oauth::Tokens { access_token: "sensitive" }
    storage.save("user", tokens)
}

// ============================================================================
// MIDDLEWARE
// ============================================================================

it("should create OAuth middleware") {
    let client_config = { client_id: "id" }
    let client = oauth::Client::new(client_config)

    let middleware_config = {
        client: client,
        login_path: "/login",
        callback_path: "/callback",
    }
    let middleware = oauth::middleware(middleware_config)
}

it("should protect routes") {
    fn on_unauth(req) {
        return http::Response::redirect("/login")
    }

    let config = {
        scopes: ["admin"],
        on_unauthorized: on_unauth,
    }
    let protect = oauth::require_auth(config)
}
