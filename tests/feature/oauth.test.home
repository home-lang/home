// OAuth Authentication Test Suite

// ============================================================================
// OAUTH 2.0 CLIENT
// ============================================================================

it("should create OAuth client") {
    let config = {
        client_id: "my-client-id",
        client_secret: "my-client-secret",
        redirect_uri: "https://myapp.com/callback",
    }
    let client = OAuth.Client.new(config)
    assert(client != null)
}

it("should configure authorization endpoint") {
    let config = {
        client_id: "my-client-id",
        authorization_url: "https://auth.example.com/authorize",
        token_url: "https://auth.example.com/token",
    }
    let client = OAuth.Client.new(config)
}

// ============================================================================
// AUTHORIZATION CODE FLOW
// ============================================================================

it("should generate authorization URL") {
    let config = {
        client_id: "my-client-id",
        authorization_url: "https://auth.example.com/authorize",
        redirect_uri: "https://myapp.com/callback",
    }
    let client = OAuth.Client.new(config)

    let scopes = ["openid", "profile", "email"]
    let url = client.authorizationUrlWithScope(scopes)
    assert(url.contains("client_id=my-client-id"))
    assert(url.contains("response_type=code"))
}

it("should include state parameter") {
    let config = { client_id: "id" }
    let client = OAuth.Client.new(config)
    let state = OAuth.generateState()
    let url = client.authorizationUrlWithState(state)
    assert(url.contains("state="))
}

it("should include PKCE challenge") {
    let config = { client_id: "id" }
    let client = OAuth.Client.new(config)
    let verifier = OAuth.pkce.generateVerifier()
    let challenge = OAuth.pkce.generateChallenge(verifier)

    let pkce_config = {
        code_challenge: challenge,
        code_challenge_method: "S256"
    }
    let url = client.authorizationUrlWithPkce(pkce_config)
    assert(url.contains("code_challenge="))
}

it("should exchange code for tokens") {
    let config = {
        client_id: "id",
        client_secret: "secret",
        token_url: "https://auth.example.com/token",
    }
    let client = OAuth.Client.new(config)

    // Mock exchange
    let tokens = client.exchangeCode("authorization_code_here")
    assert(tokens.accessToken != null or tokens.isErr())
}

it("should exchange code with PKCE verifier") {
    let config = { client_id: "id" }
    let client = OAuth.Client.new(config)
    let verifier = "original_verifier"
    let tokens = client.exchangeCodeWithVerifier("code", verifier)
}

// ============================================================================
// CLIENT CREDENTIALS FLOW
// ============================================================================

it("should get token with client credentials") {
    let config = {
        client_id: "id",
        client_secret: "secret",
        token_url: "https://auth.example.com/token",
    }
    let client = OAuth.Client.new(config)

    let scopes = ["api:read"]
    let tokens = client.clientCredentials(scopes)
    assert(tokens.accessToken != null or tokens.isErr())
}

// ============================================================================
// REFRESH TOKEN FLOW
// ============================================================================

it("should refresh access token") {
    let config = {
        client_id: "id",
        client_secret: "secret",
        token_url: "https://auth.example.com/token",
    }
    let client = OAuth.Client.new(config)

    let new_tokens = client.refreshToken("refresh_token_here")
    assert(new_tokens.accessToken != null or new_tokens.isErr())
}

it("should handle token rotation") {
    let tokens = {
        access_token: "old_access",
        refresh_token: "old_refresh",
        expires_at: Time.now() - 3600,
    }

    let config = { client_id: "id" }
    let client = OAuth.Client.new(config)
    let new_tokens = client.refreshIfNeeded(tokens)
}

// ============================================================================
// IMPLICIT FLOW
// ============================================================================

it("should generate implicit flow URL") {
    let config = {
        client_id: "id",
        authorization_url: "https://auth.example.com/authorize",
    }
    let client = OAuth.Client.new(config)

    let scopes = ["openid"]
    let url = client.implicitUrl(scopes)
    assert(url.contains("response_type=token"))
}

it("should parse implicit response") {
    let fragment = "access_token=abc123&token_type=bearer&expires_in=3600"
    let tokens = OAuth.parseImplicitResponse(fragment)
    assert(tokens.accessToken == "abc123")
}

// ============================================================================
// DEVICE CODE FLOW
// ============================================================================

it("should request device code") {
    let config = {
        client_id: "id",
        device_authorization_url: "https://auth.example.com/device",
    }
    let client = OAuth.Client.new(config)

    let scopes = ["profile"]
    let device = client.requestDeviceCode(scopes)
    assert(device.deviceCode != null or device.isErr())
    assert(device.userCode != null or device.isErr())
    assert(device.verificationUri != null or device.isErr())
}

it("should poll for device token") {
    let config = { client_id: "id" }
    let client = OAuth.Client.new(config)
    let device_code = "device_code_here"
    let interval = 5

    let tokens = client.pollDeviceToken(device_code, interval)
}

// ============================================================================
// TOKEN MANAGEMENT
// ============================================================================

it("should create token response") {
    let tokens = {
        accessToken: "access_token_value",
        tokenType: "Bearer",
        expiresIn: 3600,
        refreshToken: "refresh_token_value",
        scope: ["openid", "profile"],
    }

    assert(tokens.accessToken == "access_token_value")
}

it("should check token expiration") {
    let tokens = {
        accessToken: "token",
        expiresAt: Time.now() + 3600,
    }

    // Token expires in the future, so it's not expired
    assert(tokens.expiresAt > Time.now())
}

it("should check token expiring soon") {
    let tokens = {
        accessToken: "token",
        expiresAt: Time.now() + 60,
    }

    let threshold = 300
    // Token expires in 60 seconds, which is less than threshold (300)
    assert(tokens.expiresAt - Time.now() < threshold)
}

// ============================================================================
// TOKEN INTROSPECTION
// ============================================================================

it("should introspect token") {
    let config = {
        client_id: "id",
        introspection_url: "https://auth.example.com/introspect",
    }
    let client = OAuth.Client.new(config)

    let info = client.introspect("access_token_here")
    assert(info.active == true or info.active == false)
}

// ============================================================================
// TOKEN REVOCATION
// ============================================================================

it("should revoke token") {
    let config = {
        client_id: "id",
        revocation_url: "https://auth.example.com/revoke",
    }
    let client = OAuth.Client.new(config)

    let result = client.revoke("access_token_here")
    assert(result.success == true or result.isErr())
}

it("should revoke refresh token") {
    let config = { client_id: "id" }
    let client = OAuth.Client.new(config)
    client.revokeWithHint("refresh_token_here", "refresh_token")
}

// ============================================================================
// OPENID CONNECT
// ============================================================================

it("should discover OIDC configuration") {
    let discovery = OAuth.oidc.discover("https://auth.example.com")
    assert(discovery.authorizationEndpoint != null)
    assert(discovery.tokenEndpoint != null)
    assert(discovery.userinfoEndpoint != null)
}

it("should request ID token") {
    let config = { client_id: "id" }
    let client = OAuth.Client.new(config)
    let opts = {
        scope: ["openid", "profile"],
        response_type: "code id_token"
    }
    let url = client.authorizationUrlWithOptions(opts)
}

it("should validate ID token") {
    let config = { client_id: "id" }
    let client = OAuth.Client.new(config)
    let id_token = "eyJ..."
    let claims = client.validateIdToken(id_token)
    assert(claims.sub != null or claims.isErr())
}

it("should get userinfo") {
    let config = {
        userinfo_url: "https://auth.example.com/userinfo",
    }
    let client = OAuth.Client.new(config)

    let user = client.userinfo("access_token_here")
    assert(user.sub != null or user.isErr())
}

it("should verify nonce") {
    let config = { client_id: "id" }
    let client = OAuth.Client.new(config)
    let nonce = OAuth.generateNonce()

    let id_token = "..."
    let valid = client.verifyNonce(id_token, nonce)
}

// ============================================================================
// JWT HANDLING
// ============================================================================

it("should decode access token") {
    let token = "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9..."
    let decoded = OAuth.decodeJwt(token)
    assert(decoded.header != null)
    assert(decoded.payload != null)
}

it("should verify token signature") {
    let config = {
        jwks_uri: "https://auth.example.com/.well-known/jwks.json",
    }
    let client = OAuth.Client.new(config)

    let token = "..."
    let valid = client.verifySignature(token)
}

// ============================================================================
// PROVIDERS
// ============================================================================

it("should use Google provider") {
    let config = {
        client_id: "google-client-id",
        client_secret: "google-client-secret",
    }
    let client = OAuth.providers.google(config)

    let scopes = ["email", "profile"]
    let url = client.authorizationUrlWithScope(scopes)
    assert(url.contains("accounts.google.com"))
}

it("should use GitHub provider") {
    let config = {
        client_id: "github-client-id",
        client_secret: "github-client-secret",
    }
    let client = OAuth.providers.github(config)

    let scopes = ["user", "repo"]
    let url = client.authorizationUrlWithScope(scopes)
    assert(url.contains("github.com"))
}

it("should use Microsoft provider") {
    let config = {
        client_id: "ms-client-id",
        tenant: "common",
    }
    let client = OAuth.providers.microsoft(config)
}

it("should use Apple provider") {
    let config = {
        client_id: "apple-client-id",
        team_id: "TEAM123",
        key_id: "KEY456",
    }
    let client = OAuth.providers.apple(config)
}

// ============================================================================
// STATE AND CSRF
// ============================================================================

it("should generate secure state") {
    let state = OAuth.generateState()
    assert(state.len() >= 32)
}

it("should verify state") {
    let original = OAuth.generateState()
    let returned = original
    assert(OAuth.verifyState(original, returned) == true)
}

it("should detect state mismatch") {
    let original = OAuth.generateState()
    let different = OAuth.generateState()
    assert(OAuth.verifyState(original, different) == false)
}

// ============================================================================
// ERROR HANDLING
// ============================================================================

it("should parse error response") {
    let response = {
        error: "invalid_grant",
        error_description: "The authorization code has expired",
    }

    let err = OAuth.parseError(response)
    assert(err.code == "invalid_grant")
}

it("should handle authorization denied") {
    let callback = "https://myapp.com/callback?error=access_denied"
    let result = OAuth.parseCallback(callback)
    // When there's an error, the error field is set
    assert(result.error == "access_denied")
}

// ============================================================================
// TOKEN STORAGE
// ============================================================================

it("should store tokens securely") {
    let storage = OAuth.TokenStorage.new("myapp")
    let tokens = { access_token: "token" }

    storage.save("user123", tokens)
    let loaded = storage.load("user123")
    assert(loaded.accessToken == "token")
}

it("should encrypt stored tokens") {
    let config = { encryption_key: "secret" }
    let storage = OAuth.TokenStorage.newWithConfig("myapp", config)
    let tokens = { access_token: "sensitive" }
    storage.save("user", tokens)
}

// ============================================================================
// MIDDLEWARE
// ============================================================================

it("should create OAuth middleware") {
    let client_config = { client_id: "id" }
    let client = OAuth.Client.new(client_config)

    let middleware_config = {
        client: client,
        login_path: "/login",
        callback_path: "/callback",
    }
    let middleware = OAuth.middleware(middleware_config)
}

it("should protect routes") {
    fn on_unauth(req) {
        return HTTP.Response.redirect("/login")
    }

    let config = {
        scopes: ["admin"],
        on_unauthorized: on_unauth,
    }
    let protect = OAuth.requireAuth(config)
}
