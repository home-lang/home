// Higher-Order Functions Test Suite
// Tests functions as parameters and return values

fn double(x: i32): i32 { return x * 2; }
fn triple(x: i32): i32 { return x * 3; }
fn square(x: i32): i32 { return x * x; }
fn increment(x: i32): i32 { return x + 1; }
fn negate(x: i32): i32 { return 0 - x; }

fn apply(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

fn apply_twice(f: fn(i32): i32, x: i32): i32 {
    return f(f(x));
}

fn compose(f: fn(i32): i32, g: fn(i32): i32, x: i32): i32 {
    return f(g(x));
}

it("should pass function as parameter") {
    let result = apply(double, 5);
    assert(result == 10);
}

it("should pass different functions") {
    assert(apply(double, 5) == 10);
    assert(apply(triple, 5) == 15);
    assert(apply(square, 5) == 25);
}

it("should apply function twice") {
    assert(apply_twice(double, 3) == 12);
    assert(apply_twice(increment, 0) == 2);
    assert(apply_twice(square, 2) == 16);
}

it("should compose functions") {
    // compose(double, increment, 5) = double(increment(5)) = double(6) = 12
    assert(compose(double, increment, 5) == 12);
    // compose(square, double, 3) = square(double(3)) = square(6) = 36
    assert(compose(square, double, 3) == 36);
}

it("should work with negative results") {
    assert(apply(negate, 5) == -5);
    assert(apply_twice(negate, 5) == 5);
}

it("should chain multiple higher-order calls") {
    let step1 = apply(double, 5);     // 10
    let step2 = apply(increment, step1);  // 11
    let step3 = apply(square, step2);     // 121
    assert(step3 == 121);
}

fn map_value(f: fn(i32): i32, values: [i32]): i32 {
    let mut sum = 0;
    for (v in values) {
        sum = sum + f(v);
    }
    return sum;
}

it("should work with arrays") {
    let arr = [1, 2, 3, 4, 5];
    let sum_doubled = map_value(double, arr);
    assert(sum_doubled == 30);
}

fn select(condition: bool, f: fn(i32): i32, g: fn(i32): i32, x: i32): i32 {
    if (condition) {
        return f(x);
    } else {
        return g(x);
    }
}

it("should conditionally apply functions") {
    assert(select(true, double, triple, 5) == 10);
    assert(select(false, double, triple, 5) == 15);
}

// ============================================================================
// EDGE CASES - IDENTITY FUNCTIONS
// ============================================================================

fn identity_fn(x: i32): i32 { return x; }

it("should apply identity function") {
    assert(apply(identity_fn, 0) == 0);
    assert(apply(identity_fn, -100) == -100);
    assert(apply(identity_fn, 999) == 999);
}

it("should apply identity twice") {
    assert(apply_twice(identity_fn, 42) == 42);
}

it("should compose with identity") {
    assert(compose(identity_fn, double, 5) == 10);
    assert(compose(double, identity_fn, 5) == 10);
}

// ============================================================================
// EDGE CASES - ZERO AND NEGATIVE VALUES
// ============================================================================

it("should handle zero in all functions") {
    assert(apply(double, 0) == 0);
    assert(apply(triple, 0) == 0);
    assert(apply(square, 0) == 0);
    assert(apply(increment, 0) == 1);
}

it("should handle negative numbers") {
    assert(apply(double, -5) == -10);
    assert(apply(triple, -3) == -9);
    assert(apply(square, -4) == 16);
    assert(apply(increment, -1) == 0);
}

it("should negate and double") {
    assert(compose(negate, double, 5) == -10);
    assert(compose(double, negate, 5) == -10);
}

// ============================================================================
// EDGE CASES - COMPLEX COMPOSITIONS
// ============================================================================

fn add_ten(x: i32): i32 { return x + 10; }
fn halve(x: i32): i32 { return x / 2; }

it("should triple compose") {
    // (double . increment . double)(5) = double(increment(double(5))) = double(increment(10)) = double(11) = 22
    let step1 = apply(double, 5);      // 10
    let step2 = apply(increment, step1); // 11
    let step3 = apply(double, step2);    // 22
    assert(step3 == 22);
}

it("should compose add_ten with halve") {
    assert(compose(halve, add_ten, 10) == 10);  // halve(add_ten(10)) = halve(20) = 10
    assert(compose(add_ten, halve, 10) == 15);  // add_ten(halve(10)) = add_ten(5) = 15
}

// ============================================================================
// EDGE CASES - HIGHER-ORDER WITH ARRAYS
// ============================================================================

it("should map double over array") {
    let arr = [1, 2, 3, 4, 5];
    assert(map_value(double, arr) == 30);
}

it("should map square over array") {
    let arr = [1, 2, 3];
    assert(map_value(square, arr) == 14);  // 1 + 4 + 9
}

it("should map over empty array") {
    let arr: [i32] = [];
    assert(map_value(double, arr) == 0);
}

it("should map over single element array") {
    let arr = [10];
    assert(map_value(double, arr) == 20);
    assert(map_value(triple, arr) == 30);
}

it("should map over array with negative values") {
    let arr = [-1, -2, -3];
    assert(map_value(double, arr) == -12);
    assert(map_value(negate, arr) == 6);
}

// ============================================================================
// EDGE CASES - FUNCTION PARAMETERS
// ============================================================================

fn apply_n_times(f: fn(i32): i32, x: i32, n: i32): i32 {
    let mut result = x;
    let mut count = 0;
    while (count < n) {
        result = f(result);
        count = count + 1;
    }
    return result;
}

it("should apply function n times") {
    assert(apply_n_times(double, 1, 0) == 1);
    assert(apply_n_times(double, 1, 1) == 2);
    assert(apply_n_times(double, 1, 2) == 4);
    assert(apply_n_times(double, 1, 3) == 8);
    assert(apply_n_times(double, 1, 10) == 1024);
}

it("should apply increment n times") {
    assert(apply_n_times(increment, 0, 5) == 5);
    assert(apply_n_times(increment, 10, 10) == 20);
}

// ============================================================================
// EDGE CASES - CONDITIONAL APPLICATION
// ============================================================================

it("should select based on condition") {
    let x = 10;
    let result1 = select(x > 5, double, triple, x);
    let result2 = select(x < 5, double, triple, x);
    assert(result1 == 20);  // double(10)
    assert(result2 == 30);  // triple(10)
}

fn apply_if(cond: bool, f: fn(i32): i32, x: i32): i32 {
    if (cond) { return f(x); }
    return x;
}

it("should conditionally apply or return unchanged") {
    assert(apply_if(true, double, 5) == 10);
    assert(apply_if(false, double, 5) == 5);
}

// ============================================================================
// EDGE CASES - NESTED HIGHER ORDER
// ============================================================================

fn transform_and_sum(f: fn(i32): i32, g: fn(i32): i32, x: i32, y: i32): i32 {
    return f(x) + g(y);
}

it("should transform two values with different functions") {
    assert(transform_and_sum(double, triple, 5, 5) == 25);  // 10 + 15
    assert(transform_and_sum(square, increment, 3, 3) == 13);  // 9 + 4
}

// ============================================================================
// EDGE CASES - LARGE VALUES
// ============================================================================

it("should handle large values") {
    assert(apply(increment, 1000000) == 1000001);
    assert(apply(negate, 1000000) == -1000000);
}

it("should handle chained large operations") {
    let large = 10000;
    let step1 = apply(double, large);  // 20000
    let step2 = apply(increment, step1);  // 20001
    assert(step2 == 20001);
}

// ============================================================================
// EDGE CASES - FUNCTION RETURNING FUNCTION RESULT
// ============================================================================

fn pick_and_apply(use_first: bool, x: i32): i32 {
    if (use_first) {
        return apply(double, x);
    }
    return apply(triple, x);
}

it("should pick and apply function") {
    assert(pick_and_apply(true, 5) == 10);
    assert(pick_and_apply(false, 5) == 15);
}

// ============================================================================
// EDGE CASES - BOUNDARY CONDITIONS
// ============================================================================

fn clamp(x: i32): i32 {
    if (x < 0) { return 0; }
    if (x > 100) { return 100; }
    return x;
}

it("should apply clamp function") {
    assert(apply(clamp, -50) == 0);
    assert(apply(clamp, 50) == 50);
    assert(apply(clamp, 150) == 100);
}

it("should compose clamp with double") {
    assert(compose(clamp, double, 30) == 60);
    assert(compose(clamp, double, 60) == 100);  // double(60) = 120, clamp(120) = 100
}

