// Pattern Matching Test Suite (WIP)
// Tests match expressions with various pattern types

enum Option {
    Some(i32),
    None
}

it("should match integer literals") {
    let x = 10;
    let result = match (x) {
        10 => 42,
        20 => 99,
        _ => 0,
    };
    assert(result == 42);
}

it("should match boolean values") {
    let b = true;
    let result = match (b) {
        true => 42,
        false => 0,
    };
    assert(result == 42);
}

it("should match enum variants") {
    let opt: Option = Option.Some(42);
    let result = match (opt) {
        Option.Some(x) => x,
        Option.None => 0,
    };
    assert(result == 42);
}

it("should match None variant") {
    let opt: Option = Option.None;
    let result = match (opt) {
        Option.None => 99,
        Option.Some(x) => x,
    };
    assert(result == 99);
}

it("should support wildcard pattern") {
    let x = 999;
    let result = match (x) {
        1 => 10,
        2 => 20,
        _ => 0,
    };
    assert(result == 0);
}

it("should match negative numbers") {
    let x = -5;
    let result = match (x) {
        -5 => 100,
        0 => 0,
        5 => 50,
        _ => -1,
    };
    assert(result == 100);
}

it("should match zero") {
    let x = 0;
    let result = match (x) {
        -1 => -10,
        0 => 0,
        1 => 10,
        _ => 99,
    };
    assert(result == 0);
}

it("should match in function") {
    fn classify(n: i32): i32 {
        return match (n) {
            0 => 0,
            1 => 1,
            _ => 2,
        };
    }
    assert(classify(0) == 0);
    assert(classify(1) == 1);
    assert(classify(100) == 2);
}

it("should match nested in if") {
    let x = 5;
    let mut result = 0;
    if (x > 0) {
        result = match (x) {
            5 => 50,
            _ => 0,
        };
    }
    assert(result == 50);
}

it("should use match result in expression") {
    let x = 2;
    let doubled = match (x) {
        1 => 2,
        2 => 4,
        3 => 6,
        _ => 0,
    } + 10;
    assert(doubled == 14);
}

it("should match with multiple Some values") {
    enum Maybe {
        Just(i32),
        Nothing
    }
    let a: Maybe = Maybe.Just(10);
    let b: Maybe = Maybe.Just(20);
    let sum = match (a) {
        Maybe.Just(x) => match (b) {
            Maybe.Just(y) => x + y,
            Maybe.Nothing => x,
        },
        Maybe.Nothing => 0,
    };
    assert(sum == 30);
}

// ============================================================================
// EDGE CASES - INTEGER PATTERNS
// ============================================================================

it("should match zero") {
    let x = 0;
    let result = match (x) {
        0 => 100,
        _ => 0,
    };
    assert(result == 100);
}

it("should match large positive") {
    let x = 999999;
    let result = match (x) {
        999999 => 1,
        _ => 0,
    };
    assert(result == 1);
}

it("should match large negative") {
    let x = -999999;
    let result = match (x) {
        -999999 => 1,
        _ => 0,
    };
    assert(result == 1);
}

it("should match multiple negative values") {
    let x = -3;
    let result = match (x) {
        -1 => 10,
        -2 => 20,
        -3 => 30,
        _ => 0,
    };
    assert(result == 30);
}

// ============================================================================
// EDGE CASES - WILDCARD EXHAUSTIVENESS
// ============================================================================

it("should always match wildcard last") {
    let x = 12345;
    let result = match (x) {
        1 => 1,
        2 => 2,
        3 => 3,
        _ => 999,
    };
    assert(result == 999);
}

it("should match first pattern when multiple could match") {
    let x = 1;
    let result = match (x) {
        1 => 100,
        _ => 0,
    };
    assert(result == 100);
}

// ============================================================================
// EDGE CASES - BOOLEAN PATTERNS
// ============================================================================

it("should match false") {
    let b = false;
    let result = match (b) {
        true => 1,
        false => 0,
    };
    assert(result == 0);
}

it("should match boolean in conditional context") {
    let flag = true;
    let value = 10;
    let result = match (flag) {
        true => value * 2,
        false => value,
    };
    assert(result == 20);
}

// ============================================================================
// EDGE CASES - ENUM WITH PAYLOADS
// ============================================================================

enum Result {
    Ok(i32),
    Err(i32)
}

it("should match Ok with zero payload") {
    let r: Result = Result.Ok(0);
    let value = match (r) {
        Result.Ok(x) => x,
        Result.Err(e) => e,
    };
    assert(value == 0);
}

it("should match Ok with negative payload") {
    let r: Result = Result.Ok(-42);
    let value = match (r) {
        Result.Ok(x) => x,
        Result.Err(e) => 0,
    };
    assert(value == -42);
}

it("should match Err variant") {
    let r: Result = Result.Err(404);
    let is_error = match (r) {
        Result.Ok(x) => false,
        Result.Err(e) => true,
    };
    assert(is_error == true);
}

it("should extract Err payload") {
    let r: Result = Result.Err(500);
    let code = match (r) {
        Result.Ok(x) => 0,
        Result.Err(e) => e,
    };
    assert(code == 500);
}

// ============================================================================
// EDGE CASES - MATCH IN EXPRESSIONS
// ============================================================================

it("should use match in arithmetic") {
    let x = 2;
    let doubled = match (x) {
        1 => 2,
        2 => 4,
        3 => 6,
        _ => 0,
    } * 10;
    assert(doubled == 40);
}

it("should use match in comparison") {
    let x = 5;
    let result = match (x) {
        5 => 100,
        _ => 0,
    } > 50;
    assert(result == true);
}

it("should chain match results") {
    let a = 1;
    let b = 2;
    let sum = match (a) { 1 => 10, _ => 0 } + match (b) { 2 => 20, _ => 0 };
    assert(sum == 30);
}

// ============================================================================
// EDGE CASES - MATCH IN LOOPS
// ============================================================================

it("should use match in loop") {
    let mut sum = 0;
    for (i in 0..5) {
        sum = sum + match (i) {
            0 => 10,
            1 => 20,
            2 => 30,
            _ => 0,
        };
    }
    assert(sum == 60);  // 10 + 20 + 30 + 0 + 0
}

it("should use match to control loop") {
    let mut i = 0;
    let mut result = 0;
    while (i < 10) {
        let action = match (i) {
            5 => 1,  // stop
            _ => 0,  // continue
        };
        if (action == 1) {
            break;
        }
        result = result + i;
        i = i + 1;
    }
    assert(result == 10);  // 0+1+2+3+4
}

// ============================================================================
// EDGE CASES - NESTED MATCH
// ============================================================================

it("should handle deeply nested match") {
    let x = 1;
    let y = 2;
    let z = 3;
    let result = match (x) {
        1 => match (y) {
            2 => match (z) {
                3 => 123,
                _ => 0,
            },
            _ => 0,
        },
        _ => 0,
    };
    assert(result == 123);
}

it("should handle nested match with different paths") {
    let outer = 2;
    let inner = 1;
    let result = match (outer) {
        1 => match (inner) { 1 => 11, _ => 10 },
        2 => match (inner) { 1 => 21, _ => 20 },
        _ => 0,
    };
    assert(result == 21);
}

// ============================================================================
// EDGE CASES - OPTION PATTERNS
// ============================================================================

it("should match Some with computed value") {
    let x = 5;
    let opt: Option = Option.Some(x * 2);
    let value = match (opt) {
        Option.Some(v) => v,
        Option.None => 0,
    };
    assert(value == 10);
}

it("should match None and provide default") {
    let opt: Option = Option.None;
    let value = match (opt) {
        Option.Some(v) => v,
        Option.None => -1,
    };
    assert(value == -1);
}

// ============================================================================
// EDGE CASES - MATCH WITH FUNCTIONS
// ============================================================================

fn classify_number(n: i32): i32 {
    return match (n) {
        0 => 0,
        1 => 1,
        _ => if (n < 0) { -1 } else { 2 },
    };
}

it("should classify numbers with match") {
    assert(classify_number(0) == 0);
    assert(classify_number(1) == 1);
    assert(classify_number(-5) == -1);
    assert(classify_number(10) == 2);
}

fn get_sign(n: i32): i32 {
    return match (n > 0) {
        true => 1,
        false => match (n < 0) {
            true => -1,
            false => 0,
        },
    };
}

it("should get sign with nested match") {
    assert(get_sign(10) == 1);
    assert(get_sign(-10) == -1);
    assert(get_sign(0) == 0);
}

// ============================================================================
// EDGE CASES - CONSECUTIVE MATCHES
// ============================================================================

it("should handle multiple consecutive matches") {
    let a = 1;
    let b = 2;
    let c = 3;
    let r1 = match (a) { 1 => 10, _ => 0 };
    let r2 = match (b) { 2 => 20, _ => 0 };
    let r3 = match (c) { 3 => 30, _ => 0 };
    assert(r1 + r2 + r3 == 60);
}

// ============================================================================
// EDGE CASES - MATCH ARM ORDER
// ============================================================================

it("should match first matching arm") {
    let x = 5;
    // The wildcard would match, but specific pattern comes first
    let result = match (x) {
        5 => 100,
        _ => 0,
    };
    assert(result == 100);
}

it("should match wildcard when no specific match") {
    let x = 42;
    let result = match (x) {
        1 => 1,
        2 => 2,
        3 => 3,
        _ => 999,
    };
    assert(result == 999);
}

// ============================================================================
// PATTERN GUARDS (if conditions)
// ============================================================================

it("should match with simple guard") {
    let x = 10;
    let result = match (x) {
        n if n > 5 => 1,
        n if n <= 5 => 0,
        _ => -1,
    };
    assert(result == 1);
}

it("should match guard with equality check") {
    let x = 42;
    let result = match (x) {
        n if n == 42 => 100,
        n if n == 0 => 0,
        _ => -1,
    };
    assert(result == 100);
}

it("should match guard with range check") {
    let x = 25;
    let result = match (x) {
        n if n >= 1 and n <= 10 => 1,
        n if n >= 11 and n <= 30 => 2,
        n if n >= 31 and n <= 50 => 3,
        _ => 0,
    };
    assert(result == 2);
}

it("should match guard with modulo check") {
    let x = 15;
    let result = match (x) {
        n if n % 3 == 0 and n % 5 == 0 => 3,
        n if n % 3 == 0 => 1,
        n if n % 5 == 0 => 2,
        _ => 0,
    };
    assert(result == 3);
}

it("should match guard with negative number") {
    let x = -5;
    let result = match (x) {
        n if n < 0 => -1,
        n if n > 0 => 1,
        _ => 0,
    };
    assert(result == -1);
}

it("should match guard with zero check") {
    let x = 0;
    let result = match (x) {
        n if n < 0 => -1,
        n if n > 0 => 1,
        0 => 0,
        _ => -999,
    };
    assert(result == 0);
}

it("should match first satisfied guard") {
    let x = 10;
    let result = match (x) {
        n if n > 5 => 1,
        n if n > 0 => 2,
        _ => 0,
    };
    assert(result == 1);
}

it("should use captured variable in guard") {
    let x = 20;
    let threshold = 15;
    let result = match (x) {
        n if n > threshold => 1,
        n if n == threshold => 0,
        _ => -1,
    };
    assert(result == 1);
}

// ============================================================================
// STRUCT DESTRUCTURING IN MATCH
// ============================================================================

struct Point { x: i32, y: i32 }

it("should destructure struct in match") {
    let p = Point { x: 10, y: 20 };
    let result = match (p) {
        Point { x: 0, y: 0 } => 0,
        Point { x: 10, y: 20 } => 1,
        _ => -1,
    };
    assert(result == 1);
}

it("should capture struct fields in match") {
    let p = Point { x: 5, y: 7 };
    let result = match (p) {
        Point { x, y } => x + y,
    };
    assert(result == 12);
}

it("should destructure with partial match") {
    let p = Point { x: 10, y: 99 };
    let result = match (p) {
        Point { x: 10, y } => y,
        Point { x, y: 0 } => x,
        _ => 0,
    };
    assert(result == 99);
}

it("should match struct with guard") {
    let p = Point { x: 5, y: 10 };
    let result = match (p) {
        Point { x, y } if x == y => 0,
        Point { x, y } if x < y => 1,
        Point { x, y } if x > y => 2,
        _ => -1,
    };
    assert(result == 1);
}

it("should match origin point") {
    let p = Point { x: 0, y: 0 };
    let result = match (p) {
        Point { x: 0, y: 0 } => 1,
        Point { x: 0, y } => 2,
        Point { x, y: 0 } => 3,
        _ => 4,
    };
    assert(result == 1);
}

it("should match on x-axis") {
    let p = Point { x: 5, y: 0 };
    let result = match (p) {
        Point { x: 0, y: 0 } => 1,
        Point { x: 0, y } => 2,
        Point { x, y: 0 } => 3,
        _ => 4,
    };
    assert(result == 3);
}

it("should match on y-axis") {
    let p = Point { x: 0, y: 7 };
    let result = match (p) {
        Point { x: 0, y: 0 } => 1,
        Point { x: 0, y } => 2,
        Point { x, y: 0 } => 3,
        _ => 4,
    };
    assert(result == 2);
}

// ============================================================================
// TUPLE DESTRUCTURING IN MATCH
// ============================================================================

it("should destructure tuple in match") {
    let t = (1, 2);
    let result = match (t) {
        (0, 0) => 0,
        (1, 2) => 1,
        _ => -1,
    };
    assert(result == 1);
}

it("should capture tuple elements") {
    let t = (10, 20);
    let result = match (t) {
        (a, b) => a + b,
    };
    assert(result == 30);
}

it("should match tuple with partial pattern") {
    let t = (5, 100);
    let result = match (t) {
        (5, x) => x,
        (x, 5) => x,
        _ => 0,
    };
    assert(result == 100);
}

it("should match tuple with guard") {
    let t = (3, 7);
    let result = match (t) {
        (a, b) if a + b > 10 => 2,
        (a, b) if a + b == 10 => 1,
        (a, b) if a + b < 10 => 0,
        _ => -1,
    };
    assert(result == 0);
}

it("should match nested tuple") {
    let t = ((1, 2), 3);
    let result = match (t) {
        ((1, 2), 3) => 1,
        _ => 0,
    };
    assert(result == 1);
}

it("should capture from nested tuple") {
    let t = ((10, 20), 30);
    let result = match (t) {
        ((a, b), c) => a + b + c,
    };
    assert(result == 60);
}

// ============================================================================
// ARRAY PATTERN MATCHING
// ============================================================================

it("should match empty array") {
    let arr: [i32] = [];
    let result = match (arr) {
        [] => 0,
        _ => 1,
    };
    assert(result == 0);
}

it("should match single element array") {
    let arr = [42];
    let result = match (arr) {
        [] => 0,
        [x] => x,
        _ => -1,
    };
    assert(result == 42);
}

it("should match array with two elements") {
    let arr = [1, 2];
    let result = match (arr) {
        [] => 0,
        [x] => x,
        [x, y] => x + y,
        _ => -1,
    };
    assert(result == 3);
}

it("should match array head and rest") {
    let arr = [1, 2, 3, 4];
    let result = match (arr) {
        [] => 0,
        [head, ..rest] => head,
    };
    assert(result == 1);
}

it("should match array with specific values") {
    let arr = [1, 2, 3];
    let result = match (arr) {
        [1, 2, 3] => 1,
        [1, 2, x] => 2,
        _ => 0,
    };
    assert(result == 1);
}

// ============================================================================
// OR PATTERNS
// ============================================================================

it("should match with or pattern") {
    let x = 2;
    let result = match (x) {
        1 | 2 | 3 => 1,
        4 | 5 | 6 => 2,
        _ => 0,
    };
    assert(result == 1);
}

it("should match last or alternative") {
    let x = 6;
    let result = match (x) {
        1 | 2 | 3 => 1,
        4 | 5 | 6 => 2,
        _ => 0,
    };
    assert(result == 2);
}

it("should not match or pattern") {
    let x = 10;
    let result = match (x) {
        1 | 2 | 3 => 1,
        4 | 5 | 6 => 2,
        _ => 0,
    };
    assert(result == 0);
}

it("should match negative or pattern") {
    let x = -2;
    let result = match (x) {
        -3 | -2 | -1 => 1,
        0 => 2,
        1 | 2 | 3 => 3,
        _ => 0,
    };
    assert(result == 1);
}

// ============================================================================
// RANGE PATTERNS
// ============================================================================

it("should match inclusive range pattern") {
    let x = 5;
    let result = match (x) {
        1..=3 => 1,
        4..=6 => 2,
        7..=9 => 3,
        _ => 0,
    };
    assert(result == 2);
}

it("should match range start") {
    let x = 1;
    let result = match (x) {
        1..=5 => 1,
        _ => 0,
    };
    assert(result == 1);
}

it("should match range end") {
    let x = 5;
    let result = match (x) {
        1..=5 => 1,
        _ => 0,
    };
    assert(result == 1);
}

it("should not match outside range") {
    let x = 10;
    let result = match (x) {
        1..=5 => 1,
        _ => 0,
    };
    assert(result == 0);
}

it("should match negative range") {
    let x = -3;
    let result = match (x) {
        -5..=-1 => 1,
        0..=5 => 2,
        _ => 0,
    };
    assert(result == 1);
}

// ============================================================================
// ENUM VARIANT DESTRUCTURING
// ============================================================================

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(string),
    ChangeColor(i32, i32, i32)
}

it("should match unit enum variant") {
    let msg: Message = Message.Quit;
    let result = match (msg) {
        Message.Quit => 0,
        Message.Move { x, y } => 1,
        Message.Write(s) => 2,
        Message.ChangeColor(r, g, b) => 3,
    };
    assert(result == 0);
}

it("should match struct-like enum variant") {
    let msg: Message = Message.Move { x: 10, y: 20 };
    let result = match (msg) {
        Message.Quit => 0,
        Message.Move { x, y } => x + y,
        Message.Write(s) => 0,
        Message.ChangeColor(r, g, b) => 0,
    };
    assert(result == 30);
}

it("should match tuple enum variant single value") {
    let msg: Message = Message.Write("hello");
    let result = match (msg) {
        Message.Quit => 0,
        Message.Move { x, y } => 0,
        Message.Write(s) => s.len(),
        Message.ChangeColor(r, g, b) => 0,
    };
    assert(result == 5);
}

it("should match tuple enum variant multiple values") {
    let msg: Message = Message.ChangeColor(255, 128, 0);
    let result = match (msg) {
        Message.Quit => 0,
        Message.Move { x, y } => 0,
        Message.Write(s) => 0,
        Message.ChangeColor(r, g, b) => r + g + b,
    };
    assert(result == 383);
}

// ============================================================================
// DEEPLY NESTED PATTERN MATCHING
// ============================================================================

enum NestedOpt {
    Some(Option),
    None
}

it("should match deeply nested enum") {
    let nested: NestedOpt = NestedOpt.Some(Option.Some(42));
    let result = match (nested) {
        NestedOpt.Some(Option.Some(x)) => x,
        NestedOpt.Some(Option.None) => -1,
        NestedOpt.None => -2,
    };
    assert(result == 42);
}

it("should match inner None") {
    let nested: NestedOpt = NestedOpt.Some(Option.None);
    let result = match (nested) {
        NestedOpt.Some(Option.Some(x)) => x,
        NestedOpt.Some(Option.None) => -1,
        NestedOpt.None => -2,
    };
    assert(result == -1);
}

it("should match outer None") {
    let nested: NestedOpt = NestedOpt.None;
    let result = match (nested) {
        NestedOpt.Some(Option.Some(x)) => x,
        NestedOpt.Some(Option.None) => -1,
        NestedOpt.None => -2,
    };
    assert(result == -2);
}

// ============================================================================
// MATCH IN COMPLEX EXPRESSIONS
// ============================================================================

fn categorize(value: i32): string {
    return match (value) {
        n if n < 0 => "negative",
        0 => "zero",
        n if n > 0 and n <= 10 => "small",
        n if n > 10 and n <= 100 => "medium",
        _ => "large",
    };
}

it("should categorize negative") {
    assert(categorize(-5) == "negative");
}

it("should categorize zero") {
    assert(categorize(0) == "zero");
}

it("should categorize small") {
    assert(categorize(5) == "small");
}

it("should categorize medium") {
    assert(categorize(50) == "medium");
}

it("should categorize large") {
    assert(categorize(1000) == "large");
}

// ============================================================================
// BINDING WITH @
// ============================================================================

it("should bind entire pattern with @") {
    let p = Point { x: 5, y: 10 };
    let result = match (p) {
        whole @ Point { x, y } if x + y > 10 => whole.x * whole.y,
        _ => 0,
    };
    assert(result == 50);
}

it("should use @ binding in simple pattern") {
    let x = 42;
    let result = match (x) {
        n @ 1..=50 => n * 2,
        n @ 51..=100 => n,
        _ => 0,
    };
    assert(result == 84);
}

// ============================================================================
// STRING PATTERN MATCHING
// ============================================================================

it("should match string literals") {
    let s = "hello";
    let result = match (s) {
        "hello" => 1,
        "world" => 2,
        _ => 0,
    };
    assert(result == 1);
}

it("should match empty string") {
    let s = "";
    let result = match (s) {
        "" => 0,
        "a" => 1,
        _ => 2,
    };
    assert(result == 0);
}

it("should match with string guard") {
    let s = "test";
    let result = match (s) {
        x if x.len() > 5 => 1,
        x if x.len() > 0 => 2,
        _ => 0,
    };
    assert(result == 2);
}

