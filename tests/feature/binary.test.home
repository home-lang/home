// Binary Operations Test Suite

// ============================================================================
// BINARY REPRESENTATION
// ============================================================================

it("should represent binary numbers") {
    // Binary 1010 = decimal 10
    let binary = 0b1010;
    assert(binary == 10);
}

it("should represent hex numbers") {
    let hex = 0xFF;
    assert(hex == 255);
}

it("should represent octal numbers") {
    let octal = 0o17;
    assert(octal == 15);
}

// ============================================================================
// BIT OPERATIONS
// ============================================================================

it("should perform bitwise AND") {
    assert((0b1100 & 0b1010) == 0b1000);  // 12 & 10 = 8
    assert((15 & 8) == 8);
    assert((255 & 0) == 0);
}

it("should perform bitwise OR") {
    assert((0b1100 | 0b1010) == 0b1110);  // 12 | 10 = 14
    assert((8 | 4) == 12);
    assert((0 | 255) == 255);
}

it("should perform bitwise XOR") {
    assert((0b1100 ^ 0b1010) == 0b0110);  // 12 ^ 10 = 6
    assert((15 ^ 15) == 0);
    assert((0 ^ 255) == 255);
}

it("should perform bitwise NOT") {
    // NOT on 8-bit: ~0 = 255, ~255 = 0
    let val = 0b11110000;
    let inverted = ~val;
    // The result depends on integer size
    assert((inverted & 0xFF) == 0b00001111);
}

it("should left shift") {
    assert((1 << 0) == 1);
    assert((1 << 1) == 2);
    assert((1 << 2) == 4);
    assert((1 << 3) == 8);
    assert((1 << 4) == 16);
    assert((5 << 2) == 20);  // 5 * 4
}

it("should right shift") {
    assert((16 >> 1) == 8);
    assert((16 >> 2) == 4);
    assert((16 >> 3) == 2);
    assert((16 >> 4) == 1);
    assert((255 >> 4) == 15);
}

// ============================================================================
// BIT MANIPULATION
// ============================================================================

it("should set bit") {
    let val = 0b0000;
    let bit_position = 2;
    let result = val | (1 << bit_position);
    assert(result == 0b0100);  // 4
}

it("should clear bit") {
    let val = 0b1111;
    let bit_position = 2;
    let result = val & ~(1 << bit_position);
    assert((result & 0xF) == 0b1011);  // 11
}

it("should toggle bit") {
    let val = 0b1010;
    let bit_position = 1;
    let result = val ^ (1 << bit_position);
    assert(result == 0b1000);  // 8
}

it("should check if bit is set") {
    let val = 0b1010;
    let bit_1_set = (val & (1 << 1)) != 0;
    let bit_2_set = (val & (1 << 2)) != 0;
    assert(bit_1_set == true);
    assert(bit_2_set == false);
}

// ============================================================================
// POWER OF TWO
// ============================================================================

it("should check power of two") {
    // A number is power of two if n & (n-1) == 0
    let n = 16;
    let is_power_of_two = n > 0 and (n & (n - 1)) == 0;
    assert(is_power_of_two == true);
}

it("should check not power of two") {
    let n = 15;
    let is_power_of_two = n > 0 and (n & (n - 1)) == 0;
    assert(is_power_of_two == false);
}

// ============================================================================
// COUNTING BITS
// ============================================================================

it("should count set bits") {
    let n = 0b11010111;  // 215
    let mut count = 0;
    let mut val = n;

    while (val > 0) {
        count = count + (val & 1);
        val = val >> 1;
    }

    assert(count == 6);  // 6 bits set
}

// ============================================================================
// BIT MASKING
// ============================================================================

it("should extract bits with mask") {
    let value = 0b11010110;  // 214
    let mask = 0b00001111;   // Extract lower 4 bits
    let extracted = value & mask;
    assert(extracted == 0b0110);  // 6
}

it("should extract higher bits") {
    let value = 0b11010110;  // 214
    let higher = value >> 4;
    assert(higher == 0b1101);  // 13
}

// ============================================================================
// BYTE OPERATIONS
// ============================================================================

it("should extract individual bytes") {
    let value = 0x12345678;
    let byte0 = value & 0xFF;
    let byte1 = (value >> 8) & 0xFF;
    let byte2 = (value >> 16) & 0xFF;
    let byte3 = (value >> 24) & 0xFF;

    assert(byte0 == 0x78);
    assert(byte1 == 0x56);
    assert(byte2 == 0x34);
    assert(byte3 == 0x12);
}

it("should combine bytes") {
    let byte0 = 0x78;
    let byte1 = 0x56;
    let byte2 = 0x34;
    let byte3 = 0x12;

    let combined = byte0 | (byte1 << 8) | (byte2 << 16) | (byte3 << 24);
    assert(combined == 0x12345678);
}

// ============================================================================
// SWAP WITHOUT TEMP
// ============================================================================

it("should swap using XOR") {
    let mut a = 5;
    let mut b = 10;

    a = a ^ b;
    b = a ^ b;
    a = a ^ b;

    assert(a == 10);
    assert(b == 5);
}

// ============================================================================
// SIGN OPERATIONS
// ============================================================================

it("should check if negative using sign bit") {
    let pos = 10;
    let neg = -10;

    assert(pos >= 0);
    assert(neg < 0);
}

it("should get absolute value without branching") {
    let n = -5;
    // For signed integers, can use mask trick
    let mask = n >> 31;  // All 1s if negative, all 0s if positive
    let abs_val = (n + mask) ^ mask;
    // Note: This assumes 32-bit integers
}

// ============================================================================
// ALIGNMENT
// ============================================================================

it("should align to power of two") {
    let value = 13;
    let alignment = 8;  // Must be power of two

    // Round up to nearest multiple of alignment
    let aligned = (value + alignment - 1) & ~(alignment - 1);
    assert(aligned == 16);
}

it("should check alignment") {
    let value = 16;
    let alignment = 8;

    let is_aligned = (value & (alignment - 1)) == 0;
    assert(is_aligned == true);
}

it("should check misalignment") {
    let value = 13;
    let alignment = 8;

    let is_aligned = (value & (alignment - 1)) == 0;
    assert(is_aligned == false);
}
