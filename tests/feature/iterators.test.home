// Iterator Concepts Test Suite
// Testing iteration patterns using basic operations

// ============================================================================
// BASIC ITERATION
// ============================================================================

it("should iterate over array") {
    let arr = [1, 2, 3, 4, 5];
    let mut sum = 0;
    for (x in arr) {
        sum = sum + x;
    }
    assert(sum == 15);
}

it("should iterate with index") {
    let arr = ["a", "b", "c"];
    let mut result = "";
    for (i in 0..arr.len()) {
        result = result + arr[i];
    }
    assert(result == "abc");
}

it("should count elements") {
    let arr = [1, 2, 3, 4, 5];
    assert(arr.len() == 5);
}

// ============================================================================
// MAP CONCEPT
// ============================================================================

it("should transform values with loop") {
    let arr = [1, 2, 3];
    let mut doubled = [];
    for (x in arr) {
        doubled = doubled.push(x * 2);
    }
    assert(doubled[0] == 2);
    assert(doubled[1] == 4);
    assert(doubled[2] == 6);
}

it("should chain transformations") {
    let arr = [1, 2, 3];
    let mut result = [];
    for (x in arr) {
        let doubled = x * 2;
        let plus_one = doubled + 1;
        result = result.push(plus_one);
    }
    assert(result[0] == 3);
    assert(result[1] == 5);
    assert(result[2] == 7);
}

// ============================================================================
// FILTER CONCEPT
// ============================================================================

it("should filter values with loop") {
    let arr = [1, 2, 3, 4, 5];
    let mut evens = [];
    for (x in arr) {
        if (x % 2 == 0) {
            evens = evens.push(x);
        }
    }
    assert(evens.len() == 2);
    assert(evens[0] == 2);
    assert(evens[1] == 4);
}

it("should filter with complex condition") {
    let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let mut result = [];
    for (x in arr) {
        if (x > 3 and x < 8) {
            result = result.push(x);
        }
    }
    assert(result.len() == 4);
}

it("should filter to empty") {
    let arr = [1, 2, 3];
    let mut result = [];
    for (x in arr) {
        if (x > 10) {
            result = result.push(x);
        }
    }
    assert(result.len() == 0);
}

// ============================================================================
// MAP AND FILTER COMBINED
// ============================================================================

it("should chain filter and map") {
    let arr = [1, 2, 3, 4, 5];
    let mut result = [];
    for (x in arr) {
        if (x % 2 == 1) {
            result = result.push(x * 2);
        }
    }
    assert(result.len() == 3);
    assert(result[0] == 2);
    assert(result[1] == 6);
    assert(result[2] == 10);
}

// ============================================================================
// REDUCE CONCEPT
// ============================================================================

it("should reduce to sum") {
    let arr = [1, 2, 3, 4, 5];
    let mut sum = 0;
    for (x in arr) {
        sum = sum + x;
    }
    assert(sum == 15);
}

it("should reduce to product") {
    let arr = [1, 2, 3, 4];
    let mut product = 1;
    for (x in arr) {
        product = product * x;
    }
    assert(product == 24);
}

it("should reduce to max") {
    let arr = [3, 1, 4, 1, 5, 9, 2, 6];
    let mut max = arr[0];
    for (x in arr) {
        if (x > max) {
            max = x;
        }
    }
    assert(max == 9);
}

it("should reduce to min") {
    let arr = [3, 1, 4, 1, 5, 9, 2, 6];
    let mut min = arr[0];
    for (x in arr) {
        if (x < min) {
            min = x;
        }
    }
    assert(min == 1);
}

// ============================================================================
// FIND CONCEPT
// ============================================================================

it("should find first matching element") {
    let arr = [1, 2, 3, 4, 5];
    let mut found = -1;
    for (x in arr) {
        if (x > 3 and found == -1) {
            found = x;
        }
    }
    assert(found == 4);
}

it("should return sentinel when not found") {
    let arr = [1, 2, 3];
    let mut found = -1;
    for (x in arr) {
        if (x > 10) {
            found = x;
        }
    }
    assert(found == -1);
}

it("should find index") {
    let arr = ["a", "b", "c", "d"];
    let mut idx = -1;
    for (i in 0..arr.len()) {
        if (arr[i] == "c") {
            idx = i;
        }
    }
    assert(idx == 2);
}

// ============================================================================
// ANY AND ALL
// ============================================================================

it("should check if any match") {
    let arr = [1, 2, 3, 4, 5];
    let mut any_greater = false;
    for (x in arr) {
        if (x > 4) {
            any_greater = true;
        }
    }
    assert(any_greater == true);
}

it("should check if none match") {
    let arr = [1, 2, 3, 4, 5];
    let mut any_greater = false;
    for (x in arr) {
        if (x > 10) {
            any_greater = true;
        }
    }
    assert(any_greater == false);
}

it("should check if all match") {
    let arr = [2, 4, 6, 8];
    let mut all_even = true;
    for (x in arr) {
        if (x % 2 != 0) {
            all_even = false;
        }
    }
    assert(all_even == true);
}

it("should check if not all match") {
    let arr = [2, 4, 5, 8];
    let mut all_even = true;
    for (x in arr) {
        if (x % 2 != 0) {
            all_even = false;
        }
    }
    assert(all_even == false);
}

// ============================================================================
// COUNT WITH CONDITION
// ============================================================================

it("should count matching elements") {
    let arr = [1, 2, 3, 4, 5];
    let mut even_count = 0;
    for (x in arr) {
        if (x % 2 == 0) {
            even_count = even_count + 1;
        }
    }
    assert(even_count == 2);
}

// ============================================================================
// TAKE CONCEPT
// ============================================================================

it("should take first n elements") {
    let arr = [1, 2, 3, 4, 5];
    let mut first_three = [];
    let n = 3;
    for (i in 0..n) {
        first_three = first_three.push(arr[i]);
    }
    assert(first_three.len() == 3);
    assert(first_three[0] == 1);
    assert(first_three[2] == 3);
}

it("should skip first n elements") {
    let arr = [1, 2, 3, 4, 5];
    let mut after_two = [];
    let skip = 2;
    for (i in skip..arr.len()) {
        after_two = after_two.push(arr[i]);
    }
    assert(after_two.len() == 3);
    assert(after_two[0] == 3);
}

// ============================================================================
// TAKE WHILE CONCEPT
// ============================================================================

it("should take while condition is true") {
    let arr = [1, 2, 3, 4, 5];
    let mut result = [];
    let mut taking = true;
    for (x in arr) {
        if (x < 4 and taking) {
            result = result.push(x);
        } else {
            taking = false;
        }
    }
    assert(result.len() == 3);
}

// ============================================================================
// FLATTEN CONCEPT
// ============================================================================

it("should flatten nested array") {
    let nested = [[1, 2], [3, 4], [5]];
    let mut flat = [];
    for (inner in nested) {
        for (x in inner) {
            flat = flat.push(x);
        }
    }
    assert(flat.len() == 5);
    assert(flat[0] == 1);
    assert(flat[4] == 5);
}

// ============================================================================
// ZIP CONCEPT
// ============================================================================

it("should zip two arrays manually") {
    let a = [1, 2, 3];
    let b = [10, 20, 30];
    let mut sums = [];
    for (i in 0..a.len()) {
        sums = sums.push(a[i] + b[i]);
    }
    assert(sums[0] == 11);
    assert(sums[1] == 22);
    assert(sums[2] == 33);
}

// ============================================================================
// UNIQUE CONCEPT
// ============================================================================

it("should get unique elements") {
    let arr = [1, 2, 2, 3, 3, 3, 4];
    let mut unique = [];
    for (x in arr) {
        let mut found = false;
        for (u in unique) {
            if (u == x) {
                found = true;
            }
        }
        if (!found) {
            unique = unique.push(x);
        }
    }
    assert(unique.len() == 4);
}

// ============================================================================
// PARTITION CONCEPT
// ============================================================================

it("should partition by condition") {
    let arr = [1, 2, 3, 4, 5, 6];
    let mut evens = [];
    let mut odds = [];
    for (x in arr) {
        if (x % 2 == 0) {
            evens = evens.push(x);
        } else {
            odds = odds.push(x);
        }
    }
    assert(evens.len() == 3);
    assert(odds.len() == 3);
}

// ============================================================================
// REVERSE CONCEPT
// ============================================================================

it("should reverse array") {
    let arr = [1, 2, 3, 4, 5];
    let mut reversed = [];
    let n = arr.len();
    for (i in 0..n) {
        reversed = reversed.push(arr[n - 1 - i]);
    }
    assert(reversed[0] == 5);
    assert(reversed[4] == 1);
}

// ============================================================================
// SORT CONCEPT (BUBBLE SORT)
// ============================================================================

it("should sort ascending") {
    let mut arr = [3, 1, 4, 1, 5, 9, 2, 6];
    let n = arr.len();
    for (i in 0..n) {
        for (j in 0..(n - 1 - i)) {
            if (arr[j] > arr[j + 1]) {
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    assert(arr[0] == 1);
    assert(arr[7] == 9);
}

// ============================================================================
// CHUNK CONCEPT
// ============================================================================

it("should process in chunks") {
    let arr = [1, 2, 3, 4, 5, 6, 7];
    let chunk_size = 3;
    let mut chunk_count = 0;
    let mut i = 0;
    while (i < arr.len()) {
        chunk_count = chunk_count + 1;
        i = i + chunk_size;
    }
    assert(chunk_count == 3);  // [1,2,3], [4,5,6], [7]
}

// ============================================================================
// FIRST AND LAST
// ============================================================================

it("should get first element") {
    let arr = [1, 2, 3];
    assert(arr.first() == 1);
}

it("should get last element") {
    let arr = [1, 2, 3];
    assert(arr.last() == 3);
}

it("should handle empty array") {
    let arr = [];
    assert(arr.is_empty() == true);
}

// ============================================================================
// NTH ELEMENT
// ============================================================================

it("should get nth element safely") {
    let arr = [10, 20, 30, 40, 50];
    let idx = 2;
    if (idx < arr.len()) {
        assert(arr[idx] == 30);
    }
}

it("should check out of bounds") {
    let arr = [1, 2, 3];
    let idx = 10;
    let in_bounds = idx < arr.len();
    assert(in_bounds == false);
}

// ============================================================================
// ENUMERATE SIMULATION
// ============================================================================

it("should track index while iterating") {
    let arr = ["a", "b", "c"];
    let mut result = "";
    for (i in 0..arr.len()) {
        result = result + arr[i];
    }
    assert(result == "abc");
}

// ============================================================================
// COLLECTING RESULTS
// ============================================================================

it("should collect transformed results") {
    let arr = [1, 2, 3];
    let mut result = [];
    for (x in arr) {
        result = result.push(x * x);
    }
    assert(result[0] == 1);
    assert(result[1] == 4);
    assert(result[2] == 9);
}
