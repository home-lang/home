// Impl Blocks Test Suite
// Tests struct method implementations using impl blocks

struct Counter {
    value: i32
}

impl Counter {
    fn new(): Counter {
        return Counter { value: 0 };
    }

    fn get(self): i32 {
        return self.value;
    }

    fn increment(self): Counter {
        return Counter { value: self.value + 1 };
    }

    fn add(self, amount: i32): Counter {
        return Counter { value: self.value + amount };
    }
}

it("should call method with self") {
    let c = Counter { value: 10 };
    let result = c.get();
    assert(result == 10);
}

it("should call method that returns new struct") {
    let c = Counter { value: 5 };
    let c2 = c.increment();
    assert(c2.value == 6);
}

it("should call method with arguments") {
    let c = Counter { value: 10 };
    let c2 = c.add(5);
    assert(c2.value == 15);
}

it("should chain method calls") {
    let c = Counter { value: 0 };
    let result = c.increment().increment().increment();
    assert(result.value == 3);
}

struct Rectangle {
    width: i32,
    height: i32
}

impl Rectangle {
    fn area(self): i32 {
        return self.width * self.height;
    }

    fn perimeter(self): i32 {
        return 2 * (self.width + self.height);
    }

    fn is_square(self): bool {
        return self.width == self.height;
    }

    fn scale(self, factor: i32): Rectangle {
        return Rectangle { width: self.width * factor, height: self.height * factor };
    }
}

it("should compute area") {
    let rect = Rectangle { width: 10, height: 5 };
    assert(rect.area() == 50);
}

it("should compute perimeter") {
    let rect = Rectangle { width: 10, height: 5 };
    assert(rect.perimeter() == 30);
}

it("should check if square") {
    let square = Rectangle { width: 5, height: 5 };
    let rect = Rectangle { width: 10, height: 5 };
    assert(square.is_square() == true);
    assert(rect.is_square() == false);
}

it("should scale rectangle") {
    let rect = Rectangle { width: 3, height: 4 };
    let scaled = rect.scale(2);
    assert(scaled.width == 6);
    assert(scaled.height == 8);
}

struct Point {
    x: i32,
    y: i32
}

impl Point {
    fn origin(): Point {
        return Point { x: 0, y: 0 };
    }

    fn move_to(self, new_x: i32, new_y: i32): Point {
        return Point { x: new_x, y: new_y };
    }

    fn translate(self, dx: i32, dy: i32): Point {
        return Point { x: self.x + dx, y: self.y + dy };
    }

    fn distance_from_origin(self): i32 {
        return self.x * self.x + self.y * self.y;
    }
}

it("should create point and move") {
    let p = Point { x: 0, y: 0 };
    let p2 = p.move_to(3, 4);
    assert(p2.x == 3);
    assert(p2.y == 4);
}

it("should translate point") {
    let p = Point { x: 5, y: 5 };
    let p2 = p.translate(3, -2);
    assert(p2.x == 8);
    assert(p2.y == 3);
}

it("should compute distance squared from origin") {
    let p = Point { x: 3, y: 4 };
    let dist_sq = p.distance_from_origin();
    assert(dist_sq == 25);
}

