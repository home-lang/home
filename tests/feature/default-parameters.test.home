// Default Parameters Test Suite
// Tests functions with default parameter values

fn greet(name: string = "World"): string {
    return "Hello, " + name + "!";
}

fn add(a: i32, b: i32 = 10): i32 {
    return a + b;
}

fn calculate(a: i32, b: i32 = 5, c: i32 = 1): i32 {
    return (a + b) * c;
}

fn power_default(base: i32, exp: i32 = 2): i32 {
    let mut result = 1;
    let mut i = 0;
    while (i < exp) {
        result = result * base;
        i = i + 1;
    }
    return result;
}

it("should use default when no arg provided") {
    assert(greet() == "Hello, World!");
}

it("should use provided arg over default") {
    assert(greet("Alice") == "Hello, Alice!");
}

it("should work with numeric defaults") {
    assert(add(5) == 15);
    assert(add(5, 20) == 25);
}

it("should handle multiple defaults") {
    assert(calculate(10) == 15);         // (10 + 5) * 1
    assert(calculate(10, 10) == 20);     // (10 + 10) * 1
    assert(calculate(10, 10, 2) == 40);  // (10 + 10) * 2
}

it("should work with power function") {
    assert(power_default(3) == 9);       // 3^2
    assert(power_default(2) == 4);       // 2^2
    assert(power_default(2, 3) == 8);    // 2^3
    assert(power_default(5, 3) == 125);  // 5^3
}

fn with_bool_default(flag: bool = true): i32 {
    if (flag) { return 1; }
    return 0;
}

it("should work with boolean defaults") {
    assert(with_bool_default() == 1);
    assert(with_bool_default(false) == 0);
    assert(with_bool_default(true) == 1);
}

fn range_sum(start: i32 = 0, end: i32 = 10, step: i32 = 1): i32 {
    let mut sum = 0;
    let mut i = start;
    while (i < end) {
        sum = sum + i;
        i = i + step;
    }
    return sum;
}

it("should work with all defaults") {
    assert(range_sum() == 45);  // 0..10 step 1
}

it("should work with partial defaults") {
    assert(range_sum(5) == 35);       // 5..10 step 1
    assert(range_sum(0, 5) == 10);    // 0..5 step 1
    assert(range_sum(0, 10, 2) == 20); // 0, 2, 4, 6, 8
}

// ============================================================================
// EDGE CASES - STRING DEFAULTS
// ============================================================================

fn format_message(msg: string = "No message", prefix: string = ">"): string {
    return prefix + " " + msg;
}

it("should use string defaults") {
    assert(format_message() == "> No message");
}

it("should override string defaults") {
    assert(format_message("Hello") == "> Hello");
    assert(format_message("Hi", ">>") == ">> Hi");
}

fn empty_string_default(s: string = ""): string {
    if (s == "") { return "empty"; }
    return s;
}

it("should handle empty string default") {
    assert(empty_string_default() == "empty");
    assert(empty_string_default("text") == "text");
}

// ============================================================================
// EDGE CASES - NUMERIC DEFAULTS
// ============================================================================

fn with_zero_default(x: i32 = 0): i32 {
    return x + 100;
}

it("should handle zero as default") {
    assert(with_zero_default() == 100);
    assert(with_zero_default(5) == 105);
}

fn with_negative_default(x: i32 = -10): i32 {
    return x * 2;
}

it("should handle negative default") {
    assert(with_negative_default() == -20);
    assert(with_negative_default(5) == 10);
}

fn with_large_default(x: i32 = 1000000): i32 {
    return x / 1000;
}

it("should handle large default value") {
    assert(with_large_default() == 1000);
    assert(with_large_default(5000) == 5);
}

// ============================================================================
// EDGE CASES - BOOLEAN DEFAULTS
// ============================================================================

fn with_false_default(flag: bool = false): i32 {
    if (flag) { return 1; }
    return 0;
}

it("should handle false as default") {
    assert(with_false_default() == 0);
    assert(with_false_default(true) == 1);
}

fn toggle(on: bool = true, off: bool = false): bool {
    return on and !off;
}

it("should handle multiple boolean defaults") {
    assert(toggle() == true);
    assert(toggle(false) == false);
    assert(toggle(true, true) == false);
}

// ============================================================================
// EDGE CASES - MULTIPLE DEFAULTS PARTIAL OVERRIDE
// ============================================================================

fn multi_param(a: i32 = 1, b: i32 = 2, c: i32 = 3, d: i32 = 4): i32 {
    return a * 1000 + b * 100 + c * 10 + d;
}

it("should use all defaults") {
    assert(multi_param() == 1234);
}

it("should override first only") {
    assert(multi_param(9) == 9234);
}

it("should override first two") {
    assert(multi_param(9, 8) == 9834);
}

it("should override first three") {
    assert(multi_param(9, 8, 7) == 9874);
}

it("should override all") {
    assert(multi_param(9, 8, 7, 6) == 9876);
}

// ============================================================================
// EDGE CASES - DEFAULTS IN EXPRESSIONS
// ============================================================================

fn scale_with_default(value: i32, factor: i32 = 2): i32 {
    return value * factor;
}

it("should use default in expression") {
    let result = scale_with_default(5) + scale_with_default(3);
    assert(result == 16);  // 10 + 6
}

it("should mix default and override in expression") {
    let result = scale_with_default(5) + scale_with_default(3, 3);
    assert(result == 19);  // 10 + 9
}

// ============================================================================
// EDGE CASES - DEFAULTS IN LOOPS
// ============================================================================

fn counter_default(limit: i32 = 5): i32 {
    let mut count = 0;
    let mut i = 0;
    while (i < limit) {
        count = count + 1;
        i = i + 1;
    }
    return count;
}

it("should use default in loop bound") {
    assert(counter_default() == 5);
    assert(counter_default(10) == 10);
}

// ============================================================================
// EDGE CASES - DEFAULTS WITH STRUCT RETURNS
// ============================================================================

struct Point { x: i32, y: i32 }

fn make_point_default(x: i32 = 0, y: i32 = 0): Point {
    return Point { x: x, y: y };
}

it("should create struct with defaults") {
    let p = make_point_default();
    assert(p.x == 0);
    assert(p.y == 0);
}

it("should create struct with partial defaults") {
    let p = make_point_default(5);
    assert(p.x == 5);
    assert(p.y == 0);
}

it("should create struct overriding all defaults") {
    let p = make_point_default(10, 20);
    assert(p.x == 10);
    assert(p.y == 20);
}

// ============================================================================
// EDGE CASES - NESTED FUNCTION CALLS WITH DEFAULTS
// ============================================================================

fn outer_default(x: i32 = 5): i32 {
    return inner_default(x);
}

fn inner_default(y: i32 = 10): i32 {
    return y * 2;
}

it("should propagate defaults through nested calls") {
    assert(outer_default() == 10);  // outer uses 5, inner gets 5
    assert(inner_default() == 20);  // inner uses 10
}

// ============================================================================
// EDGE CASES - DEFAULTS DEPENDING ON OTHER PARAMS
// ============================================================================

fn clamp_default(value: i32, min: i32 = 0, max: i32 = 100): i32 {
    if (value < min) { return min; }
    if (value > max) { return max; }
    return value;
}

it("should clamp with defaults") {
    assert(clamp_default(-10) == 0);
    assert(clamp_default(50) == 50);
    assert(clamp_default(150) == 100);
}

it("should clamp with custom bounds") {
    assert(clamp_default(50, 60) == 60);
    assert(clamp_default(50, 0, 40) == 40);
}

