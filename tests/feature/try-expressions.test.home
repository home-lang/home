// Try Expression Test Suite
// Tests ? operator and else for error handling

// ============================================================================
// BASIC TRY WITH ELSE
// ============================================================================

it("should use default on error") {
    fn may_fail(x: i32): Result<i32, string> {
        if (x < 0) {
            return Err("negative");
        }
        return Ok(x);
    }

    let result = may_fail(-5) else 0;
    assert(result == 0);
}

it("should use value on success") {
    fn may_fail(x: i32): Result<i32, string> {
        if (x < 0) {
            return Err("negative");
        }
        return Ok(x);
    }

    let result = may_fail(10) else 0;
    assert(result == 10);
}

// ============================================================================
// OK AND ERR CONSTRUCTORS
// ============================================================================

it("should create Ok values") {
    let result = Ok(42);
    assert(result == Ok(42));
}

it("should create Err values") {
    let result = Err("error message");
    assert(result == Err("error message"));
}

// ============================================================================
// RESULT COMPARISON
// ============================================================================

it("should compare Ok values correctly") {
    let a = Ok(10);
    let b = Ok(10);
    let c = Ok(20);
    assert(a == b);
    assert(a != c);
}

it("should compare Err values correctly") {
    let a = Err("error");
    let b = Err("error");
    let c = Err("different");
    assert(a == b);
    assert(a != c);
}

it("should not compare Ok with Err") {
    let ok = Ok(42);
    let err = Err("error");
    assert(ok != err);
}

// ============================================================================
// TRY-ELSE WITH BLOCK
// ============================================================================

it("should use else block for error handling") {
    fn may_fail(x: i32): Result<i32, string> {
        if (x < 0) {
            return Err("negative");
        }
        return Ok(x);
    }

    let result = may_fail(-1) else {
        -100
    };
    assert(result == -100);
}

// ============================================================================
// CHAINED TRY-ELSE
// ============================================================================

it("should chain try-else operations") {
    fn get_value(key: string): Result<i32, string> {
        if (key == "valid") {
            return Ok(100);
        }
        return Err("not found");
    }

    let val1 = get_value("valid") else 0;
    let val2 = get_value("invalid") else 0;
    assert(val1 == 100);
    assert(val2 == 0);
}

// ============================================================================
// TRY EXPRESSION WITH FUNCTION CALL
// ============================================================================

it("should propagate Ok value through try") {
    fn safe_div(a: i32, b: i32): Result<i32, string> {
        if (b == 0) {
            return Err("division by zero");
        }
        return Ok(a / b);
    }

    fn compute(): Result<i32, string> {
        let x = safe_div(10, 2)?;
        return Ok(x * 2);
    }

    let result = compute();
    assert(result == Ok(10));
}

// ============================================================================
// EDGE CASES - OK VALUES
// ============================================================================

it("should handle Ok with zero") {
    let result = Ok(0);
    assert(result == Ok(0));
}

it("should handle Ok with negative number") {
    let result = Ok(-42);
    assert(result == Ok(-42));
}

it("should handle Ok with large number") {
    let result = Ok(999999);
    assert(result == Ok(999999));
}

it("should handle Ok with string") {
    let result = Ok("success");
    assert(result == Ok("success"));
}

it("should handle Ok with empty string") {
    let result = Ok("");
    assert(result == Ok(""));
}

it("should handle Ok with boolean true") {
    let result = Ok(true);
    assert(result == Ok(true));
}

it("should handle Ok with boolean false") {
    let result = Ok(false);
    assert(result == Ok(false));
}

// ============================================================================
// EDGE CASES - ERR VALUES
// ============================================================================

it("should handle Err with empty string") {
    let result = Err("");
    assert(result == Err(""));
}

it("should handle Err with long message") {
    let msg = "This is a very long error message that describes what went wrong";
    let result = Err(msg);
    assert(result == Err(msg));
}

it("should handle Err with number") {
    let result = Err(404);
    assert(result == Err(404));
}

it("should handle Err with zero") {
    let result = Err(0);
    assert(result == Err(0));
}

// ============================================================================
// EDGE CASES - ELSE WITH DIFFERENT TYPES
// ============================================================================

it("should use negative default on error") {
    fn may_fail(x: i32): Result<i32, string> {
        if (x < 0) { return Err("neg"); }
        return Ok(x);
    }
    let result = may_fail(-1) else -999;
    assert(result == -999);
}

it("should use zero default on error") {
    fn may_fail(x: i32): Result<i32, string> {
        if (x < 0) { return Err("neg"); }
        return Ok(x);
    }
    let result = may_fail(-1) else 0;
    assert(result == 0);
}

it("should use computed default on error") {
    fn may_fail(x: i32): Result<i32, string> {
        if (x < 0) { return Err("neg"); }
        return Ok(x);
    }
    let fallback = 10 + 20;
    let result = may_fail(-1) else fallback;
    assert(result == 30);
}

it("should call function in else branch") {
    fn may_fail(x: i32): Result<i32, string> {
        if (x < 0) { return Err("neg"); }
        return Ok(x);
    }
    fn get_default(): i32 { return 42; }
    let result = may_fail(-1) else get_default();
    assert(result == 42);
}

// ============================================================================
// EDGE CASES - MULTIPLE RESULTS
// ============================================================================

it("should handle multiple Ok results in sequence") {
    fn make_ok(x: i32): Result<i32, string> { return Ok(x); }
    let a = make_ok(1) else 0;
    let b = make_ok(2) else 0;
    let c = make_ok(3) else 0;
    assert(a + b + c == 6);
}

it("should handle multiple Err results in sequence") {
    fn make_err(msg: string): Result<i32, string> { return Err(msg); }
    let a = make_err("a") else 10;
    let b = make_err("b") else 20;
    let c = make_err("c") else 30;
    assert(a + b + c == 60);
}

it("should handle mixed Ok and Err results") {
    fn maybe(x: i32): Result<i32, string> {
        if (x % 2 == 0) { return Ok(x); }
        return Err("odd");
    }
    let a = maybe(2) else 0;  // Ok(2)
    let b = maybe(3) else 0;  // Err, use 0
    let c = maybe(4) else 0;  // Ok(4)
    assert(a == 2);
    assert(b == 0);
    assert(c == 4);
}

// ============================================================================
// EDGE CASES - NESTED RESULTS
// ============================================================================

it("should handle result in conditional") {
    fn get_result(success: bool): Result<i32, string> {
        if (success) { return Ok(42); }
        return Err("failed");
    }
    let r = get_result(true);
    let value = if (r == Ok(42)) { 1 } else { 0 };
    assert(value == 1);
}

it("should use result in loop") {
    fn get_value(i: i32): Result<i32, string> {
        if (i < 0) { return Err("negative"); }
        return Ok(i * 2);
    }
    let mut sum = 0;
    for (i in 0..5) {
        let v = get_value(i) else 0;
        sum = sum + v;
    }
    assert(sum == 0 + 2 + 4 + 6 + 8);
}

// ============================================================================
// EDGE CASES - ELSE BLOCK EXPRESSIONS
// ============================================================================

it("should compute complex expression in else block") {
    fn may_fail(x: i32): Result<i32, string> {
        if (x < 0) { return Err("neg"); }
        return Ok(x);
    }
    let result = may_fail(-1) else {
        let a = 10;
        let b = 20;
        a + b + 5
    };
    assert(result == 35);
}

it("should use conditional in else block") {
    fn may_fail(x: i32): Result<i32, string> {
        if (x < 0) { return Err("neg"); }
        return Ok(x);
    }
    let flag = true;
    let fallback = if (flag) { 100 } else { 200 };
    let result = may_fail(-1) else fallback;
    assert(result == 100);
}

// ============================================================================
// EDGE CASES - OPTION TYPE (Some/None)
// ============================================================================

it("should create Some value") {
    let opt = Some(42);
    assert(opt == Some(42));
}

it("should handle None value") {
    let opt = None;
    // None compared with itself
    assert(opt == None);
}

it("should compare Some values") {
    let a = Some(10);
    let b = Some(10);
    let c = Some(20);
    assert(a == b);
    assert(a != c);
}

it("should compare Some with None") {
    let some = Some(42);
    let none = None;
    assert(some != none);
}

it("should handle Some with zero") {
    let opt = Some(0);
    assert(opt == Some(0));
}

it("should handle Some with negative") {
    let opt = Some(-100);
    assert(opt == Some(-100));
}

it("should handle Some with string") {
    let opt = Some("hello");
    assert(opt == Some("hello"));
}

it("should handle Some with empty string") {
    let opt = Some("");
    assert(opt == Some(""));
}

// ============================================================================
// EDGE CASES - ARITHMETIC WITH RESULTS
// ============================================================================

it("should use result value in arithmetic") {
    fn get_num(): Result<i32, string> { return Ok(10); }
    let a = get_num() else 0;
    let b = get_num() else 0;
    assert(a + b == 20);
    assert(a * b == 100);
}

it("should chain arithmetic with multiple results") {
    fn double(x: i32): Result<i32, string> { return Ok(x * 2); }
    let result = (double(5) else 0) + (double(10) else 0);
    assert(result == 30);
}

// ============================================================================
// ERROR PROPAGATION WITH ? OPERATOR
// ============================================================================

fn divide(a: i32, b: i32): Result<i32, string> {
    if (b == 0) {
        return Err("division by zero");
    }
    return Ok(a / b);
}

fn calculate_ratio(a: i32, b: i32, c: i32): Result<i32, string> {
    let first = divide(a, b)?;
    let second = divide(first, c)?;
    return Ok(second);
}

it("should propagate error with ? operator") {
    let result = calculate_ratio(100, 0, 2);
    assert(result == Err("division by zero"));
}

it("should succeed with ? operator on valid input") {
    let result = calculate_ratio(100, 10, 2);
    assert(result == Ok(5));
}

fn chain_operations(x: i32): Result<i32, string> {
    let a = divide(x, 2)?;
    let b = divide(a, 2)?;
    let c = divide(b, 2)?;
    return Ok(c);
}

it("should chain multiple ? operators") {
    let result = chain_operations(80);
    assert(result == Ok(10));
}

it("should fail at any point in chain") {
    let result = chain_operations(6);  // 6/2=3, 3/2=1, 1/2=0
    assert(result == Ok(0));
}

// ============================================================================
// ? OPERATOR WITH OPTION TYPE
// ============================================================================

fn find_in_array(arr: [i32], target: i32): Option<i32> {
    for (i in 0..arr.len()) {
        if (arr[i] == target) {
            return Some(i);
        }
    }
    return None;
}

fn find_and_double(arr: [i32], target: i32): Option<i32> {
    let index = find_in_array(arr, target)?;
    return Some(index * 2);
}

it("should propagate None with ? on Option") {
    let arr = [1, 2, 3];
    let result = find_and_double(arr, 5);
    assert(result == None);
}

it("should propagate Some with ? on Option") {
    let arr = [1, 2, 3];
    let result = find_and_double(arr, 2);  // index 1
    assert(result == Some(2));
}

// ============================================================================
// NESTED ERROR PROPAGATION
// ============================================================================

fn level_one(x: i32): Result<i32, string> {
    if (x < 0) { return Err("negative input"); }
    return Ok(x * 2);
}

fn level_two(x: i32): Result<i32, string> {
    let y = level_one(x)?;
    if (y > 100) { return Err("too large"); }
    return Ok(y + 10);
}

fn level_three(x: i32): Result<i32, string> {
    let y = level_two(x)?;
    return Ok(y * 3);
}

it("should propagate error from deep call") {
    let result = level_three(-5);
    assert(result == Err("negative input"));
}

it("should propagate error from middle call") {
    let result = level_three(60);  // 60*2=120 > 100
    assert(result == Err("too large"));
}

it("should succeed through all levels") {
    let result = level_three(10);  // 10*2=20, 20+10=30, 30*3=90
    assert(result == Ok(90));
}

// ============================================================================
// ? OPERATOR IN DIFFERENT CONTEXTS
// ============================================================================

it("should use ? in conditional") {
    fn conditional_try(flag: bool, x: i32): Result<i32, string> {
        if (flag) {
            let v = divide(x, 2)?;
            return Ok(v);
        }
        return Ok(x);
    }
    assert(conditional_try(true, 10) == Ok(5));
    assert(conditional_try(false, 10) == Ok(10));
    assert(conditional_try(true, 0) == Ok(0));
}

it("should use ? in loop") {
    fn sum_divisions(n: i32): Result<i32, string> {
        let mut sum = 0;
        for (i in 1..n+1) {
            let v = divide(100, i)?;
            sum = sum + v;
        }
        return Ok(sum);
    }
    let result = sum_divisions(4);  // 100/1 + 100/2 + 100/3 + 100/4 = 100+50+33+25 = 208
    assert(result == Ok(208));
}

// ============================================================================
// COMBINING ELSE AND ? OPERATOR
// ============================================================================

it("should use else as fallback after ? propagation") {
    fn try_divide(a: i32, b: i32): Result<i32, string> {
        return divide(a, b);
    }

    fn compute_with_fallback(): i32 {
        let result = try_divide(10, 2) else 0;
        return result;
    }

    assert(compute_with_fallback() == 5);
}

it("should use default when ? would fail") {
    fn safe_compute(a: i32, b: i32): i32 {
        return divide(a, b) else -1;
    }

    assert(safe_compute(10, 2) == 5);
    assert(safe_compute(10, 0) == -1);
}

// ============================================================================
// ERROR TRANSFORMATION
// ============================================================================

fn transform_error(x: i32): Result<i32, i32> {
    if (x < 0) {
        return Err(-x);  // Return absolute value as error code
    }
    return Ok(x);
}

it("should transform error type") {
    let result = transform_error(-42);
    assert(result == Err(42));
}

fn map_error_type(x: i32): Result<i32, string> {
    let val = transform_error(x);
    match (val) {
        Ok(v) => return Ok(v),
        Err(code) => return Err("Error code: " + to_string(code)),
    }
}

it("should map error to different type") {
    let result = map_error_type(-10);
    assert(result == Err("Error code: 10"));
}

// ============================================================================
// RESULT METHODS
// ============================================================================

it("should check is_ok") {
    let ok = Ok(42);
    let err = Err("error");
    assert(ok.is_ok() == true);
    assert(err.is_ok() == false);
}

it("should check is_err") {
    let ok = Ok(42);
    let err = Err("error");
    assert(ok.is_err() == false);
    assert(err.is_err() == true);
}

it("should unwrap_or with Ok") {
    let result = Ok(42);
    assert(result.unwrap_or(0) == 42);
}

it("should unwrap_or with Err") {
    let result = Err("error");
    assert(result.unwrap_or(0) == 0);
}

it("should map Ok value") {
    let result = Ok(10);
    let mapped = result.map(|x| x * 2);
    assert(mapped == Ok(20));
}

it("should not map Err value") {
    let result: Result<i32, string> = Err("error");
    let mapped = result.map(|x| x * 2);
    assert(mapped == Err("error"));
}

it("should map_err on Err") {
    let result: Result<i32, i32> = Err(404);
    let mapped = result.map_err(|e| "Error: " + to_string(e));
    assert(mapped == Err("Error: 404"));
}

it("should not map_err on Ok") {
    let result: Result<i32, i32> = Ok(42);
    let mapped = result.map_err(|e| "Error: " + to_string(e));
    assert(mapped == Ok(42));
}

// ============================================================================
// OPTION METHODS
// ============================================================================

it("should check is_some") {
    assert(Some(42).is_some() == true);
    assert(None.is_some() == false);
}

it("should check is_none") {
    assert(Some(42).is_none() == false);
    assert(None.is_none() == true);
}

it("should unwrap_or Some") {
    assert(Some(42).unwrap_or(0) == 42);
}

it("should unwrap_or None") {
    let opt: Option<i32> = None;
    assert(opt.unwrap_or(100) == 100);
}

it("should map Some value") {
    let opt = Some(10);
    let mapped = opt.map(|x| x * 3);
    assert(mapped == Some(30));
}

it("should not map None") {
    let opt: Option<i32> = None;
    let mapped = opt.map(|x| x * 3);
    assert(mapped == None);
}

// ============================================================================
// AND_THEN (FLATMAP) FOR RESULTS
// ============================================================================

fn validate_positive(x: i32): Result<i32, string> {
    if (x > 0) { return Ok(x); }
    return Err("not positive");
}

fn validate_even(x: i32): Result<i32, string> {
    if (x % 2 == 0) { return Ok(x); }
    return Err("not even");
}

it("should chain with and_then both succeed") {
    let result = validate_positive(10).and_then(validate_even);
    assert(result == Ok(10));
}

it("should chain with and_then first fails") {
    let result = validate_positive(-5).and_then(validate_even);
    assert(result == Err("not positive"));
}

it("should chain with and_then second fails") {
    let result = validate_positive(7).and_then(validate_even);
    assert(result == Err("not even"));
}

// ============================================================================
// OR_ELSE FOR RESULTS
// ============================================================================

fn fallback_value(): Result<i32, string> {
    return Ok(0);
}

it("should use or_else on Err") {
    let result: Result<i32, string> = Err("error");
    let recovered = result.or_else(fallback_value);
    assert(recovered == Ok(0));
}

it("should not use or_else on Ok") {
    let result = Ok(42);
    let recovered = result.or_else(fallback_value);
    assert(recovered == Ok(42));
}

// ============================================================================
// RESULT IN STRUCT
// ============================================================================

struct ApiResponse {
    data: Result<string, i32>
}

it("should store Result in struct") {
    let success = ApiResponse { data: Ok("success") };
    let failure = ApiResponse { data: Err(404) };

    assert(success.data == Ok("success"));
    assert(failure.data == Err(404));
}

it("should access Result from struct") {
    let response = ApiResponse { data: Ok("hello") };
    let value = response.data else "default";
    assert(value == "hello");
}

// ============================================================================
// RESULT IN ARRAY
// ============================================================================

it("should store Results in array") {
    let results = [Ok(1), Ok(2), Err("failed"), Ok(4)];
    let mut sum = 0;
    for (r in results) {
        sum = sum + (r else 0);
    }
    assert(sum == 7);
}

it("should filter Ok values from array") {
    let results = [Ok(1), Err("a"), Ok(2), Err("b"), Ok(3)];
    let mut oks: [i32] = [];
    for (r in results) {
        if (r.is_ok()) {
            oks.push(r else 0);
        }
    }
    assert(oks.len() == 3);
    assert(oks[0] == 1);
    assert(oks[1] == 2);
    assert(oks[2] == 3);
}

// ============================================================================
// EARLY RETURN PATTERNS
// ============================================================================

fn early_return_on_error(values: [i32]): Result<i32, string> {
    if (values.len() == 0) {
        return Err("empty array");
    }

    let first = values[0];
    if (first < 0) {
        return Err("negative first value");
    }

    let mut sum = 0;
    for (v in values) {
        sum = sum + v;
    }

    return Ok(sum);
}

it("should early return on empty") {
    let result = early_return_on_error([]);
    assert(result == Err("empty array"));
}

it("should early return on negative") {
    let result = early_return_on_error([-1, 2, 3]);
    assert(result == Err("negative first value"));
}

it("should succeed after all checks") {
    let result = early_return_on_error([1, 2, 3]);
    assert(result == Ok(6));
}
