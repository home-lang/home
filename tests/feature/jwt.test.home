// JWT (JSON Web Token) Test Suite

// ============================================================================
// JWT CREATION
// ============================================================================

it("should create JWT with HS256") {
    let token = jwt::sign({
        sub: "1234567890",
        name: "John Doe",
        iat: 1516239022,
    }, secret: "your-256-bit-secret");

    assert(token.split(".").len() == 3);
}

it("should create JWT with custom algorithm") {
    let token = jwt::sign({
        sub: "user123",
    }, secret: "secret", algorithm: jwt::Algorithm::HS384);

    let header = jwt::decode_header(token);
    assert(header["alg"] == "HS384");
}

it("should create JWT with RS256") {
    let private_key = "-----BEGIN RSA PRIVATE KEY-----\n...";
    let token = jwt::sign({
        sub: "user123",
    }, key: private_key, algorithm: jwt::Algorithm::RS256);

    assert(token.len() > 0);
}

// ============================================================================
// JWT VERIFICATION
// ============================================================================

it("should verify valid JWT") {
    let token = jwt::sign({ sub: "123" }, secret: "secret");
    let payload = jwt::verify(token, secret: "secret");
    assert(payload["sub"] == "123");
}

it("should reject invalid signature") {
    let token = jwt::sign({ sub: "123" }, secret: "secret1");
    let result = jwt::verify_safe(token, secret: "secret2");
    assert(result.is_err() == true);
}

it("should reject tampered token") {
    let token = jwt::sign({ sub: "123" }, secret: "secret");
    // Tamper with payload
    let parts = token.split(".");
    let tampered = parts[0] + "." + "invalid" + "." + parts[2];
    let result = jwt::verify_safe(tampered, secret: "secret");
    assert(result.is_err() == true);
}

// ============================================================================
// JWT CLAIMS
// ============================================================================

it("should include standard claims") {
    let token = jwt::sign({
        sub: "user123",
        iss: "auth-server",
        aud: "api-server",
        exp: time::now() + 3600,
        nbf: time::now(),
        iat: time::now(),
        jti: uuid::v4(),
    }, secret: "secret");

    let payload = jwt::verify(token, secret: "secret");
    assert(payload["sub"] == "user123");
    assert(payload["iss"] == "auth-server");
}

it("should validate expiration") {
    let token = jwt::sign({
        sub: "123",
        exp: time::now() - 3600,  // Expired
    }, secret: "secret");

    let result = jwt::verify_safe(token, secret: "secret");
    assert(result.is_err() == true);
    assert(result.err().code == jwt::Error::TokenExpired);
}

it("should validate not before") {
    let token = jwt::sign({
        sub: "123",
        nbf: time::now() + 3600,  // Not valid yet
    }, secret: "secret");

    let result = jwt::verify_safe(token, secret: "secret");
    assert(result.is_err() == true);
    assert(result.err().code == jwt::Error::TokenNotYetValid);
}

it("should validate issuer") {
    let token = jwt::sign({
        sub: "123",
        iss: "wrong-issuer",
    }, secret: "secret");

    let result = jwt::verify_safe(token, secret: "secret", issuer: "expected-issuer");
    assert(result.is_err() == true);
}

it("should validate audience") {
    let token = jwt::sign({
        sub: "123",
        aud: "api-server",
    }, secret: "secret");

    let payload = jwt::verify(token, secret: "secret", audience: "api-server");
    assert(payload["sub"] == "123");
}

// ============================================================================
// JWT DECODING
// ============================================================================

it("should decode header") {
    let token = jwt::sign({ sub: "123" }, secret: "secret");
    let header = jwt::decode_header(token);
    assert(header["typ"] == "JWT");
    assert(header["alg"] == "HS256");
}

it("should decode payload without verification") {
    let token = jwt::sign({ sub: "123", name: "John" }, secret: "secret");
    let payload = jwt::decode(token);  // No verification
    assert(payload["sub"] == "123");
    assert(payload["name"] == "John");
}

// ============================================================================
// JWT REFRESH
// ============================================================================

it("should refresh token") {
    let original = jwt::sign({
        sub: "123",
        exp: time::now() + 60,
    }, secret: "secret");

    let refreshed = jwt::refresh(original, secret: "secret", extend_by: 3600);
    let payload = jwt::verify(refreshed, secret: "secret");
    assert(payload["exp"] > time::now() + 3500);
}

// ============================================================================
// ALGORITHMS
// ============================================================================

it("should support HS256") {
    let token = jwt::sign({ sub: "123" }, secret: "secret", algorithm: jwt::Algorithm::HS256);
    let header = jwt::decode_header(token);
    assert(header["alg"] == "HS256");
}

it("should support HS384") {
    let token = jwt::sign({ sub: "123" }, secret: "secret", algorithm: jwt::Algorithm::HS384);
    let header = jwt::decode_header(token);
    assert(header["alg"] == "HS384");
}

it("should support HS512") {
    let token = jwt::sign({ sub: "123" }, secret: "secret", algorithm: jwt::Algorithm::HS512);
    let header = jwt::decode_header(token);
    assert(header["alg"] == "HS512");
}

// ============================================================================
// KEY PAIRS
// ============================================================================

it("should generate RSA key pair") {
    let (public_key, private_key) = jwt::generate_rsa_keys(2048);
    assert(public_key.starts_with("-----BEGIN"));
    assert(private_key.starts_with("-----BEGIN"));
}

it("should sign and verify with RSA") {
    let (public_key, private_key) = jwt::generate_rsa_keys(2048);

    let token = jwt::sign({
        sub: "123",
    }, key: private_key, algorithm: jwt::Algorithm::RS256);

    let payload = jwt::verify(token, key: public_key, algorithm: jwt::Algorithm::RS256);
    assert(payload["sub"] == "123");
}

it("should generate EC key pair") {
    let (public_key, private_key) = jwt::generate_ec_keys(jwt::Curve::P256);
    assert(public_key.len() > 0);
    assert(private_key.len() > 0);
}

// ============================================================================
// JWK (JSON Web Key)
// ============================================================================

it("should convert to JWK") {
    let (public_key, _) = jwt::generate_rsa_keys(2048);
    let jwk = jwt::to_jwk(public_key);
    assert(jwk["kty"] == "RSA");
    assert(jwk["n"] != null);
    assert(jwk["e"] != null);
}

it("should convert from JWK") {
    let jwk = {
        kty: "RSA",
        n: "0vx7agoebGcQSuu...",
        e: "AQAB",
    };
    let key = jwt::from_jwk(jwk);
    assert(key.len() > 0);
}

it("should fetch JWKS") {
    // Mock JWKS endpoint
    let jwks = jwt::fetch_jwks("https://example.com/.well-known/jwks.json");
    assert(jwks["keys"].len() >= 0);
}

// ============================================================================
// CUSTOM HEADERS
// ============================================================================

it("should add custom header") {
    let token = jwt::sign({
        sub: "123",
    }, secret: "secret", headers: { kid: "key-id-1" });

    let header = jwt::decode_header(token);
    assert(header["kid"] == "key-id-1");
}

// ============================================================================
// TOKEN VALIDATION OPTIONS
// ============================================================================

it("should allow clock skew") {
    let token = jwt::sign({
        sub: "123",
        exp: time::now() - 30,  // Expired 30 seconds ago
    }, secret: "secret");

    // Allow 60 seconds of clock skew
    let payload = jwt::verify(token, secret: "secret", clock_tolerance: 60);
    assert(payload["sub"] == "123");
}

it("should validate specific claims") {
    let token = jwt::sign({
        sub: "123",
        role: "admin",
    }, secret: "secret");

    let payload = jwt::verify(token, secret: "secret", required_claims: ["sub", "role"]);
    assert(payload["role"] == "admin");
}

// ============================================================================
// ERROR HANDLING
// ============================================================================

it("should handle malformed token") {
    let result = jwt::verify_safe("not.a.valid.token", secret: "secret");
    assert(result.is_err() == true);
    assert(result.err().code == jwt::Error::MalformedToken);
}

it("should handle missing algorithm") {
    let result = jwt::verify_safe("eyJhbGciOiJub25lIn0.eyJzdWIiOiIxMjMifQ.", secret: "secret");
    assert(result.is_err() == true);
}

// ============================================================================
// BLACKLISTING
// ============================================================================

it("should check token blacklist") {
    let token = jwt::sign({ sub: "123", jti: "token-id-1" }, secret: "secret");

    jwt::blacklist.add("token-id-1");

    let result = jwt::verify_safe(token, secret: "secret", check_blacklist: true);
    assert(result.is_err() == true);
}

// ============================================================================
// TOKEN INTROSPECTION
// ============================================================================

it("should introspect token") {
    let token = jwt::sign({
        sub: "123",
        exp: time::now() + 3600,
    }, secret: "secret");

    let info = jwt::introspect(token);
    assert(info.is_expired == false);
    assert(info.expires_in > 3500);
    assert(info.subject == "123");
}

