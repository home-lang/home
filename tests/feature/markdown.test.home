// Markdown Parsing and Rendering Test Suite

// ============================================================================
// HEADINGS
// ============================================================================

it("should parse h1 with correct HTML output") {
    let html = markdown::to_html("# Hello World")
    assert(html.contains("<h1>"))
    assert(html.contains("Hello World"))
    assert(html.contains("</h1>"))
}

it("should parse h2 with correct HTML output") {
    let html = markdown::to_html("## Section Title")
    assert(html.contains("<h2>Section Title</h2>"))
}

it("should parse h3") {
    let html = markdown::to_html("### Subsection")
    assert(html.contains("<h3>"))
    assert(html.contains("Subsection"))
}

it("should parse h4") {
    let html = markdown::to_html("#### Deep Section")
    assert(html.contains("<h4>"))
}

it("should parse h5") {
    let html = markdown::to_html("##### Very Deep")
    assert(html.contains("<h5>"))
}

it("should parse h6") {
    let html = markdown::to_html("###### Deepest")
    assert(html.contains("<h6>"))
}

it("should not parse h7 as heading") {
    let html = markdown::to_html("####### Too Many")
    // Should not be a heading, just text with hashes
    assert(html.contains("#"))
}

// ============================================================================
// EMPHASIS - BOLD
// ============================================================================

it("should parse bold text with double asterisks") {
    let html = markdown::to_html("This is **bold** text")
    assert(html.contains("<strong>bold</strong>"))
}

it("should parse multiple bold sections") {
    let html = markdown::to_html("**one** and **two**")
    assert(html.contains("<strong>one</strong>"))
    assert(html.contains("<strong>two</strong>"))
}

it("should parse bold at start of line") {
    let html = markdown::to_html("**Start** of line")
    assert(html.contains("<strong>Start</strong>"))
}

it("should parse bold at end of line") {
    let html = markdown::to_html("End of **line**")
    assert(html.contains("<strong>line</strong>"))
}

// ============================================================================
// EMPHASIS - ITALIC
// ============================================================================

it("should parse italic text with single asterisk") {
    let html = markdown::to_html("This is *italic* text")
    assert(html.contains("<em>italic</em>"))
}

it("should parse multiple italic sections") {
    let html = markdown::to_html("*one* and *two*")
    assert(html.contains("<em>one</em>"))
    assert(html.contains("<em>two</em>"))
}

// ============================================================================
// COMBINED EMPHASIS
// ============================================================================

it("should parse bold and italic in same line") {
    let html = markdown::to_html("**bold** and *italic*")
    assert(html.contains("<strong>bold</strong>"))
    assert(html.contains("<em>italic</em>"))
}

// ============================================================================
// PARAGRAPHS
// ============================================================================

it("should wrap text in paragraph tags") {
    let html = markdown::to_html("Simple paragraph text")
    assert(html.contains("<p>"))
    assert(html.contains("Simple paragraph text"))
}

it("should create separate paragraphs for double newlines") {
    let html = markdown::to_html("First para\n\nSecond para")
    assert(html.contains("<p>"))
}

// ============================================================================
// CODE
// ============================================================================

it("should parse inline code with backticks") {
    let html = markdown::to_html("Use `code` here")
    assert(html.contains("code"))
}

it("should parse code blocks") {
    let html = markdown::to_html("```\nlet x = 1\n```")
    assert(html.contains("let x = 1") or html.contains("code"))
}

// ============================================================================
// CONTENT PRESERVATION
// ============================================================================

it("should preserve plain text content") {
    let html = markdown::to_html("Plain text without formatting")
    assert(html.contains("Plain text without formatting"))
}

it("should preserve special characters") {
    let html = markdown::to_html("Price: $100 & tax")
    assert(html.contains("Price"))
    assert(html.contains("100"))
}

it("should preserve numbers") {
    let html = markdown::to_html("The answer is 42")
    assert(html.contains("42"))
}

// ============================================================================
// AST PARSING
// ============================================================================

it("should parse markdown to AST") {
    let ast = markdown::parse("# Title\n\nParagraph")
    assert(ast != null)
    assert(ast.type == "document")
}

// ============================================================================
// TABLE OF CONTENTS
// ============================================================================

it("should generate TOC from headings") {
    let md = "# First\n## Second\n### Third"
    let toc = markdown::toc(md)
    assert(toc.len() >= 1)
}

// ============================================================================
// EXTENSIONS
// ============================================================================

it("should support footnotes extension") {
    let md = "Text with reference[^1]\n\n[^1]: Footnote content"
    let html = markdown::to_html_with_footnotes(md)
    assert(html.contains("Text"))
}

it("should support autolink extension") {
    let html = markdown::to_html_with_autolink("Visit https://example.com today")
    assert(html.contains("Visit"))
}

// ============================================================================
// SANITIZATION
// ============================================================================

it("should sanitize dangerous HTML in markdown") {
    let md = "Safe text <script>evil()</script>"
    let html = markdown::to_html_sanitized(md)
    assert(html.contains("Safe text"))
}

// ============================================================================
// FRONT MATTER
// ============================================================================

it("should parse YAML front matter") {
    let md = "---\ntitle: Test\n---\n# Content"
    let result = markdown::parse_with_front_matter(md)
    assert(result != null)
}

// ============================================================================
// CUSTOM RENDERER
// ============================================================================

it("should support custom renderer") {
    let md = "# Custom"
    let html = markdown::to_html_with_renderer(md, null)
    assert(html.contains("Custom"))
}

// ============================================================================
// SYNTAX HIGHLIGHTING
// ============================================================================

it("should highlight code syntax") {
    let md = "```python\ndef hello():\n    print('hi')\n```"
    let html = markdown::to_html_highlighted(md)
    assert(html.contains("hello") or html.contains("def"))
}

// ============================================================================
// EDGE CASES
// ============================================================================

it("should handle empty input") {
    let html = markdown::to_html("")
    assert(html != null)
}

it("should handle whitespace only") {
    let html = markdown::to_html("   \n\n   ")
    assert(html != null)
}

it("should handle very long lines") {
    let long_text = "word word word word word word word word word word word word word word word word word word word word"
    let html = markdown::to_html(long_text)
    assert(html.contains("word"))
}

it("should not crash on unclosed formatting") {
    let html = markdown::to_html("**unclosed bold")
    assert(html.contains("unclosed"))
}

it("should not crash on nested formatting") {
    let html = markdown::to_html("**bold *and italic* text**")
    assert(html.contains("bold"))
}

