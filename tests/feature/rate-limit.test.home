// Rate Limiting Test Suite

// ============================================================================
// BASIC RATE LIMITER
// ============================================================================

it("should create rate limiter") {
    // Create limiter with 100 requests per 60 seconds
    let limiter = ratelimit::Limiter::new(100, 60);
    assert(limiter != null);
}

it("should allow requests under limit") {
    let limiter = ratelimit::Limiter::new(10, 60);

    for i in 0..10 {
        let result = limiter.check("client1");
        assert(result.allowed == true);
    }
}

it("should block requests over limit") {
    let limiter = ratelimit::Limiter::new(5, 60);

    for i in 0..5 {
        limiter.check("client1");
    }

    let result = limiter.check("client1");
    assert(result.allowed == false);
}

it("should track remaining requests") {
    let limiter = ratelimit::Limiter::new(10, 60);

    limiter.check("client1");
    limiter.check("client1");
    limiter.check("client1");

    let status = limiter.status("client1");
    assert(status.remaining == 7);
}

it("should provide reset time") {
    let limiter = ratelimit::Limiter::new(10, 60);
    limiter.check("client1");

    let status = limiter.status("client1");
    assert(status.reset_at > time::now());
}

// ============================================================================
// SLIDING WINDOW
// ============================================================================

it("should use sliding window") {
    let limiter = ratelimit::SlidingWindow::new(100, 60);

    // More accurate than fixed windows
    for i in 0..50 {
        limiter.check("client1");
    }

    // Wait for window to slide
    // Requests should gradually become available
}

it("should track request history") {
    let limiter = ratelimit::SlidingWindow::new(10, 60);

    limiter.check("client1");
    limiter.check("client1");

    let history = limiter.history("client1");
    assert(history.len() == 2);
}

// ============================================================================
// TOKEN BUCKET
// ============================================================================

it("should create token bucket") {
    // capacity: 100, refill_rate: 10 tokens per second
    let bucket = ratelimit::TokenBucket::new(100, 10);
    assert(bucket != null);
}

it("should consume tokens") {
    let bucket = ratelimit::TokenBucket::new(100, 10);

    let result = bucket.consume(1);
    assert(result.allowed == true);
    assert(bucket.tokens() == 99);
}

it("should consume multiple tokens") {
    let bucket = ratelimit::TokenBucket::new(100, 10);

    let result = bucket.consume(50);
    assert(result.allowed == true);
    assert(bucket.tokens() == 50);
}

it("should reject when insufficient tokens") {
    let bucket = ratelimit::TokenBucket::new(10, 1);

    bucket.consume(10);  // Empty the bucket

    let result = bucket.consume(1);
    assert(result.allowed == false);
}

it("should refill tokens over time") {
    let bucket = ratelimit::TokenBucket::new(10, 10);

    bucket.consume(10);  // Empty
    // After 1 second, should have ~10 tokens
    time::sleep(1000);

    let tokens = bucket.tokens();
    assert(tokens >= 9);  // Allow some timing variance
}

// ============================================================================
// LEAKY BUCKET
// ============================================================================

it("should create leaky bucket") {
    // capacity: 100, leak_rate: 10 per second
    let bucket = ratelimit::LeakyBucket::new(100, 10);
    assert(bucket != null);
}

it("should add to leaky bucket") {
    let bucket = ratelimit::LeakyBucket::new(100, 10);

    let result = bucket.add(1);
    assert(result.allowed == true);
}

it("should overflow leaky bucket") {
    let bucket = ratelimit::LeakyBucket::new(10, 1);

    // Fill up the bucket
    for i in 0..10 {
        bucket.add(1);
    }

    let result = bucket.add(1);
    assert(result.allowed == false);
}

it("should leak over time") {
    let bucket = ratelimit::LeakyBucket::new(10, 10);

    bucket.add(10);  // Fill up
    time::sleep(1000);  // Wait 1 second

    let result = bucket.add(5);
    assert(result.allowed == true);
}

// ============================================================================
// FIXED WINDOW
// ============================================================================

it("should use fixed window") {
    let limiter = ratelimit::FixedWindow::new(100, 60);

    for i in 0..100 {
        assert(limiter.check("client").allowed == true);
    }

    assert(limiter.check("client").allowed == false);
}

it("should reset at window boundary") {
    let limiter = ratelimit::FixedWindow::new(10, 1);  // 1 second window

    for i in 0..10 {
        limiter.check("client");
    }

    time::sleep(1100);  // Wait for window reset

    assert(limiter.check("client").allowed == true);
}

// ============================================================================
// CONCURRENT LIMITER
// ============================================================================

it("should limit concurrent requests") {
    let limiter = ratelimit::Concurrent::new(5);

    let permits = [];
    for i in 0..5 {
        let permit = limiter.acquire("client");
        assert(permit != null);
        permits.push(permit);
    }

    // 6th should fail
    let result = limiter.try_acquire("client");
    assert(result == null);
}

it("should release on permit drop") {
    let limiter = ratelimit::Concurrent::new(1);

    {
        let permit = limiter.acquire("client");
        // permit dropped at end of scope
    }

    // Should be able to acquire again
    let permit = limiter.acquire("client");
    assert(permit != null);
}

// ============================================================================
// PER-KEY LIMITS
// ============================================================================

it("should limit per key") {
    let limiter = ratelimit::Limiter::new(10, 60);

    for i in 0..10 {
        limiter.check("client1");
    }

    // client1 is at limit
    assert(limiter.check("client1").allowed == false);

    // client2 should still work
    assert(limiter.check("client2").allowed == true);
}

it("should support composite keys") {
    let limiter = ratelimit::Limiter::new(10, 60);

    let key = ratelimit::key("user:123", "endpoint:/api/data");
    limiter.check(key);
}

// ============================================================================
// DISTRIBUTED RATE LIMITING
// ============================================================================

it("should use Redis backend") {
    let backend = ratelimit::redis("redis://localhost:6379");
    // Limiter uses backend for distributed storage
    let limiter = ratelimit::Limiter::with_backend(100, 60, backend);
    assert(limiter != null);
}

it("should sync across instances") {
    let backend = ratelimit::redis("redis://localhost:6379");

    let limiter1 = ratelimit::Limiter::with_backend(10, 60, backend);
    let limiter2 = ratelimit::Limiter::with_backend(10, 60, backend);

    for i in 0..5 {
        limiter1.check("shared_client");
    }

    let status = limiter2.status("shared_client");
    assert(status.remaining == 5);
}

// ============================================================================
// RATE LIMIT HEADERS
// ============================================================================

it("should generate rate limit headers") {
    let limiter = ratelimit::Limiter::new(100, 60);
    limiter.check("client");

    let headers = limiter.headers("client");
    assert(headers["X-RateLimit-Limit"] == "100");
    assert(headers["X-RateLimit-Remaining"] == "99");
    assert(headers["X-RateLimit-Reset"] != null);
}

it("should include Retry-After when limited") {
    let limiter = ratelimit::Limiter::new(1, 60);
    limiter.check("client");
    limiter.check("client");  // Over limit

    let headers = limiter.headers("client");
    assert(headers["Retry-After"] != null);
}

// ============================================================================
// MIDDLEWARE
// ============================================================================

it("should create rate limit middleware") {
    let limiter = ratelimit::Limiter::new(100, 60);
    let middleware = ratelimit::middleware(limiter);
    assert(middleware != null);
}

it("should use IP-based key extractor") {
    let limiter = ratelimit::Limiter::new(100, 60);
    let key_extractor = ratelimit::by_ip();
    let middleware = ratelimit::middleware_with_key(limiter, key_extractor);
    assert(middleware != null);
}

it("should use custom key extractor") {
    let limiter = ratelimit::Limiter::new(1000, 60);
    // Use user ID as the rate limit key
    let middleware = ratelimit::middleware_with_key(limiter, ratelimit::by_user());
    assert(middleware != null);
}

// ============================================================================
// TIERED LIMITS
// ============================================================================

it("should support tiered limits") {
    // Create tiered limiter with different limits per tier
    let limiter = ratelimit::Tiered::new();
    limiter.add_tier("free", 100, 3600);
    limiter.add_tier("basic", 1000, 3600);
    limiter.add_tier("premium", 10000, 3600);

    let result = limiter.check_with_tier("user1", "basic");
    assert(result.limit == 1000);
}

it("should upgrade tier dynamically") {
    let limiter = ratelimit::Tiered::new();
    limiter.add_tier("free", 100, 3600);
    limiter.add_tier("premium", 10000, 3600);

    limiter.set_tier("user1", "premium");
    let status = limiter.status("user1");
    assert(status.limit == 10000);
}

// ============================================================================
// COST-BASED LIMITING
// ============================================================================

it("should support request costs") {
    let limiter = ratelimit::Limiter::new(1000, 60);

    // Different endpoints have different costs
    limiter.check_with_cost("client", 1);    // Simple read
    limiter.check_with_cost("client", 10);   // Complex query
    limiter.check_with_cost("client", 100);  // Expensive operation

    let status = limiter.status("client");
    assert(status.remaining == 889);  // 1000 - 111
}

// ============================================================================
// BURST HANDLING
// ============================================================================

it("should allow bursts") {
    // capacity: 100 (max burst), refill_rate: 10 (sustained rate)
    let limiter = ratelimit::TokenBucket::new(100, 10);

    // Can burst up to 100
    let result = limiter.consume(50);
    assert(result.allowed == true);
}

it("should smooth traffic with leaky bucket") {
    // capacity: 10, leak_rate: 1 per second
    let bucket = ratelimit::LeakyBucket::new(10, 1);

    // Requests are processed at steady rate regardless of bursts
    assert(bucket != null);
}

// ============================================================================
// ANALYTICS
// ============================================================================

it("should track rate limit metrics") {
    let limiter = ratelimit::Limiter::new(100, 60);

    for i in 0..150 {
        limiter.check("client");
    }

    let metrics = limiter.metrics("client");
    assert(metrics.allowed_count == 100);
    assert(metrics.blocked_count == 50);
}

it("should get global metrics") {
    let limiter = ratelimit::Limiter::new(100, 60);

    let metrics = limiter.global_metrics();
    assert(metrics.total_requests >= 0);
    assert(metrics.blocked_percentage >= 0);
}

// ============================================================================
// GRACEFUL DEGRADATION
// ============================================================================

it("should warn before limiting") {
    let limiter = ratelimit::Limiter::new(100, 60);

    for i in 0..90 {
        limiter.check("client");
    }

    let status = limiter.status("client");
    assert(status.warning == true);  // At 90% capacity
}

it("should use soft limits") {
    // Limiter with soft limit at 80%
    let limiter = ratelimit::Limiter::with_soft_limit(100, 60, 80);

    // At soft limit: still allowed but warned
    // At hard limit: blocked
    assert(limiter != null);
}
