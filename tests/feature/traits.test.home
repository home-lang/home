// Traits Test Suite
// Tests trait definitions, implementations, and trait bounds

// ============================================================================
// BASIC TRAIT DEFINITION
// ============================================================================

trait Printable {
    fn to_string(self): string;
}

trait Comparable {
    fn compare(self, other: Self): i32;
}

trait Identifiable {
    fn id(self): i32;
}

// ============================================================================
// TRAIT IMPLEMENTATION FOR STRUCTS
// ============================================================================

struct Point {
    x: i32,
    y: i32
}

impl Printable for Point {
    fn to_string(self): string {
        return "Point(" + to_string(self.x) + ", " + to_string(self.y) + ")";
    }
}

impl Comparable for Point {
    fn compare(self, other: Point): i32 {
        let self_sum = self.x + self.y;
        let other_sum = other.x + other.y;
        if (self_sum < other_sum) { return -1; }
        if (self_sum > other_sum) { return 1; }
        return 0;
    }
}

it("should implement Printable trait") {
    let p = Point { x: 10, y: 20 };
    let s = p.to_string();
    assert(s.contains("10"));
    assert(s.contains("20"));
}

it("should implement Comparable trait") {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    assert(p1.compare(p2) == -1);
    assert(p2.compare(p1) == 1);
}

it("should compare equal points") {
    let p1 = Point { x: 5, y: 5 };
    let p2 = Point { x: 5, y: 5 };
    assert(p1.compare(p2) == 0);
}

// ============================================================================
// MULTIPLE TRAIT IMPLEMENTATIONS
// ============================================================================

struct Person {
    name: string,
    age: i32
}

impl Printable for Person {
    fn to_string(self): string {
        return self.name + " (age " + to_string(self.age) + ")";
    }
}

impl Identifiable for Person {
    fn id(self): i32 {
        return self.age * 1000;
    }
}

it("should implement multiple traits") {
    let p = Person { name: "Alice", age: 30 };
    assert(p.to_string().contains("Alice"));
    assert(p.id() == 30000);
}

it("should use trait methods on different instances") {
    let p1 = Person { name: "Bob", age: 25 };
    let p2 = Person { name: "Charlie", age: 35 };
    assert(p1.id() != p2.id());
    assert(p1.to_string() != p2.to_string());
}

// ============================================================================
// TRAIT WITH DEFAULT IMPLEMENTATION
// ============================================================================

trait Describable {
    fn describe(self): string {
        return "An object";
    }
    fn detailed(self): string;
}

struct Item {
    name: string,
    value: i32
}

impl Describable for Item {
    fn detailed(self): string {
        return self.name + ": " + to_string(self.value);
    }
}

it("should use default trait implementation") {
    let item = Item { name: "Sword", value: 100 };
    assert(item.describe() == "An object");
}

it("should use custom trait implementation") {
    let item = Item { name: "Shield", value: 50 };
    assert(item.detailed() == "Shield: 50");
}

// ============================================================================
// TRAIT BOUNDS ON GENERICS
// ============================================================================

fn print_it<T: Printable>(item: T): string {
    return item.to_string();
}

it("should use trait bound on generic function") {
    let p = Point { x: 5, y: 10 };
    let result = print_it(p);
    assert(result.contains("5"));
    assert(result.contains("10"));
}

fn compare_items<T: Comparable>(a: T, b: T): i32 {
    return a.compare(b);
}

it("should use Comparable trait bound") {
    let p1 = Point { x: 1, y: 1 };
    let p2 = Point { x: 2, y: 2 };
    assert(compare_items(p1, p2) == -1);
}

// ============================================================================
// TRAIT WITH ASSOCIATED TYPE
// ============================================================================

trait Container {
    type Item;
    fn get(self): Self.Item;
    fn set(mut self, item: Self.Item);
}

struct IntBox {
    value: i32
}

impl Container for IntBox {
    type Item = i32;

    fn get(self): i32 {
        return self.value;
    }

    fn set(mut self, item: i32) {
        self.value = item;
    }
}

it("should implement trait with associated type") {
    let box = IntBox { value: 42 };
    assert(box.get() == 42);
}

it("should set value through trait method") {
    let mut box = IntBox { value: 0 };
    box.set(100);
    assert(box.get() == 100);
}

// ============================================================================
// TRAIT INHERITANCE
// ============================================================================

trait Named {
    fn name(self): string;
}

trait FullyDescribed: Named + Printable {
    fn full_description(self): string {
        return self.name() + ": " + self.to_string();
    }
}

struct Animal {
    species: string,
    age: i32
}

impl Named for Animal {
    fn name(self): string {
        return self.species;
    }
}

impl Printable for Animal {
    fn to_string(self): string {
        return self.species + " (" + to_string(self.age) + " years)";
    }
}

impl FullyDescribed for Animal {}

it("should inherit from multiple traits") {
    let a = Animal { species: "Cat", age: 5 };
    assert(a.name() == "Cat");
    assert(a.to_string().contains("Cat"));
}

it("should use inherited trait method") {
    let a = Animal { species: "Dog", age: 3 };
    let desc = a.full_description();
    assert(desc.contains("Dog"));
}

// ============================================================================
// STATIC TRAIT METHODS
// ============================================================================

trait Creatable {
    fn create(): Self;
    fn create_with_value(val: i32): Self;
}

struct Counter {
    count: i32
}

impl Creatable for Counter {
    fn create(): Counter {
        return Counter { count: 0 };
    }

    fn create_with_value(val: i32): Counter {
        return Counter { count: val };
    }
}

it("should call static trait method") {
    let c = Counter.create();
    assert(c.count == 0);
}

it("should call static trait method with value") {
    let c = Counter.create_with_value(100);
    assert(c.count == 100);
}

// ============================================================================
// TRAIT OBJECTS
// ============================================================================

fn get_description(obj: dyn Printable): string {
    return obj.to_string();
}

it("should use trait object") {
    let p = Point { x: 1, y: 2 };
    let desc = get_description(p);
    assert(desc.contains("1"));
}

it("should use trait object with different types") {
    let point = Point { x: 3, y: 4 };
    let person = Person { name: "Eve", age: 25 };

    let desc1 = get_description(point);
    let desc2 = get_description(person);

    assert(desc1 != desc2);
}

// ============================================================================
// TRAIT WITH MULTIPLE METHODS
// ============================================================================

trait Mathematical {
    fn add(self, other: Self): Self;
    fn subtract(self, other: Self): Self;
    fn multiply(self, scalar: i32): Self;
    fn is_zero(self): bool;
}

struct Vector2D {
    x: i32,
    y: i32
}

impl Mathematical for Vector2D {
    fn add(self, other: Vector2D): Vector2D {
        return Vector2D { x: self.x + other.x, y: self.y + other.y };
    }

    fn subtract(self, other: Vector2D): Vector2D {
        return Vector2D { x: self.x - other.x, y: self.y - other.y };
    }

    fn multiply(self, scalar: i32): Vector2D {
        return Vector2D { x: self.x * scalar, y: self.y * scalar };
    }

    fn is_zero(self): bool {
        return self.x == 0 and self.y == 0;
    }
}

it("should add vectors using trait") {
    let v1 = Vector2D { x: 1, y: 2 };
    let v2 = Vector2D { x: 3, y: 4 };
    let result = v1.add(v2);
    assert(result.x == 4);
    assert(result.y == 6);
}

it("should subtract vectors using trait") {
    let v1 = Vector2D { x: 5, y: 7 };
    let v2 = Vector2D { x: 2, y: 3 };
    let result = v1.subtract(v2);
    assert(result.x == 3);
    assert(result.y == 4);
}

it("should multiply vector by scalar") {
    let v = Vector2D { x: 2, y: 3 };
    let result = v.multiply(3);
    assert(result.x == 6);
    assert(result.y == 9);
}

it("should check if vector is zero") {
    let zero = Vector2D { x: 0, y: 0 };
    let nonzero = Vector2D { x: 1, y: 0 };
    assert(zero.is_zero() == true);
    assert(nonzero.is_zero() == false);
}

// ============================================================================
// TRAIT WITH SELF RETURN
// ============================================================================

trait Chainable {
    fn double(self): Self;
    fn negate(self): Self;
}

struct Number {
    value: i32
}

impl Chainable for Number {
    fn double(self): Number {
        return Number { value: self.value * 2 };
    }

    fn negate(self): Number {
        return Number { value: -self.value };
    }
}

it("should chain trait methods") {
    let n = Number { value: 5 };
    let result = n.double().negate();
    assert(result.value == -10);
}

it("should chain multiple times") {
    let n = Number { value: 2 };
    let result = n.double().double().double();
    assert(result.value == 16);
}

// ============================================================================
// EDGE CASES
// ============================================================================

it("should implement trait for zero values") {
    let p = Point { x: 0, y: 0 };
    let s = p.to_string();
    assert(s.contains("0"));
}

it("should implement trait for negative values") {
    let p = Point { x: -10, y: -20 };
    let s = p.to_string();
    assert(s.contains("-10"));
    assert(s.contains("-20"));
}

it("should compare with same values") {
    let p1 = Point { x: 0, y: 0 };
    let p2 = Point { x: 0, y: 0 };
    assert(p1.compare(p2) == 0);
}

it("should handle trait method on empty string") {
    let p = Person { name: "", age: 0 };
    let s = p.to_string();
    assert(s.contains("0"));
}

