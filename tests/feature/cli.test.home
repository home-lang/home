// CLI Argument Parsing Concepts Test Suite
// Tests CLI parsing patterns using basic Home syntax

// ============================================================================
// BASIC ARGUMENT PARSING
// ============================================================================

it("should parse positional argument") {
    let args = ["myapp", "input.txt"]
    assert(args[1] == "input.txt")
}

it("should parse multiple positional arguments") {
    let args = ["myapp", "input.txt", "output.txt"]
    assert(args[1] == "input.txt")
    assert(args[2] == "output.txt")
}

it("should count positional arguments") {
    let args = ["myapp", "a", "b", "c"]
    let positional_count = args.len() - 1  // Exclude program name
    assert(positional_count == 3)
}

// ============================================================================
// FLAGS DETECTION
// ============================================================================

it("should detect short flag") {
    let args = ["myapp", "-v"]
    let has_v = args.contains("-v")
    assert(has_v == true)
}

it("should detect missing flag") {
    let args = ["myapp", "-v"]
    let has_q = args.contains("-q")
    assert(has_q == false)
}

it("should detect long flag") {
    let args = ["myapp", "--verbose"]
    let has_verbose = args.contains("--verbose")
    assert(has_verbose == true)
}

// ============================================================================
// OPTIONS WITH VALUES
// ============================================================================

it("should find option value by index") {
    let args = ["myapp", "-o", "output.txt"]
    let mut output_value = ""
    for i in 0..args.len() {
        if args[i] == "-o" and i + 1 < args.len() {
            output_value = args[i + 1]
        }
    }
    assert(output_value == "output.txt")
}

it("should parse option with equals sign") {
    let arg = "--output=output.txt"
    let parts = arg.split("=")
    assert(parts[0] == "--output")
    assert(parts[1] == "output.txt")
}

it("should provide default for missing option") {
    let args = ["myapp"]
    let has_output = args.contains("--output")
    let value = if has_output { "found" } else { "default" }
    assert(value == "default")
}

// ============================================================================
// FLAG PATTERNS
// ============================================================================

it("should identify short flag pattern") {
    let arg = "-v"
    let is_short_flag = arg.starts_with("-") and arg.len() == 2
    assert(is_short_flag == true)
}

it("should identify long flag pattern") {
    let arg = "--verbose"
    let is_long_flag = arg.starts_with("--")
    assert(is_long_flag == true)
}

it("should identify positional argument") {
    let arg = "filename.txt"
    let is_positional = arg.starts_with("-") == false
    assert(is_positional == true)
}

// ============================================================================
// ARGUMENT CLASSIFICATION
// ============================================================================

it("should classify arguments") {
    let args = ["myapp", "-v", "--output", "file.txt", "input.txt"]
    let mut flags = []
    let mut options = []
    let mut positionals = []

    for i in 1..args.len() {
        let arg = args[i]
        if arg.starts_with("--") {
            options = options.push(arg)
        } else if arg.starts_with("-") {
            flags = flags.push(arg)
        } else {
            positionals = positionals.push(arg)
        }
    }

    assert(flags.len() == 1)
    assert(options.len() == 1)
    assert(positionals.len() == 2)
}

// ============================================================================
// MULTIPLE VALUES
// ============================================================================

it("should collect repeated options") {
    let args = ["myapp", "-I", "/usr", "-I", "/opt"]
    let mut values = []

    for i in 0..args.len() {
        if args[i] == "-I" and i + 1 < args.len() {
            values = values.push(args[i + 1])
        }
    }

    assert(values.len() == 2)
    assert(values[0] == "/usr")
    assert(values[1] == "/opt")
}

it("should parse comma-separated values") {
    let value = "a,b,c"
    let parts = value.split(",")
    assert(parts.len() == 3)
    assert(parts[0] == "a")
    assert(parts[1] == "b")
    assert(parts[2] == "c")
}

// ============================================================================
// SUBCOMMANDS
// ============================================================================

it("should identify subcommand") {
    let args = ["myapp", "build"]
    let subcommand = args[1]
    assert(subcommand == "build")
}

it("should identify subcommand with flags") {
    let args = ["myapp", "build", "--release"]
    let subcommand = args[1]
    let has_release = args.contains("--release")
    assert(subcommand == "build")
    assert(has_release == true)
}

// ============================================================================
// DOUBLE DASH SEPARATOR
// ============================================================================

it("should find double dash separator") {
    let args = ["myapp", "--verbose", "--", "-v", "--help"]
    let mut separator_index = -1

    for i in 0..args.len() {
        if args[i] == "--" {
            separator_index = i
        }
    }

    assert(separator_index == 2)
}

it("should extract rest after separator") {
    let args = ["myapp", "--", "-v", "--help"]
    let mut rest = []
    let mut found_separator = false

    for arg in args {
        if found_separator {
            rest = rest.push(arg)
        }
        if arg == "--" {
            found_separator = true
        }
    }

    assert(rest.len() == 2)
}

// ============================================================================
// HELP FLAG DETECTION
// ============================================================================

it("should detect help flag short") {
    let args = ["myapp", "-h"]
    let wants_help = args.contains("-h") or args.contains("--help")
    assert(wants_help == true)
}

it("should detect help flag long") {
    let args = ["myapp", "--help"]
    let wants_help = args.contains("-h") or args.contains("--help")
    assert(wants_help == true)
}

// ============================================================================
// VERSION FLAG DETECTION
// ============================================================================

it("should detect version flag") {
    let args = ["myapp", "--version"]
    let wants_version = args.contains("-V") or args.contains("--version")
    assert(wants_version == true)
}

// ============================================================================
// VALIDATION PATTERNS
// ============================================================================

it("should validate required argument present") {
    let args = ["myapp", "input.txt"]
    let has_input = args.len() > 1
    assert(has_input == true)
}

it("should detect missing required argument") {
    let args = ["myapp"]
    let has_input = args.len() > 1
    assert(has_input == false)
}

it("should validate option value is number") {
    let value = "42"
    let mut is_number = true
    let digits = "0123456789"
    for i in 0..value.len() {
        if digits.contains(value.char_at(i)) == false {
            is_number = false
        }
    }
    assert(is_number == true)
}

// ============================================================================
// CHOICE VALIDATION
// ============================================================================

it("should validate value in choices") {
    let value = "info"
    let choices = ["debug", "info", "warn", "error"]
    let is_valid = choices.contains(value)
    assert(is_valid == true)
}

it("should detect invalid choice") {
    let value = "invalid"
    let choices = ["debug", "info", "warn", "error"]
    let is_valid = choices.contains(value)
    assert(is_valid == false)
}

// ============================================================================
// PARSING INTEGER VALUES
// ============================================================================

it("should parse positive integer") {
    let value = "123"
    let mut result = 0
    let digits = "0123456789"
    for i in 0..value.len() {
        let c = value.char_at(i)
        for d in 0..10 {
            if c == digits.char_at(d) {
                result = result * 10 + d
            }
        }
    }
    assert(result == 123)
}

// ============================================================================
// USAGE STRING BUILDING
// ============================================================================

it("should build usage string") {
    let program = "myapp"
    let required_arg = "<input>"
    let optional_flag = "[-v]"
    let usage = program + " " + required_arg + " " + optional_flag
    assert(usage == "myapp <input> [-v]")
}

// ============================================================================
// ALIAS DETECTION
// ============================================================================

it("should match option alias") {
    let arg = "-V"
    let aliases = ["-v", "-V", "--verbose"]
    let is_verbose = aliases.contains(arg)
    assert(is_verbose == true)
}
