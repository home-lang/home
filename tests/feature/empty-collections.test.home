// Empty Collections Edge Cases Test Suite
// Tests behavior of all collection operations with empty inputs

// ============================================================================
// EMPTY ARRAY CREATION
// ============================================================================

it("should create empty array with type annotation") {
    let arr: [i32] = [];
    assert(arr.len() == 0);
}

it("should create empty string array") {
    let arr: [string] = [];
    assert(arr.len() == 0);
}

it("should create empty nested array") {
    let arr: [[i32]] = [];
    assert(arr.len() == 0);
}

// ============================================================================
// EMPTY ARRAY PROPERTIES
// ============================================================================

it("should have zero length") {
    let arr: [i32] = [];
    assert(arr.len() == 0);
}

it("should be empty") {
    let arr: [i32] = [];
    assert(arr.is_empty() == true);
}

it("should not be empty after concat") {
    let arr: [i32] = [];
    let arr2 = arr.concat([1]);
    assert(arr2.is_empty() == false);
}

// ============================================================================
// EMPTY ARRAY ITERATION
// ============================================================================

it("should iterate empty array zero times") {
    let arr: [i32] = [];
    let mut count = 0;
    for (x in arr) {
        count = count + 1;
    }
    assert(count == 0);
}

it("should iterate with enumerate on empty") {
    let arr: [i32] = [];
    let mut count = 0;
    // Use simple iteration instead of tuple destructuring
    let enumerated = arr.enumerate();
    for (pair in enumerated) {
        count = count + 1;
    }
    assert(count == 0);
}

// ============================================================================
// EMPTY ARRAY METHODS
// ============================================================================

it("should map empty array to empty") {
    let arr: [i32] = [];
    let result = arr.map(|x| x * 2);
    assert(result.len() == 0);
}

it("should filter empty array to empty") {
    let arr: [i32] = [];
    let result = arr.filter(|x| x > 0);
    assert(result.len() == 0);
}

it("should reduce empty array to initial") {
    let arr: [i32] = [];
    // reduce takes closure first, then initial value
    let result = arr.reduce(|acc, x| acc + x, 42);
    assert(result == 42);
}

it("should reduce empty array with different initial") {
    let arr: [i32] = [];
    let result = arr.reduce(|acc, x| acc + x, 100);
    assert(result == 100);
}

it("should find nothing in empty array") {
    let arr: [i32] = [];
    let result = arr.find(|x| x == 1);
    // find returns void for empty array (no match)
    assert(typeof(result) == "void");
}

it("should find_index nothing in empty") {
    let arr: [i32] = [];
    let result = arr.find_index(|x| x == 1);
    // find_index returns -1 when not found
    assert(result == -1);
}

it("should every be true for empty") {
    let arr: [i32] = [];
    assert(arr.every(|x| x > 0) == true);
}

it("should some be false for empty") {
    let arr: [i32] = [];
    assert(arr.some(|x| x > 0) == false);
}

it("should contains be false for empty") {
    let arr: [i32] = [];
    assert(arr.contains(1) == false);
}

it("should reverse empty to empty") {
    let arr: [i32] = [];
    let result = arr.reverse();
    assert(result.len() == 0);
}

it("should sort empty to empty") {
    let arr: [i32] = [];
    let result = arr.sort();
    assert(result.len() == 0);
}

it("should first on empty return None") {
    let arr: [i32] = [];
    // first on empty returns void
    assert(typeof(arr.first()) == "void");
}

it("should last on empty return None") {
    let arr: [i32] = [];
    // last on empty returns void
    assert(typeof(arr.last()) == "void");
}

it("should join empty array") {
    let arr: [string] = [];
    assert(arr.join(",") == "");
}

it("should concat two empty arrays") {
    let a: [i32] = [];
    let b: [i32] = [];
    let result = a.concat(b);
    assert(result.len() == 0);
}

it("should concat empty with non-empty") {
    let a: [i32] = [];
    let b = [1, 2, 3];
    let result = a.concat(b);
    assert(result.len() == 3);
}

it("should concat non-empty with empty") {
    let a = [1, 2, 3];
    let b: [i32] = [];
    let result = a.concat(b);
    assert(result.len() == 3);
}

it("should flat_map empty to empty") {
    let arr: [i32] = [];
    let result = arr.flat_map(|x| [x, x]);
    assert(result.len() == 0);
}

it("should flatten empty to empty") {
    let arr: [[i32]] = [];
    let result = arr.flatten();
    assert(result.len() == 0);
}

it("should zip empty arrays") {
    let a: [i32] = [];
    let b: [i32] = [];
    let result = a.zip(b);
    assert(result.len() == 0);
}

it("should zip empty with non-empty") {
    let a: [i32] = [];
    let b = [1, 2, 3];
    let result = a.zip(b);
    assert(result.len() == 0);
}

it("should take from empty") {
    let arr: [i32] = [];
    let result = arr.take(5);
    assert(result.len() == 0);
}

it("should skip from empty") {
    let arr: [i32] = [];
    let result = arr.skip(5);
    assert(result.len() == 0);
}

it("should slice empty array") {
    let arr: [i32] = [];
    let result = arr[0..0];
    assert(result.len() == 0);
}

it("should chunk empty array") {
    let arr: [i32] = [];
    let result = arr.chunk(3);
    assert(result.len() == 0);
}

it("should partition empty array") {
    let arr: [i32] = [];
    let result = arr.partition(|x| x % 2 == 0);
    // partition returns array of two arrays
    assert(result[0].len() == 0);
    assert(result[1].len() == 0);
}

it("should group_by empty array") {
    let arr: [i32] = [];
    let result = arr.group_by(|x| x % 2);
    assert(result.len() == 0);
}

it("should dedup empty array") {
    let arr: [i32] = [];
    let result = arr.dedup();
    assert(result.len() == 0);
}

it("should unique empty array") {
    let arr: [i32] = [];
    let result = arr.unique();
    assert(result.len() == 0);
}

// ============================================================================
// EMPTY STRING
// ============================================================================

it("should have zero length empty string") {
    let s = "";
    assert(s.len() == 0);
}

it("should be empty string") {
    let s = "";
    assert(s.is_empty() == true);
}

it("should split empty string") {
    let s = "";
    let parts = s.split(",");
    assert(parts.len() == 1);
    assert(parts[0] == "");
}

it("should trim empty string") {
    let s = "";
    assert(s.trim() == "");
}

it("should uppercase empty string") {
    let s = "";
    assert(s.to_upper() == "");
}

it("should lowercase empty string") {
    let s = "";
    assert(s.to_lower() == "");
}

it("should reverse empty string") {
    let s = "";
    assert(s.reverse() == "");
}

it("should starts_with on empty") {
    let s = "";
    assert(s.starts_with("") == true);
    assert(s.starts_with("a") == false);
}

it("should ends_with on empty") {
    let s = "";
    assert(s.ends_with("") == true);
    assert(s.ends_with("a") == false);
}

it("should contains on empty") {
    let s = "";
    assert(s.contains("") == true);
    assert(s.contains("a") == false);
}

it("should replace in empty string") {
    let s = "";
    let result = s.replace("a", "b");
    assert(result == "");
}

it("should get empty string length") {
    let s = "";
    // chars() not implemented, just check string length
    assert(s.len() == 0);
}

it("should check empty string is empty") {
    let s = "";
    // bytes() not implemented, just check it's empty
    assert(s.is_empty());
}

// ============================================================================
// EMPTY MAP
// ============================================================================

it("should create empty map") {
    let map = {};
    assert(map.len() == 0);
}

it("should be empty map") {
    let map = {};
    assert(map.is_empty() == true);
}

it("should not contain key in empty map") {
    let map = {};
    assert(map.contains_key("test") == false);
}

it("should get None from empty map") {
    let map = {};
    assert(map.get("test").is_none());
}

it("should keys of empty map") {
    let map = {};
    let keys = map.keys();
    assert(keys.len() == 0);
}

it("should values of empty map") {
    let map = {};
    let values = map.values();
    assert(values.len() == 0);
}

it("should entries of empty map") {
    let map = {};
    let entries = map.entries();
    assert(entries.len() == 0);
}

it("should iterate empty map zero times") {
    let map = {};
    let mut count = 0;
    // Use entries() instead of tuple destructuring
    for (entry in map.entries()) {
        count = count + 1;
    }
    assert(count == 0);
}
