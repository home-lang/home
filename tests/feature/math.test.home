// Math Functions Test Suite

// ============================================================================
// BASIC OPERATIONS
// ============================================================================

it("should compute absolute value") {
    assert(math::abs(-5) == 5);
    assert(math::abs(5) == 5);
    assert(math::abs(0) == 0);
}

it("should compute absolute value of float") {
    assert(math::abs(-3.14) == 3.14);
    assert(math::abs(3.14) == 3.14);
}

it("should find minimum") {
    assert(math::min(3, 7) == 3);
    assert(math::min(-5, 2) == -5);
    assert(math::min(4.5, 4.4) == 4.4);
}

it("should find maximum") {
    assert(math::max(3, 7) == 7);
    assert(math::max(-5, 2) == 2);
    assert(math::max(4.5, 4.4) == 4.5);
}

it("should clamp value") {
    assert(math::clamp(5, 0, 10) == 5);
    assert(math::clamp(-5, 0, 10) == 0);
    assert(math::clamp(15, 0, 10) == 10);
}

// ============================================================================
// ROUNDING
// ============================================================================

it("should round to nearest") {
    assert(math::round(3.4) == 3);
    assert(math::round(3.5) == 4);
    assert(math::round(3.6) == 4);
    assert(math::round(-3.5) == -4);
}

it("should floor value") {
    assert(math::floor(3.9) == 3);
    assert(math::floor(3.1) == 3);
    assert(math::floor(-3.1) == -4);
}

it("should ceil value") {
    assert(math::ceil(3.1) == 4);
    assert(math::ceil(3.9) == 4);
    assert(math::ceil(-3.9) == -3);
}

it("should truncate value") {
    assert(math::trunc(3.9) == 3);
    assert(math::trunc(-3.9) == -3);
}

it("should round to decimal places") {
    assert(math::round_to(3.14159, 2) == 3.14);
    assert(math::round_to(3.145, 2) == 3.15);
}

// ============================================================================
// POWER AND ROOTS
// ============================================================================

it("should compute power") {
    assert(math::pow(2, 3) == 8);
    assert(math::pow(2, 0) == 1);
    assert(math::pow(10, 2) == 100);
}

it("should compute square root") {
    assert(math::sqrt(4) == 2);
    assert(math::sqrt(9) == 3);
    assert(math::sqrt(2) > 1.41 and math::sqrt(2) < 1.42);
}

it("should compute cube root") {
    assert(math::cbrt(8) == 2);
    assert(math::cbrt(27) == 3);
    assert(math::cbrt(-8) == -2);
}

it("should compute nth root") {
    assert(math::root(16, 4) == 2);
    assert(math::root(32, 5) == 2);
}

it("should compute hypotenuse") {
    assert(math::hypot(3, 4) == 5);
    assert(math::hypot(5, 12) == 13);
}

// ============================================================================
// LOGARITHMS
// ============================================================================

it("should compute natural logarithm") {
    assert(math::ln(math::E) == 1);
    assert(math::ln(1) == 0);
}

it("should compute log base 10") {
    assert(math::log10(10) == 1);
    assert(math::log10(100) == 2);
    assert(math::log10(1000) == 3);
}

it("should compute log base 2") {
    assert(math::log2(2) == 1);
    assert(math::log2(8) == 3);
    assert(math::log2(1024) == 10);
}

it("should compute log with custom base") {
    assert(math::log(8, 2) == 3);
    assert(math::log(81, 3) == 4);
}

it("should compute exponential") {
    assert(math::exp(0) == 1);
    assert(math::exp(1) > 2.71 and math::exp(1) < 2.72);
}

// ============================================================================
// TRIGONOMETRY
// ============================================================================

it("should compute sine") {
    assert(math::abs(math::sin(0)) < 0.0001);
    assert(math::abs(math::sin(math::PI / 2) - 1) < 0.0001);
}

it("should compute cosine") {
    assert(math::abs(math::cos(0) - 1) < 0.0001);
    assert(math::abs(math::cos(math::PI)) + 1 < 0.0001);
}

it("should compute tangent") {
    assert(math::abs(math::tan(0)) < 0.0001);
    assert(math::abs(math::tan(math::PI / 4) - 1) < 0.0001);
}

it("should compute arcsine") {
    assert(math::abs(math::asin(0)) < 0.0001);
    assert(math::abs(math::asin(1) - math::PI / 2) < 0.0001);
}

it("should compute arccosine") {
    assert(math::abs(math::acos(1)) < 0.0001);
    assert(math::abs(math::acos(0) - math::PI / 2) < 0.0001);
}

it("should compute arctangent") {
    assert(math::abs(math::atan(0)) < 0.0001);
    assert(math::abs(math::atan(1) - math::PI / 4) < 0.0001);
}

it("should compute atan2") {
    assert(math::abs(math::atan2(1, 1) - math::PI / 4) < 0.0001);
    assert(math::abs(math::atan2(0, 1)) < 0.0001);
}

// ============================================================================
// HYPERBOLIC FUNCTIONS
// ============================================================================

it("should compute sinh") {
    assert(math::abs(math::sinh(0)) < 0.0001);
}

it("should compute cosh") {
    assert(math::abs(math::cosh(0) - 1) < 0.0001);
}

it("should compute tanh") {
    assert(math::abs(math::tanh(0)) < 0.0001);
}

// ============================================================================
// ANGLE CONVERSION
// ============================================================================

it("should convert degrees to radians") {
    assert(math::abs(math::to_radians(180) - math::PI) < 0.0001);
    assert(math::abs(math::to_radians(90) - math::PI / 2) < 0.0001);
}

it("should convert radians to degrees") {
    assert(math::abs(math::to_degrees(math::PI) - 180) < 0.0001);
    assert(math::abs(math::to_degrees(math::PI / 2) - 90) < 0.0001);
}

// ============================================================================
// CONSTANTS
// ============================================================================

it("should have PI constant") {
    assert(math::PI > 3.141 and math::PI < 3.142);
}

it("should have E constant") {
    assert(math::E > 2.718 and math::E < 2.719);
}

it("should have TAU constant") {
    assert(math::abs(math::TAU - 2 * math::PI) < 0.0001);
}

it("should have infinity") {
    assert(math::INFINITY > 1e308);
    assert(math::NEG_INFINITY < -1e308);
}

it("should have NaN") {
    assert(math::is_nan(math::NAN) == true);
}

// ============================================================================
// SPECIAL VALUES
// ============================================================================

it("should check for NaN") {
    assert(math::is_nan(0.0 / 0.0) == true);
    assert(math::is_nan(1.0) == false);
}

it("should check for infinity") {
    assert(math::is_infinite(1.0 / 0.0) == true);
    assert(math::is_infinite(1.0) == false);
}

it("should check for finite") {
    assert(math::is_finite(1.0) == true);
    assert(math::is_finite(1.0 / 0.0) == false);
}

// ============================================================================
// SIGN AND COMPARISON
// ============================================================================

it("should get sign") {
    assert(math::sign(-5) == -1);
    assert(math::sign(5) == 1);
    assert(math::sign(0) == 0);
}

it("should copy sign") {
    assert(math::copysign(5, -1) == -5);
    assert(math::copysign(-5, 1) == 5);
}

// ============================================================================
// MODULO AND REMAINDER
// ============================================================================

it("should compute modulo") {
    assert(math::mod(7, 3) == 1);
    assert(math::mod(-7, 3) == 2);  // True modulo
}

it("should compute remainder") {
    assert(math::rem(7, 3) == 1);
    assert(math::rem(-7, 3) == -1);  // Remainder preserves sign
}

it("should compute fmod for floats") {
    assert(math::abs(math::fmod(5.5, 2.0) - 1.5) < 0.0001);
}

// ============================================================================
// FACTORIAL AND COMBINATORICS
// ============================================================================

it("should compute factorial") {
    assert(math::factorial(0) == 1);
    assert(math::factorial(1) == 1);
    assert(math::factorial(5) == 120);
    assert(math::factorial(10) == 3628800);
}

it("should compute permutations") {
    assert(math::permutations(5, 2) == 20);
    assert(math::permutations(10, 3) == 720);
}

it("should compute combinations") {
    assert(math::combinations(5, 2) == 10);
    assert(math::combinations(10, 3) == 120);
}

// ============================================================================
// GCD AND LCM
// ============================================================================

it("should compute GCD") {
    assert(math::gcd(12, 8) == 4);
    assert(math::gcd(17, 13) == 1);
    assert(math::gcd(100, 25) == 25);
}

it("should compute LCM") {
    assert(math::lcm(4, 6) == 12);
    assert(math::lcm(3, 5) == 15);
}

// ============================================================================
// INTEGER OPERATIONS
// ============================================================================

it("should check if even") {
    assert(math::is_even(4) == true);
    assert(math::is_even(3) == false);
}

it("should check if odd") {
    assert(math::is_odd(3) == true);
    assert(math::is_odd(4) == false);
}

it("should check if prime") {
    assert(math::is_prime(2) == true);
    assert(math::is_prime(17) == true);
    assert(math::is_prime(4) == false);
    assert(math::is_prime(1) == false);
}

it("should compute integer power") {
    assert(math::ipow(2, 10) == 1024);
    assert(math::ipow(3, 4) == 81);
}

// ============================================================================
// INTERPOLATION
// ============================================================================

it("should linear interpolate") {
    assert(math::lerp(0, 10, 0.5) == 5);
    assert(math::lerp(0, 10, 0) == 0);
    assert(math::lerp(0, 10, 1) == 10);
}

it("should inverse lerp") {
    assert(math::inv_lerp(0, 10, 5) == 0.5);
    assert(math::inv_lerp(0, 10, 0) == 0);
    assert(math::inv_lerp(0, 10, 10) == 1);
}

it("should remap value") {
    assert(math::remap(5, 0, 10, 0, 100) == 50);
    assert(math::remap(2, 0, 4, 0, 8) == 4);
}

// ============================================================================
// VECTOR OPERATIONS
// ============================================================================

it("should compute dot product") {
    assert(math::dot([1, 2, 3], [4, 5, 6]) == 32);
}

it("should compute cross product") {
    let result = math::cross([1, 0, 0], [0, 1, 0]);
    assert(result == [0, 0, 1]);
}

it("should compute vector magnitude") {
    assert(math::magnitude([3, 4]) == 5);
}

it("should normalize vector") {
    let norm = math::normalize([3, 4]);
    assert(math::abs(norm[0] - 0.6) < 0.0001);
    assert(math::abs(norm[1] - 0.8) < 0.0001);
}

