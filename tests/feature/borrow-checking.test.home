// Borrow Checking Test Suite (WIP)
// Tests borrowing rules and reference semantics

struct Counter {
    value: i32,
}

it("should allow immutable borrow") {
    let x = 42;
    let y = &x;
    assert(*y == 42);
}

it("should allow mutable borrow") {
    let mut x = 42;
    let y = &mut x;
    *y = 100;
    assert(x == 100);
}

it("should allow multiple immutable borrows") {
    let x = 42;
    let y = &x;
    let z = &x;
    assert(*y == 42);
    assert(*z == 42);
    assert(*y == *z);
}

it("should track borrow lifetimes") {
    fn get_ref(data: &i32): &i32 {
        return data;
    }
    let x = 42;
    let r = get_ref(&x);
    assert(*r == 42);
}

it("should handle struct borrowing") {
    let counter = Counter { value: 0 };
    let r = &counter;
    assert((*r).value == 0);
}

it("should borrow in function") {
    fn read_value(x: &i32): i32 {
        return 0;
    }
    let val = 42;
    let result = read_value(&val);
    assert(result == 0);
}

it("should allow re-borrow after drop") {
    let x = 10;
    {
        let r1 = &x;
        assert(*r1 == 10);
    }
    let r2 = &x;
    assert(*r2 == 10);
}

it("should borrow array element") {
    let arr = [1, 2, 3];
    let elem = &arr[0];
    assert(*elem == 1);
}

it("should handle nested borrow") {
    struct Wrapper { data: i32 }
    let w = Wrapper { data: 42 };
    let r1 = &w;
    let r2 = &w;
    assert((*r1).data == 42);
    assert((*r2).data == 42);
}

it("should borrow in loop") {
    let value = 100;
    let mut i = 0;
    while (i < 3) {
        let r = &value;
        i = i + 1;
    }
    assert(i == 3);
}

it("should handle mutable reborrow") {
    let mut x = 5;
    {
        let r = &mut x;
        *r = 10;
    }
    let r2 = &mut x;
    *r2 = 20;
    assert(x == 20);
}

it("should borrow struct field") {
    let c = Counter { value: 42 };
    let r = &c.value;
    assert(*r == 42);
}

it("should handle reference in conditional") {
    let x = 10;
    let y = 20;
    let r = if (true) { &x } else { &y };
    assert(*r == 10);
}

it("should track multiple struct borrows") {
    let c1 = Counter { value: 1 };
    let c2 = Counter { value: 2 };
    let r1 = &c1;
    let r2 = &c2;
    assert((*r1).value == 1);
    assert((*r2).value == 2);
}

