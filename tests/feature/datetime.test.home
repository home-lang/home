// Date and Time Test Suite

// ============================================================================
// CURRENT TIME
// ============================================================================

it("should get current timestamp") {
    let now = time::now();
    assert(now > 0);
}

it("should get current date") {
    let today = date::today();
    assert(today.year >= 2024);
    assert(today.month >= 1 and today.month <= 12);
    assert(today.day >= 1 and today.day <= 31);
}

it("should get current datetime") {
    let now = datetime::now();
    assert(now.year >= 2024);
    assert(now.hour >= 0 and now.hour < 24);
}

// ============================================================================
// DATE CREATION
// ============================================================================

it("should create date from components") {
    let d = date::new(2023, 12, 25);
    assert(d.year == 2023);
    assert(d.month == 12);
    assert(d.day == 25);
}

it("should parse date from string") {
    let d = date::parse("2023-12-25");
    assert(d.year == 2023);
    assert(d.month == 12);
    assert(d.day == 25);
}

it("should parse date with different formats") {
    let d1 = date::parse("12/25/2023", format: "MM/DD/YYYY");
    let d2 = date::parse("25.12.2023", format: "DD.MM.YYYY");
    assert(d1.year == 2023);
    assert(d2.year == 2023);
}

// ============================================================================
// TIME CREATION
// ============================================================================

it("should create time from components") {
    let t = time::new(14, 30, 45);
    assert(t.hour == 14);
    assert(t.minute == 30);
    assert(t.second == 45);
}

it("should create time with nanoseconds") {
    let t = time::new(14, 30, 45, 123456789);
    assert(t.nanosecond == 123456789);
}

it("should parse time from string") {
    let t = time::parse("14:30:45");
    assert(t.hour == 14);
    assert(t.minute == 30);
    assert(t.second == 45);
}

// ============================================================================
// DATETIME CREATION
// ============================================================================

it("should create datetime from components") {
    let dt = datetime::new(2023, 12, 25, 14, 30, 45);
    assert(dt.year == 2023);
    assert(dt.month == 12);
    assert(dt.day == 25);
    assert(dt.hour == 14);
    assert(dt.minute == 30);
    assert(dt.second == 45);
}

it("should parse ISO 8601 datetime") {
    let dt = datetime::parse("2023-12-25T14:30:45Z");
    assert(dt.year == 2023);
    assert(dt.hour == 14);
}

it("should parse datetime with timezone offset") {
    let dt = datetime::parse("2023-12-25T14:30:45+05:30");
    assert(dt.year == 2023);
    assert(dt.timezone_offset == 330);  // minutes
}

// ============================================================================
// DATE ARITHMETIC
// ============================================================================

it("should add days to date") {
    let d = date::new(2023, 12, 25);
    let next = d.add_days(7);
    assert(next.year == 2024);
    assert(next.month == 1);
    assert(next.day == 1);
}

it("should subtract days from date") {
    let d = date::new(2024, 1, 1);
    let prev = d.sub_days(7);
    assert(prev.year == 2023);
    assert(prev.month == 12);
    assert(prev.day == 25);
}

it("should add months to date") {
    let d = date::new(2023, 11, 15);
    let next = d.add_months(3);
    assert(next.year == 2024);
    assert(next.month == 2);
    assert(next.day == 15);
}

it("should handle month overflow") {
    let d = date::new(2023, 1, 31);
    let next = d.add_months(1);
    assert(next.month == 2);
    assert(next.day == 28);  // Feb doesn't have 31 days
}

it("should add years to date") {
    let d = date::new(2023, 6, 15);
    let next = d.add_years(5);
    assert(next.year == 2028);
}

it("should handle leap year") {
    let d = date::new(2024, 2, 29);  // Leap year
    let next = d.add_years(1);
    assert(next.day == 28);  // 2025 is not a leap year
}

// ============================================================================
// TIME ARITHMETIC
// ============================================================================

it("should add hours to datetime") {
    let dt = datetime::new(2023, 12, 25, 22, 0, 0);
    let next = dt.add_hours(5);
    assert(next.day == 26);
    assert(next.hour == 3);
}

it("should add minutes to datetime") {
    let dt = datetime::new(2023, 12, 25, 14, 30, 0);
    let next = dt.add_minutes(45);
    assert(next.hour == 15);
    assert(next.minute == 15);
}

it("should add seconds to datetime") {
    let dt = datetime::new(2023, 12, 25, 14, 59, 45);
    let next = dt.add_seconds(30);
    assert(next.hour == 15);
    assert(next.minute == 0);
    assert(next.second == 15);
}

// ============================================================================
// DURATION
// ============================================================================

it("should create duration from seconds") {
    let d = duration::from_seconds(3661);
    assert(d.hours() == 1);
    assert(d.minutes() == 1);
    assert(d.seconds() == 1);
}

it("should create duration from components") {
    let d = duration::new(hours: 2, minutes: 30, seconds: 45);
    assert(d.total_seconds() == 9045);
}

it("should add durations") {
    let d1 = duration::from_minutes(30);
    let d2 = duration::from_minutes(45);
    let sum = d1 + d2;
    assert(sum.total_minutes() == 75);
}

it("should subtract durations") {
    let d1 = duration::from_hours(2);
    let d2 = duration::from_minutes(30);
    let diff = d1 - d2;
    assert(diff.total_minutes() == 90);
}

// ============================================================================
// DATE COMPARISON
// ============================================================================

it("should compare dates") {
    let d1 = date::new(2023, 12, 25);
    let d2 = date::new(2024, 1, 1);
    assert(d1 < d2);
    assert(d2 > d1);
}

it("should check date equality") {
    let d1 = date::new(2023, 12, 25);
    let d2 = date::new(2023, 12, 25);
    assert(d1 == d2);
}

it("should get days between dates") {
    let d1 = date::new(2023, 12, 25);
    let d2 = date::new(2024, 1, 1);
    let diff = d2.days_since(d1);
    assert(diff == 7);
}

// ============================================================================
// DAY OF WEEK
// ============================================================================

it("should get day of week") {
    let d = date::new(2023, 12, 25);  // Monday
    assert(d.weekday() == Weekday::Monday);
}

it("should check if weekend") {
    let saturday = date::new(2023, 12, 23);
    let monday = date::new(2023, 12, 25);
    assert(saturday.is_weekend() == true);
    assert(monday.is_weekend() == false);
}

it("should get day of year") {
    let d = date::new(2023, 12, 31);
    assert(d.day_of_year() == 365);
}

it("should get week of year") {
    let d = date::new(2023, 1, 15);
    assert(d.week_of_year() == 2);
}

// ============================================================================
// FORMATTING
// ============================================================================

it("should format date as ISO") {
    let d = date::new(2023, 12, 25);
    assert(d.to_iso() == "2023-12-25");
}

it("should format datetime as ISO") {
    let dt = datetime::new(2023, 12, 25, 14, 30, 45);
    let iso = dt.to_iso();
    assert(iso.starts_with("2023-12-25T14:30:45"));
}

it("should format with custom pattern") {
    let d = date::new(2023, 12, 25);
    assert(d.format("DD/MM/YYYY") == "25/12/2023");
    assert(d.format("MMMM D, YYYY") == "December 25, 2023");
}

it("should format time") {
    let t = time::new(14, 30, 45);
    assert(t.format("HH:mm:ss") == "14:30:45");
    assert(t.format("h:mm A") == "2:30 PM");
}

// ============================================================================
// TIMEZONE
// ============================================================================

it("should convert to UTC") {
    let dt = datetime::new(2023, 12, 25, 14, 30, 0, tz: "America/New_York");
    let utc = dt.to_utc();
    assert(utc.hour == 19);  // EST is UTC-5
}

it("should convert between timezones") {
    let dt = datetime::new(2023, 12, 25, 12, 0, 0, tz: "UTC");
    let tokyo = dt.in_timezone("Asia/Tokyo");
    assert(tokyo.hour == 21);  // JST is UTC+9
}

it("should get timezone offset") {
    let dt = datetime::now_in("America/New_York");
    let offset = dt.utc_offset();
    assert(offset == -300 or offset == -240);  // EST or EDT
}

// ============================================================================
// UNIX TIMESTAMP
// ============================================================================

it("should convert to unix timestamp") {
    let dt = datetime::new(2023, 12, 25, 0, 0, 0, tz: "UTC");
    let ts = dt.to_unix();
    assert(ts > 1703462400);
}

it("should create from unix timestamp") {
    let ts = 1703462400;  // 2023-12-25 00:00:00 UTC
    let dt = datetime::from_unix(ts);
    assert(dt.year == 2023);
    assert(dt.month == 12);
    assert(dt.day == 25);
}

it("should handle milliseconds") {
    let ts_ms = 1703462400000;
    let dt = datetime::from_unix_millis(ts_ms);
    assert(dt.year == 2023);
}

// ============================================================================
// LEAP YEAR
// ============================================================================

it("should detect leap year") {
    assert(date::is_leap_year(2024) == true);
    assert(date::is_leap_year(2023) == false);
    assert(date::is_leap_year(2000) == true);
    assert(date::is_leap_year(1900) == false);
}

it("should get days in month") {
    assert(date::days_in_month(2023, 2) == 28);
    assert(date::days_in_month(2024, 2) == 29);
    assert(date::days_in_month(2023, 12) == 31);
}

// ============================================================================
// START AND END OF PERIOD
// ============================================================================

it("should get start of day") {
    let dt = datetime::new(2023, 12, 25, 14, 30, 45);
    let start = dt.start_of_day();
    assert(start.hour == 0);
    assert(start.minute == 0);
    assert(start.second == 0);
}

it("should get end of day") {
    let dt = datetime::new(2023, 12, 25, 14, 30, 45);
    let end = dt.end_of_day();
    assert(end.hour == 23);
    assert(end.minute == 59);
    assert(end.second == 59);
}

it("should get start of month") {
    let d = date::new(2023, 12, 25);
    let start = d.start_of_month();
    assert(start.day == 1);
}

it("should get end of month") {
    let d = date::new(2023, 12, 15);
    let end = d.end_of_month();
    assert(end.day == 31);
}

it("should get start of year") {
    let d = date::new(2023, 6, 15);
    let start = d.start_of_year();
    assert(start.month == 1);
    assert(start.day == 1);
}

// ============================================================================
// RELATIVE TIME
// ============================================================================

it("should format relative time") {
    let now = datetime::now();
    let past = now.sub_hours(2);
    assert(past.relative_to(now) == "2 hours ago");
}

it("should format future relative time") {
    let now = datetime::now();
    let future = now.add_days(3);
    assert(future.relative_to(now) == "in 3 days");
}

// ============================================================================
// DATE RANGES
// ============================================================================

it("should iterate over date range") {
    let start = date::new(2023, 12, 25);
    let end = date::new(2023, 12, 28);
    let days = date::range(start, end).collect();
    assert(days.len() == 4);
}

it("should check if date is in range") {
    let start = date::new(2023, 12, 1);
    let end = date::new(2023, 12, 31);
    let d = date::new(2023, 12, 15);
    assert(d.is_between(start, end) == true);
}
