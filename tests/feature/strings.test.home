// Strings Feature Test Suite

it("should create strings") {
    let s = "Hello, World!";
    assert(s == "Hello, World!");
}

it("should concatenate strings") {
    let a = "Hello";
    let b = "World";
    let c = a + ", " + b + "!";
    assert(c == "Hello, World!");
}

it("should compare strings") {
    let s1 = "abc";
    let s2 = "abc";
    let s3 = "xyz";
    assert(s1 == s2);
    assert(s1 != s3);
}

it("should handle empty strings") {
    let empty = "";
    let hello = "hello";
    assert(empty != hello);
}

it("should use strings in expressions") {
    let name = "Alice";
    let greeting = "Hello, " + name;
    assert(greeting == "Hello, Alice");
}

it("should concatenate multiple strings") {
    let a = "one";
    let b = "two";
    let c = "three";
    let result = a + " " + b + " " + c;
    assert(result == "one two three");
}

it("should handle string in array") {
    let names = ["Alice", "Bob", "Charlie"];
    assert(names[0] == "Alice");
    assert(names[1] == "Bob");
    assert(names[2] == "Charlie");
}

it("should compare same strings") {
    let a = "test";
    let b = "test";
    assert(a == b);
    assert(!(a != b));
}

it("should detect different strings") {
    let a = "hello";
    let b = "world";
    assert(a != b);
    assert(!(a == b));
}

it("should handle single character strings") {
    let c = "x";
    assert(c == "x");
    assert(c != "y");
}

it("should handle strings with spaces") {
    let s = "hello world";
    assert(s == "hello world");
}

it("should handle strings with numbers") {
    let s = "value: 42";
    assert(s == "value: 42");
}

it("should pass strings to functions") {
    fn greet(name: string): string {
        return "Hello, " + name + "!";
    }
    assert(greet("World") == "Hello, World!");
    assert(greet("Alice") == "Hello, Alice!");
}

it("should return strings from functions") {
    fn get_name(): string {
        return "Claude";
    }
    let name = get_name();
    assert(name == "Claude");
}

it("should use strings in conditionals") {
    let status = "active";
    let mut code = 0;
    if (status == "active") {
        code = 1;
    } else if (status == "inactive") {
        code = 0;
    }
    assert(code == 1);
}

// ============================================================================
// EDGE CASES - EMPTY STRINGS
// ============================================================================

it("should create empty string") {
    let s = "";
    assert(s == "");
}

it("should concatenate with empty string") {
    let a = "hello";
    let b = "";
    assert(a + b == "hello");
    assert(b + a == "hello");
}

it("should compare empty strings") {
    let a = "";
    let b = "";
    assert(a == b);
}

it("should detect empty vs non-empty") {
    let empty = "";
    let nonempty = "x";
    assert(empty != nonempty);
}

it("should get length of empty string") {
    let s = "";
    assert(s.len() == 0);
}

// ============================================================================
// EDGE CASES - SINGLE CHARACTER
// ============================================================================

it("should handle single char string length") {
    let s = "a";
    assert(s.len() == 1);
}

it("should compare single char strings") {
    let a = "a";
    let b = "a";
    let c = "b";
    assert(a == b);
    assert(a != c);
}

it("should concatenate single char strings") {
    let a = "a";
    let b = "b";
    let c = "c";
    assert(a + b + c == "abc");
}

// ============================================================================
// EDGE CASES - SPECIAL CHARACTERS
// ============================================================================

it("should handle string with newline") {
    let s = "line1\nline2";
    assert(s.len() == 11);
}

it("should handle string with tab") {
    let s = "col1\tcol2";
    assert(s.len() == 9);
}

it("should handle string with backslash") {
    let s = "path\\to\\file";
    assert(s.len() == 12);
}

it("should handle string with quotes") {
    let s = "he said \"hello\"";
    assert(s.len() == 15);
}

// ============================================================================
// EDGE CASES - LONG STRINGS
// ============================================================================

it("should handle long string") {
    let s = "This is a very long string that contains many characters and words to test handling of longer text content.";
    assert(s.len() > 100);
}

it("should concatenate to form long string") {
    let mut s = "";
    s = s + "aaaaaaaaaa";
    s = s + "bbbbbbbbbb";
    s = s + "cccccccccc";
    assert(s.len() == 30);
}

// ============================================================================
// EDGE CASES - STRING METHODS
// ============================================================================

it("should get string length") {
    assert("".len() == 0);
    assert("a".len() == 1);
    assert("hello".len() == 5);
    assert("hello world".len() == 11);
}

it("should check starts_with") {
    let s = "hello world";
    assert(s.starts_with("hello") == true);
    assert(s.starts_with("world") == false);
    assert(s.starts_with("") == true);
    assert(s.starts_with("hello world") == true);
}

it("should check ends_with") {
    let s = "hello world";
    assert(s.ends_with("world") == true);
    assert(s.ends_with("hello") == false);
    assert(s.ends_with("") == true);
    assert(s.ends_with("hello world") == true);
}

it("should check contains") {
    let s = "hello world";
    assert(s.contains("lo wo") == true);
    assert(s.contains("xyz") == false);
    assert(s.contains("") == true);
    assert(s.contains("hello world") == true);
}

it("should convert to uppercase") {
    assert("hello".to_upper() == "HELLO");
    assert("".to_upper() == "");
    assert("ALREADY".to_upper() == "ALREADY");
    assert("MiXeD".to_upper() == "MIXED");
}

it("should convert to lowercase") {
    assert("HELLO".to_lower() == "hello");
    assert("".to_lower() == "");
    assert("already".to_lower() == "already");
    assert("MiXeD".to_lower() == "mixed");
}

it("should trim whitespace") {
    assert("  hello  ".trim() == "hello");
    assert("hello".trim() == "hello");
    assert("   ".trim() == "");
    assert("".trim() == "");
}

// ============================================================================
// EDGE CASES - STRING INDEXING
// ============================================================================

it("should get character at index") {
    let s = "hello";
    assert(s[0] == 'h');
    assert(s[4] == 'o');
}

it("should get first character") {
    let s = "abc";
    assert(s[0] == 'a');
}

it("should get last character by length") {
    let s = "xyz";
    let last = s.len() - 1;
    assert(s[last] == 'z');
}

// ============================================================================
// EDGE CASES - STRING IN COLLECTIONS
// ============================================================================

it("should use string as map key") {
    let map = { "key1": 1, "key2": 2 };
    assert(map["key1"] == 1);
}

it("should use string as map value") {
    let map = { "name": "Alice", "city": "NYC" };
    assert(map["name"] == "Alice");
}

it("should iterate over string array") {
    let words = ["one", "two", "three"];
    let mut count = 0;
    for (w in words) {
        count = count + 1;
    }
    assert(count == 3);
}

// ============================================================================
// EDGE CASES - STRING COMPARISON EDGE CASES
// ============================================================================

it("should compare case-sensitive") {
    assert("Hello" != "hello");
    assert("ABC" != "abc");
}

it("should compare strings with numbers") {
    assert("a1" != "a2");
    assert("1a" != "2a");
    assert("123" == "123");
}

it("should compare strings with spaces") {
    assert("hello world" != "helloworld");
    assert("hello " != "hello");
    assert(" hello" != "hello");
}

// ============================================================================
// EDGE CASES - STRING IN FUNCTIONS
// ============================================================================

it("should pass empty string to function") {
    fn process(s: string): i32 {
        return s.len();
    }
    assert(process("") == 0);
    assert(process("abc") == 3);
}

it("should return empty string from function") {
    fn get_empty(): string {
        return "";
    }
    assert(get_empty() == "");
}

it("should modify string in function") {
    fn shout(s: string): string {
        return s.to_upper() + "!";
    }
    assert(shout("hello") == "HELLO!");
}

// ============================================================================
// EDGE CASES - STRING SLICING
// ============================================================================

it("should slice string") {
    let s = "hello world";
    let slice = s[0..5];
    assert(slice == "hello");
}

it("should slice from middle") {
    let s = "hello world";
    let slice = s[6..11];
    assert(slice == "world");
}

it("should handle empty slice") {
    let s = "hello";
    let slice = s[0..0];
    assert(slice == "");
}

// ============================================================================
// EDGE CASES - COMPLEX STRING OPERATIONS
// ============================================================================

it("should chain string operations") {
    let s = "  HELLO WORLD  ";
    let result = s.trim().to_lower();
    assert(result == "hello world");
}

it("should use string in ternary") {
    let flag = true;
    let s = if (flag) { "yes" } else { "no" };
    assert(s == "yes");
}

it("should build string in loop") {
    let mut s = "";
    for (i in 0..5) {
        s = s + "x";
    }
    assert(s == "xxxxx");
}

// ============================================================================
// UNICODE STRINGS
// ============================================================================

it("should handle unicode characters") {
    let s = "Hello, \u4E16\u754C";  // Hello, World in Chinese
    assert(s.len() > 0);
}

it("should handle emoji") {
    let s = "\u{1F600}";  // Grinning face emoji
    assert(s.len() > 0);
}

it("should handle multiple emoji") {
    let s = "\u{1F600}\u{1F601}\u{1F602}";
    assert(s.len() > 0);
}

it("should handle accented characters") {
    let s = "caf\u00E9";  // cafe with accent
    assert(s == "cafe" or s.contains("caf"));
}

it("should handle cyrillic") {
    let s = "\u041F\u0440\u0438\u0432\u0435\u0442";  // "Privet" in Russian
    assert(s.len() > 0);
}

it("should handle japanese hiragana") {
    let s = "\u3053\u3093\u306B\u3061\u306F";  // "konnichiwa" in Japanese
    assert(s.len() > 0);
}

it("should handle arabic") {
    let s = "\u0645\u0631\u062D\u0628\u0627";  // "marhaba" in Arabic
    assert(s.len() > 0);
}

it("should handle mixed unicode and ascii") {
    let s = "Hello \u4E16\u754C!";
    assert(s.starts_with("Hello"));
    assert(s.ends_with("!"));
}

// ============================================================================
// UNICODE STRING METHODS
// ============================================================================

it("should get unicode string length in bytes") {
    let s = "hello";
    assert(s.len() == 5);
}

it("should get unicode char count") {
    let s = "caf\u00E9";
    let char_count = s.chars().len();
    assert(char_count == 4);  // c, a, f, e-accent
}

it("should iterate unicode chars") {
    let s = "abc";
    let chars = s.chars();
    assert(chars[0] == 'a');
    assert(chars[1] == 'b');
    assert(chars[2] == 'c');
}

it("should compare unicode strings") {
    let s1 = "caf\u00E9";
    let s2 = "caf\u00E9";
    assert(s1 == s2);
}

// ============================================================================
// ESCAPE SEQUENCES
// ============================================================================

it("should handle newline escape") {
    let s = "line1\nline2";
    assert(s.contains("\n"));
}

it("should handle tab escape") {
    let s = "col1\tcol2";
    assert(s.contains("\t"));
}

it("should handle carriage return") {
    let s = "text\rmore";
    assert(s.len() == 9);
}

it("should handle backslash escape") {
    let s = "path\\to\\file";
    assert(s.contains("\\"));
}

it("should handle double quote escape") {
    let s = "say \"hello\"";
    assert(s.contains("\""));
}

it("should handle single quote escape") {
    let s = "it\'s";
    assert(s == "it's");
}

it("should handle null character") {
    let s = "before\0after";
    assert(s.len() == 12);
}

it("should handle bell/alert escape") {
    let s = "alert\a";
    assert(s.len() == 6);
}

it("should handle backspace escape") {
    let s = "back\bspace";
    assert(s.len() == 10);
}

it("should handle form feed escape") {
    let s = "form\ffeed";
    assert(s.len() == 9);
}

it("should handle vertical tab escape") {
    let s = "vertical\vtab";
    assert(s.len() == 12);
}

// ============================================================================
// HEX AND UNICODE ESCAPES
// ============================================================================

it("should handle hex escape") {
    let s = "\x48\x65\x6C\x6C\x6F";  // "Hello"
    assert(s == "Hello");
}

it("should handle unicode escape 4 digits") {
    let s = "\u0048\u0065\u006C\u006C\u006F";  // "Hello"
    assert(s == "Hello");
}

it("should handle unicode escape braces") {
    let s = "\u{48}\u{65}\u{6C}\u{6C}\u{6F}";  // "Hello"
    assert(s == "Hello");
}

it("should handle unicode escape long form") {
    let s = "\u{0001F600}";  // Grinning face
    assert(s.len() > 0);
}

// ============================================================================
// RAW STRINGS
// ============================================================================

it("should handle raw string") {
    let s = r"no\escape\here";
    assert(s.contains("\\"));
    assert(s.len() == 14);
}

it("should handle raw string with quotes") {
    let s = r#"can have "quotes" inside"#;
    assert(s.contains("\""));
}

it("should handle raw string multiline") {
    let s = r"line1
line2";
    assert(s.contains("line1"));
    assert(s.contains("line2"));
}

// ============================================================================
// MULTILINE STRINGS
// ============================================================================

it("should handle multiline string literal") {
    let s = """
    line 1
    line 2
    line 3
    """;
    assert(s.contains("line 1"));
    assert(s.contains("line 2"));
    assert(s.contains("line 3"));
}

it("should preserve indentation in multiline") {
    let s = """
    if (true) {
        doSomething();
    }
    """;
    assert(s.contains("if"));
    assert(s.contains("doSomething"));
}

// ============================================================================
// STRING BYTES
// ============================================================================

it("should get bytes of string") {
    let s = "ABC";
    let bytes = s.bytes();
    assert(bytes[0] == 65);  // 'A'
    assert(bytes[1] == 66);  // 'B'
    assert(bytes[2] == 67);  // 'C'
}

it("should convert bytes back to string") {
    let bytes = [72, 105];  // "Hi"
    let s = string.from_bytes(bytes);
    assert(s == "Hi");
}

// ============================================================================
// STRING ENCODING
// ============================================================================

it("should encode to utf8") {
    let s = "hello";
    let utf8 = s.encode("utf-8");
    assert(utf8.len() == 5);
}

it("should decode from utf8") {
    let bytes = [104, 101, 108, 108, 111];  // "hello"
    let s = string.decode(bytes, "utf-8");
    assert(s == "hello");
}

// ============================================================================
// UNICODE NORMALIZATION
// ============================================================================

it("should normalize unicode NFC") {
    let s1 = "e\u0301";  // e + combining acute
    let s2 = "\u00E9";   // precomposed e-acute
    let n1 = s1.normalize("NFC");
    let n2 = s2.normalize("NFC");
    assert(n1 == n2);
}

it("should normalize unicode NFD") {
    let s = "\u00E9";  // precomposed e-acute
    let normalized = s.normalize("NFD");
    assert(normalized.chars().len() == 2);
}

// ============================================================================
// UNICODE PROPERTIES
// ============================================================================

it("should check if char is alphabetic") {
    assert('a'.is_alpha() == true);
    assert('1'.is_alpha() == false);
    assert('\u00E9'.is_alpha() == true);
}

it("should check if char is numeric") {
    assert('0'.is_numeric() == true);
    assert('9'.is_numeric() == true);
    assert('a'.is_numeric() == false);
}

it("should check if char is alphanumeric") {
    assert('a'.is_alphanumeric() == true);
    assert('1'.is_alphanumeric() == true);
    assert(' '.is_alphanumeric() == false);
}

it("should check if char is whitespace") {
    assert(' '.is_whitespace() == true);
    assert('\t'.is_whitespace() == true);
    assert('\n'.is_whitespace() == true);
    assert('a'.is_whitespace() == false);
}

it("should check if char is uppercase") {
    assert('A'.is_uppercase() == true);
    assert('a'.is_uppercase() == false);
}

it("should check if char is lowercase") {
    assert('a'.is_lowercase() == true);
    assert('A'.is_lowercase() == false);
}

// ============================================================================
// CHAR CASE CONVERSION
// ============================================================================

it("should convert char to uppercase") {
    assert('a'.to_uppercase() == 'A');
    assert('z'.to_uppercase() == 'Z');
    assert('A'.to_uppercase() == 'A');
}

it("should convert char to lowercase") {
    assert('A'.to_lowercase() == 'a');
    assert('Z'.to_lowercase() == 'z');
    assert('a'.to_lowercase() == 'a');
}

// ============================================================================
// UNICODE STRING OPERATIONS
// ============================================================================

it("should reverse unicode string") {
    let s = "hello";
    let reversed = s.reverse();
    assert(reversed == "olleh");
}

it("should reverse string with unicode") {
    let s = "ab\u00E9";
    let reversed = s.reverse();
    assert(reversed.chars()[0] == '\u00E9');
}

it("should split unicode string") {
    let s = "a,b,\u00E9";
    let parts = s.split(",");
    assert(parts.len() == 3);
    assert(parts[0] == "a");
    assert(parts[1] == "b");
}

// ============================================================================
// STRING GRAPHEME CLUSTERS
// ============================================================================

it("should count grapheme clusters") {
    let s = "e\u0301";  // e + combining acute = 1 grapheme
    let graphemes = s.graphemes();
    assert(graphemes.len() == 1);
}

it("should handle emoji as single grapheme") {
    let s = "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}";  // family emoji
    let graphemes = s.graphemes();
    assert(graphemes.len() == 1);
}

// ============================================================================
// UNICODE EDGE CASES
// ============================================================================

it("should handle empty unicode string") {
    let s = "";
    assert(s.chars().len() == 0);
}

it("should handle BOM") {
    let s = "\uFEFFhello";
    assert(s.contains("hello"));
}

it("should handle zero width chars") {
    let s = "a\u200Bb";  // zero-width space between a and b
    assert(s.len() > 2);
}

it("should handle right-to-left marker") {
    let s = "\u200Fhello";
    assert(s.contains("hello"));
}

// ============================================================================
// STRING FORMATTING WITH UNICODE
// ============================================================================

it("should format with unicode placeholder") {
    let name = "\u4E16\u754C";
    let greeting = "Hello, {name}!";
    assert(greeting.contains("{name}"));
}

it("should pad unicode string") {
    let s = "ab";
    let padded = s.pad_left(5, ' ');
    assert(padded == "   ab");
}

it("should center unicode string") {
    let s = "hi";
    let centered = s.center(6, '-');
    assert(centered == "--hi--");
}
