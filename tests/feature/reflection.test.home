// Reflection and Introspection Test Suite

// ============================================================================
// TYPE INSPECTION
// ============================================================================

it("should get type of value") {
    assert(reflect::type_of(42) == "int");
    assert(reflect::type_of(3.14) == "float");
    assert(reflect::type_of("hello") == "string");
    assert(reflect::type_of(true) == "bool");
    assert(reflect::type_of(null) == "null");
}

it("should get type of array") {
    let arr = [1, 2, 3];
    assert(reflect::type_of(arr) == "array");
    assert(reflect::element_type(arr) == "int");
}

it("should get type of map") {
    let map = { "a": 1, "b": 2 };
    assert(reflect::type_of(map) == "map");
}

it("should get type of function") {
    let fn = |x| x * 2;
    assert(reflect::type_of(fn) == "function");
}

// ============================================================================
// TYPE CHECKING
// ============================================================================

it("should check type") {
    assert(reflect::is_int(42) == true);
    assert(reflect::is_int("42") == false);
}

it("should check float") {
    assert(reflect::is_float(3.14) == true);
    assert(reflect::is_float(42) == false);
}

it("should check numeric") {
    assert(reflect::is_numeric(42) == true);
    assert(reflect::is_numeric(3.14) == true);
    assert(reflect::is_numeric("42") == false);
}

it("should check string") {
    assert(reflect::is_string("hello") == true);
    assert(reflect::is_string(42) == false);
}

it("should check bool") {
    assert(reflect::is_bool(true) == true);
    assert(reflect::is_bool(false) == true);
    assert(reflect::is_bool(0) == false);
}

it("should check null") {
    assert(reflect::is_null(null) == true);
    assert(reflect::is_null(0) == false);
}

it("should check array") {
    assert(reflect::is_array([1, 2, 3]) == true);
    assert(reflect::is_array("abc") == false);
}

it("should check map") {
    assert(reflect::is_map({ a: 1 }) == true);
    assert(reflect::is_map([1, 2]) == false);
}

it("should check callable") {
    assert(reflect::is_callable(|x| x) == true);
    assert(reflect::is_callable(42) == false);
}

// ============================================================================
// STRUCT REFLECTION
// ============================================================================

it("should get struct fields") {
    struct Point { x: int, y: int }
    let fields = reflect::fields(Point);
    assert(fields.contains("x"));
    assert(fields.contains("y"));
}

it("should get field types") {
    struct Person { name: string, age: int }
    let types = reflect::field_types(Person);
    assert(types["name"] == "string");
    assert(types["age"] == "int");
}

it("should get field value") {
    struct Point { x: int, y: int }
    let p = Point { x: 10, y: 20 };
    assert(reflect::get_field(p, "x") == 10);
    assert(reflect::get_field(p, "y") == 20);
}

it("should set field value") {
    struct Point { x: int, y: int }
    let p = Point { x: 0, y: 0 };
    reflect::set_field(p, "x", 42);
    assert(p.x == 42);
}

it("should check field exists") {
    struct Point { x: int, y: int }
    assert(reflect::has_field(Point, "x") == true);
    assert(reflect::has_field(Point, "z") == false);
}

// ============================================================================
// METHOD REFLECTION
// ============================================================================

it("should get struct methods") {
    struct Calculator {
        fn add(a: int, b: int) -> int { return a + b; }
        fn sub(a: int, b: int) -> int { return a - b; }
    }
    let methods = reflect::methods(Calculator);
    assert(methods.contains("add"));
    assert(methods.contains("sub"));
}

it("should get method signature") {
    struct Math {
        fn add(a: int, b: int) -> int { return a + b; }
    }
    let sig = reflect::method_signature(Math, "add");
    assert(sig.params.len() == 2);
    assert(sig.return_type == "int");
}

it("should invoke method by name") {
    struct Math {
        fn add(a: int, b: int) -> int { return a + b; }
    }
    let m = Math {};
    let result = reflect::invoke(m, "add", [1, 2]);
    assert(result == 3);
}

// ============================================================================
// FUNCTION REFLECTION
// ============================================================================

it("should get function name") {
    fn my_function() {}
    let name = reflect::function_name(my_function);
    assert(name == "my_function");
}

it("should get function arity") {
    let fn = |a, b, c| a + b + c;
    assert(reflect::arity(fn) == 3);
}

it("should get function parameters") {
    fn add(a: int, b: int) -> int { return a + b; }
    let params = reflect::parameters(add);
    assert(params.len() == 2);
    assert(params[0].name == "a");
    assert(params[0].type == "int");
}

// ============================================================================
// ENUM REFLECTION
// ============================================================================

it("should get enum variants") {
    enum Color { Red, Green, Blue }
    let variants = reflect::variants(Color);
    assert(variants.contains("Red"));
    assert(variants.contains("Green"));
    assert(variants.contains("Blue"));
}

it("should get enum variant value") {
    enum Status { Active = 1, Inactive = 0 }
    assert(reflect::variant_value(Status, "Active") == 1);
}

it("should get variant from value") {
    enum Status { Active = 1, Inactive = 0 }
    let name = reflect::variant_name(Status, 1);
    assert(name == "Active");
}

// ============================================================================
// TYPE CONVERSION
// ============================================================================

it("should convert type") {
    let result = reflect::convert(42, "string");
    assert(result == "42");
}

it("should check convertible") {
    assert(reflect::is_convertible(42, "string") == true);
    assert(reflect::is_convertible("not_a_num", "int") == false);
}

// ============================================================================
// OBJECT COMPARISON
// ============================================================================

it("should check deep equality") {
    let a = { x: [1, 2, { y: 3 }] };
    let b = { x: [1, 2, { y: 3 }] };
    assert(reflect::deep_equal(a, b) == true);
}

it("should compare types") {
    assert(reflect::same_type(42, 100) == true);
    assert(reflect::same_type(42, "42") == false);
}

// ============================================================================
// CLONING AND COPYING
// ============================================================================

it("should shallow copy") {
    let original = { a: 1, b: [1, 2, 3] };
    let copy = reflect::shallow_copy(original);
    assert(copy.a == 1);
    copy.a = 2;
    assert(original.a == 1);  // Original unchanged
}

it("should deep copy") {
    let original = { a: 1, b: [1, 2, 3] };
    let copy = reflect::deep_copy(original);
    copy.b[0] = 100;
    assert(original.b[0] == 1);  // Original unchanged
}

// ============================================================================
// PROPERTY ENUMERATION
// ============================================================================

it("should enumerate object keys") {
    let obj = { a: 1, b: 2, c: 3 };
    let keys = reflect::keys(obj);
    assert(keys.len() == 3);
    assert(keys.contains("a"));
}

it("should enumerate object values") {
    let obj = { a: 1, b: 2, c: 3 };
    let values = reflect::values(obj);
    assert(values.len() == 3);
    assert(values.contains(1));
}

it("should enumerate object entries") {
    let obj = { a: 1, b: 2 };
    let entries = reflect::entries(obj);
    assert(entries.len() == 2);
}

// ============================================================================
// ATTRIBUTE/ANNOTATION INSPECTION
// ============================================================================

it("should get type attributes") {
    @serializable
    @deprecated("use NewType instead")
    struct OldType { value: int }

    let attrs = reflect::attributes(OldType);
    assert(attrs.contains("serializable"));
    assert(attrs.contains("deprecated"));
}

it("should get attribute value") {
    @version("1.0.0")
    struct MyType {}

    let version = reflect::attribute(MyType, "version");
    assert(version == "1.0.0");
}

// ============================================================================
// MEMORY INSPECTION
// ============================================================================

it("should get size of type") {
    struct Point { x: float, y: float }
    let size = reflect::size_of(Point);
    assert(size == 16);  // Two 8-byte floats
}

it("should get alignment of type") {
    struct Data { value: int }
    let align = reflect::align_of(Data);
    assert(align >= 4);
}

// ============================================================================
// MODULE INSPECTION
// ============================================================================

it("should list module exports") {
    let exports = reflect::module_exports("std::math");
    assert(exports.contains("sin"));
    assert(exports.contains("cos"));
}

it("should check module loaded") {
    assert(reflect::is_module_loaded("std::core") == true);
}

// ============================================================================
// DYNAMIC INVOCATION
// ============================================================================

it("should call function dynamically") {
    fn add(a: int, b: int) -> int { return a + b; }
    let result = reflect::call(add, [5, 3]);
    assert(result == 8);
}

it("should apply function with array args") {
    let fn = |a, b, c| a + b + c;
    let args = [1, 2, 3];
    let result = reflect::apply(fn, args);
    assert(result == 6);
}

// ============================================================================
// TYPE CREATION
// ============================================================================

it("should create instance dynamically") {
    struct Point { x: int, y: int }
    let p = reflect::create(Point, { x: 10, y: 20 });
    assert(p.x == 10);
    assert(p.y == 20);
}

it("should create array dynamically") {
    let arr = reflect::create_array("int", 5);
    assert(arr.len() == 5);
}

// ============================================================================
// PROXY AND INTERCEPT
// ============================================================================

it("should create proxy") {
    let obj = { value: 42 };
    let proxy = reflect::proxy(obj, {
        get: |target, prop| {
            print("Accessing: {prop}");
            return target[prop];
        },
        set: |target, prop, value| {
            print("Setting {prop} to {value}");
            target[prop] = value;
        },
    });
    assert(proxy.value == 42);
}

// ============================================================================
// STACK INSPECTION
// ============================================================================

it("should get call stack") {
    fn inner() {
        let stack = reflect::call_stack();
        return stack;
    }
    fn outer() {
        return inner();
    }
    let stack = outer();
    assert(stack.len() >= 2);
}

it("should get caller info") {
    fn get_caller() {
        return reflect::caller();
    }
    let caller = get_caller();
    assert(caller.function != null);
}

