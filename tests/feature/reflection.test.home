// Reflection and Introspection Test Suite

// ============================================================================
// TYPE INSPECTION
// ============================================================================

it("should get type of value") {
    assert(Reflect.typeOf(42) == "int");
    assert(Reflect.typeOf(3.14) == "float");
    assert(Reflect.typeOf("hello") == "string");
    assert(Reflect.typeOf(true) == "bool");
    assert(Reflect.typeOf(null) == "null");
}

it("should get type of array") {
    let arr = [1, 2, 3];
    assert(Reflect.typeOf(arr) == "array");
    assert(Reflect.elementType(arr) == "int");
}

it("should get type of map") {
    let map = { "a": 1, "b": 2 };
    assert(Reflect.typeOf(map) == "map");
}

it("should get type of function") {
    let func = |x| x * 2;
    assert(Reflect.typeOf(func) == "function");
}

// ============================================================================
// TYPE CHECKING
// ============================================================================

it("should check type") {
    assert(Reflect.isInt(42) == true);
    assert(Reflect.isInt("42") == false);
}

it("should check float") {
    assert(Reflect.isFloat(3.14) == true);
    assert(Reflect.isFloat(42) == false);
}

it("should check numeric") {
    assert(Reflect.isNumeric(42) == true);
    assert(Reflect.isNumeric(3.14) == true);
    assert(Reflect.isNumeric("42") == false);
}

it("should check string") {
    assert(Reflect.isString("hello") == true);
    assert(Reflect.isString(42) == false);
}

it("should check bool") {
    assert(Reflect.isBool(true) == true);
    assert(Reflect.isBool(false) == true);
    assert(Reflect.isBool(0) == false);
}

it("should check null") {
    assert(Reflect.isNull(null) == true);
    assert(Reflect.isNull(0) == false);
}

it("should check array") {
    assert(Reflect.isArray([1, 2, 3]) == true);
    assert(Reflect.isArray("abc") == false);
}

it("should check map") {
    let m = { "a": 1 };
    assert(Reflect.isMap(m) == true);
    assert(Reflect.isMap([1, 2]) == false);
}

it("should check callable") {
    assert(Reflect.isCallable(|x| x) == true);
    assert(Reflect.isCallable(42) == false);
}

// ============================================================================
// STRUCT REFLECTION
// ============================================================================

it("should get struct fields") {
    struct Point { x: int, y: int }
    let fields = Reflect.fields(Point);
    assert(fields.contains("x"));
    assert(fields.contains("y"));
}

it("should get field types") {
    struct Person { name: string, age: int }
    let types = Reflect.fieldTypes(Person);
    assert(types["name"] == "string");
    assert(types["age"] == "int");
}

it("should get field value") {
    struct Point { x: int, y: int }
    let p = Point { x: 10, y: 20 };
    assert(Reflect.getField(p, "x") == 10);
    assert(Reflect.getField(p, "y") == 20);
}

// Note: set_field requires mutable value semantics which is not yet implemented
// it("should set field value") {
//     struct Point { x: int, y: int }
//     let p = Point { x: 0, y: 0 };
//     Reflect.setField(p, "x", 42);
//     assert(p.x == 42);
// }

it("should check field exists") {
    struct Point { x: int, y: int }
    assert(Reflect.hasField(Point, "x") == true);
    assert(Reflect.hasField(Point, "z") == false);
}

// ============================================================================
// METHOD REFLECTION
// ============================================================================
// Note: Method reflection features are not yet implemented

// it("should get struct methods") {
//     struct Calculator {
//         fn add(a: int, b: int): int { return a + b; }
//         fn sub(a: int, b: int): int { return a - b; }
//     }
//     let methods = Reflect.methods(Calculator);
//     assert(methods.contains("add"));
//     assert(methods.contains("sub"));
// }

// it("should get method signature") {
//     struct Math {
//         fn add(a: int, b: int): int { return a + b; }
//     }
//     let sig = Reflect.methodSignature(Math, "add");
//     assert(sig.params.len() == 2);
//     assert(sig.return_type == "int");
// }

// it("should invoke method by name") {
//     struct Math {
//         fn add(a: int, b: int): int { return a + b; }
//     }
//     let m = Math {};
//     let result = Reflect.invoke(m, "add", [1, 2]);
//     assert(result == 3);
// }

// ============================================================================
// FUNCTION REFLECTION
// ============================================================================
// Note: Function reflection features are not yet implemented

// it("should get function name") {
//     fn my_function() {}
//     let name = Reflect.functionName(my_function);
//     assert(name == "my_function");
// }

it("should get function arity") {
    let f = |a, b, c| a + b + c;
    assert(Reflect.arity(f) == 3);
}

// it("should get function parameters") {
//     fn add(a: int, b: int): int { return a + b; }
//     let params = Reflect.parameters(add);
//     assert(params.len() == 2);
//     assert(params[0].name == "a");
//     assert(params[0].type == "int");
// }

// ============================================================================
// ENUM REFLECTION
// ============================================================================
// Note: Enum reflection features are not yet implemented

// it("should get enum variants") {
//     enum Color { Red, Green, Blue }
//     let variants = Reflect.variants(Color);
//     assert(variants.contains("Red"));
//     assert(variants.contains("Green"));
//     assert(variants.contains("Blue"));
// }

// it("should get enum variant value") {
//     enum Status { Active = 1, Inactive = 0 }
//     assert(Reflect.variantValue(Status, "Active") == 1);
// }

// it("should get variant from value") {
//     enum Status { Active = 1, Inactive = 0 }
//     let name = Reflect.variantName(Status, 1);
//     assert(name == "Active");
// }

// ============================================================================
// TYPE CONVERSION
// ============================================================================
// Note: Type conversion features are not yet implemented

// it("should convert type") {
//     let result = Reflect.convert(42, "string");
//     assert(result == "42");
// }

// it("should check convertible") {
//     assert(Reflect.isConvertible(42, "string") == true);
//     assert(Reflect.isConvertible("not_a_num", "int") == false);
// }

// ============================================================================
// OBJECT COMPARISON
// ============================================================================

it("should check deep equality") {
    let inner_a = { "y": 3 };
    let arr_a = [1, 2, inner_a];
    let a = { "x": arr_a };

    let inner_b = { "y": 3 };
    let arr_b = [1, 2, inner_b];
    let b = { "x": arr_b };

    assert(Reflect.deepEqual(a, b) == true);
}

it("should compare types") {
    assert(Reflect.sameType(42, 100) == true);
    assert(Reflect.sameType(42, "42") == false);
}

// ============================================================================
// CLONING AND COPYING
// ============================================================================
// Note: Cloning and copying features are not yet implemented

// it("should shallow copy") {
//     let arr = [1, 2, 3];
//     let original = { "a": 1, "b": arr };
//     let copy = Reflect.shallowCopy(original);
//     assert(copy["a"] == 1);
//     copy["a"] = 2;
//     assert(original["a"] == 1);  // Original unchanged
// }

// it("should deep copy") {
//     let arr = [1, 2, 3];
//     let original = { "a": 1, "b": arr };
//     let copy = Reflect.deepCopy(original);
//     copy["b"][0] = 100;
//     assert(original["b"][0] == 1);  // Original unchanged
// }

// ============================================================================
// PROPERTY ENUMERATION
// ============================================================================

it("should enumerate object keys") {
    let obj = { "a": 1, "b": 2, "c": 3 };
    let keys = Reflect.keys(obj);
    assert(keys.len() == 3);
    assert(keys.contains("a"));
}

it("should enumerate object values") {
    let obj = { "a": 1, "b": 2, "c": 3 };
    let values = Reflect.values(obj);
    assert(values.len() == 3);
    assert(values.contains(1));
}

it("should enumerate object entries") {
    let obj = { "a": 1, "b": 2 };
    let entries = Reflect.entries(obj);
    assert(entries.len() == 2);
}

// ============================================================================
// ATTRIBUTE/ANNOTATION INSPECTION
// ============================================================================
// Note: Attributes inside function bodies are not yet supported by the parser.
// These tests are commented out until the feature is implemented.

// it("should get type attributes") {
//     @serializable
//     @deprecated("use NewType instead")
//     struct OldType { value: int }
//
//     let attrs = Reflect.attributes(OldType);
//     assert(attrs.contains("serializable"));
//     assert(attrs.contains("deprecated"));
// }

// it("should get attribute value") {
//     @version("1.0.0")
//     struct MyType {}
//
//     let version = Reflect.attribute(MyType, "version");
//     assert(version == "1.0.0");
// }

// ============================================================================
// MEMORY INSPECTION
// ============================================================================
// Note: Memory inspection features are not yet implemented

// it("should get size of type") {
//     struct Point { x: float, y: float }
//     let size = Reflect.sizeOf(Point);
//     assert(size == 16);  // Two 8-byte floats
// }

// it("should get alignment of type") {
//     struct Data { value: int }
//     let align = Reflect.alignOf(Data);
//     assert(align >= 4);
// }

// ============================================================================
// MODULE INSPECTION
// ============================================================================
// Note: Module inspection features are not yet implemented

// it("should list module exports") {
//     let exports = Reflect.moduleExports("Std.Math");
//     assert(exports.contains("sin"));
//     assert(exports.contains("cos"));
// }

// it("should check module loaded") {
//     assert(Reflect.isModuleLoaded("Std.Core") == true);
// }

// ============================================================================
// DYNAMIC INVOCATION
// ============================================================================
// Note: Dynamic invocation features are not yet implemented

// it("should call function dynamically") {
//     fn add(a: int, b: int): int { return a + b; }
//     let result = Reflect.call(add, [5, 3]);
//     assert(result == 8);
// }

// it("should apply function with array args") {
//     let f = |a, b, c| a + b + c;
//     let args = [1, 2, 3];
//     let result = Reflect.apply(f, args);
//     assert(result == 6);
// }

// ============================================================================
// TYPE CREATION
// ============================================================================
// Note: Dynamic type creation features are not yet implemented

// it("should create instance dynamically") {
//     struct Point { x: int, y: int }
//     let init_values = { "x": 10, "y": 20 };
//     let p = Reflect.create(Point, init_values);
//     assert(p.x == 10);
//     assert(p.y == 20);
// }

// it("should create array dynamically") {
//     let arr = Reflect.createArray("int", 5);
//     assert(arr.len() == 5);
// }

// ============================================================================
// PROXY AND INTERCEPT
// ============================================================================
// Note: Proxy features are not yet implemented

// it("should create proxy") {
//     let obj = { "value": 42 };
//
//     // Create handler functions
//     let get_handler = |target, prop| {
//         print("Accessing: " + prop);
//         return target[prop];
//     };
//     let set_handler = |target, prop, value| {
//         print("Setting " + prop + " to " + value);
//         target[prop] = value;
//     };
//
//     let proxy = Reflect.proxy(obj, get_handler, set_handler);
//     assert(proxy["value"] == 42);
// }

// ============================================================================
// STACK INSPECTION
// ============================================================================
// Note: Stack inspection features are not yet implemented

// it("should get call stack") {
//     fn inner() {
//         let stack = Reflect.callStack();
//         return stack;
//     }
//     fn outer() {
//         return inner();
//     }
//     let stack = outer();
//     assert(stack.len() >= 2);
// }

// it("should get caller info") {
//     fn get_caller() {
//         return Reflect.caller();
//     }
//     let caller = get_caller();
//     assert(caller.function != null);
// }
