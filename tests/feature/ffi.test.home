// Foreign Function Interface (FFI) Test Suite

// ============================================================================
// C LIBRARY LOADING
// ============================================================================

it("should load C library") {
    let lib = FFI.load("libc")
    assert(lib != null)
}

it("should load library by path") {
    let lib = FFI.load("/usr/lib/libm.dylib")
    assert(lib != null)
}

it("should handle library not found") {
    let result = FFI.load("nonexistent_library")
    assert(result == null or result.isErr())
}

// ============================================================================
// FUNCTION BINDING
// ============================================================================

it("should bind C function") {
    let lib = FFI.load("libc")
    let strlen = lib.bind("strlen", FFI.fn([FFI.ptr], FFI.sizeT))
    assert(strlen != null)
}

it("should call bound function") {
    let lib = FFI.load("libc")
    let strlen = lib.bind("strlen", FFI.fn([FFI.ptr], FFI.sizeT))
    let len = strlen("hello")
    assert(len == 5)
}

it("should bind function with multiple args") {
    let lib = FFI.load("libc")
    let strcmp = lib.bind("strcmp", FFI.fn([FFI.ptr, FFI.ptr], FFI.int))
    let result = strcmp("abc", "abc")
    assert(result == 0)
}

it("should bind void function") {
    let lib = FFI.load("libc")
    let free = lib.bind("free", FFI.fn([FFI.ptr], FFI.void))
    assert(free != null)
}

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

it("should define struct type") {
    let point = FFI.struct({
        x: FFI.double,
        y: FFI.double,
    })
    assert(point.size() == 16)  // Two 8-byte doubles
}

it("should define nested struct") {
    let inner = FFI.struct({ value: FFI.int })
    let outer = FFI.struct({
        data: inner,
        count: FFI.int,
    })
    assert(outer.size() >= 8)
}

it("should define union type") {
    let variant = FFI.union({
        as_int: FFI.int,
        as_float: FFI.float,
        as_bytes: FFI.array(FFI.char, 4),
    })
    assert(variant.size() == 4)
}

it("should define array type") {
    let arr_type = FFI.array(FFI.int, 10)
    assert(arr_type.size() == 40)  // 10 * 4 bytes
}

// ============================================================================
// PRIMITIVE TYPES
// ============================================================================

it("should have correct type sizes") {
    assert(FFI.char.size() == 1)
    assert(FFI.short.size() == 2)
    assert(FFI.int.size() == 4)
    assert(FFI.long.size() >= 4)
    assert(FFI.float.size() == 4)
    assert(FFI.double.size() == 8)
}

it("should support signed types") {
    assert(FFI.int8.size() == 1)
    assert(FFI.int16.size() == 2)
    assert(FFI.int32.size() == 4)
    assert(FFI.int64.size() == 8)
}

it("should support unsigned types") {
    assert(FFI.uint8.size() == 1)
    assert(FFI.uint16.size() == 2)
    assert(FFI.uint32.size() == 4)
    assert(FFI.uint64.size() == 8)
}

// ============================================================================
// POINTER OPERATIONS
// ============================================================================

it("should create pointer") {
    let data = 42
    let ptr = FFI.ptrTo(data)
    assert(ptr != null)
}

it("should dereference pointer") {
    let data = 42
    let ptr = FFI.ptrTo(data)
    let value = FFI.deref(ptr, FFI.int)
    assert(value == 42)
}

it("should handle null pointer") {
    let ptr = FFI.nullPtr()
    assert(FFI.isNull(ptr) == true)
}

it("should do pointer arithmetic") {
    let arr = [1, 2, 3, 4, 5]
    let ptr = FFI.ptrTo(arr)
    let offset_ptr = FFI.ptrOffset(ptr, 2, FFI.int)
    let value = FFI.deref(offset_ptr, FFI.int)
    assert(value == 3)
}

// ============================================================================
// MEMORY ALLOCATION
// ============================================================================

it("should allocate memory") {
    let ptr = FFI.malloc(1024)
    assert(ptr != null)
    FFI.free(ptr)
}

it("should allocate zeroed memory") {
    let ptr = FFI.calloc(10, FFI.int.size())
    let value = FFI.deref(ptr, FFI.int)
    assert(value == 0)
    FFI.free(ptr)
}

it("should reallocate memory") {
    let ptr = FFI.malloc(100)
    let new_ptr = FFI.realloc(ptr, 200)
    assert(new_ptr != null)
    FFI.free(new_ptr)
}

// ============================================================================
// STRING HANDLING
// ============================================================================

it("should convert string to C string") {
    let home_str = "hello"
    let c_str = FFI.toCString(home_str)
    assert(c_str != null)
}

it("should convert C string to string") {
    let lib = FFI.load("libc")
    let c_str = FFI.toCString("hello")
    let home_str = FFI.fromCString(c_str)
    assert(home_str == "hello")
}

it("should handle string with null bytes") {
    let c_str = FFI.toCString("hello\x00world")
    let home_str = FFI.fromCString(c_str)
    assert(home_str == "hello")  // Truncated at null
}

// ============================================================================
// STRUCT OPERATIONS
// ============================================================================

it("should create struct instance") {
    let Point = FFI.struct({ x: FFI.double, y: FFI.double })
    let p = Point.new({ x: 1.0, y: 2.0 })
    assert(p.x == 1.0)
    assert(p.y == 2.0)
}

it("should access struct fields") {
    let Point = FFI.struct({ x: FFI.int, y: FFI.int })
    let p = Point.new({ x: 10, y: 20 })
    assert(FFI.getField(p, "x") == 10)
}

it("should set struct fields") {
    let Point = FFI.struct({ x: FFI.int, y: FFI.int })
    let p = Point.new({ x: 0, y: 0 })
    FFI.setField(p, "x", 42)
    assert(p.x == 42)
}

it("should get struct field offset") {
    let Record = FFI.struct({
        a: FFI.char,
        b: FFI.int,
    })
    let offset = Record.offsetOf("b")
    assert(offset >= 1)  // After padding
}

// ============================================================================
// CALLBACKS
// ============================================================================

it("should create callback") {
    let callback = FFI.callback(FFI.fn([FFI.int, FFI.int], FFI.int), |a, b| {
        return a + b
    })
    assert(callback != null)
}

it("should pass callback to C") {
    let lib = FFI.load("libc")
    let qsort = lib.bind("qsort", FFI.fn([FFI.ptr, FFI.sizeT, FFI.sizeT, FFI.ptr], FFI.void))

    let compare = FFI.callback(FFI.fn([FFI.ptr, FFI.ptr], FFI.int), |a, b| {
        let va = FFI.deref(a, FFI.int)
        let vb = FFI.deref(b, FFI.int)
        return va - vb
    })

    let arr = [3, 1, 4, 1, 5]
    qsort(FFI.ptrTo(arr), 5, FFI.int.size(), compare)
}

// ============================================================================
// VARIADIC FUNCTIONS
// ============================================================================

it("should call variadic function") {
    let lib = FFI.load("libc")
    let sprintf = lib.bindVariadic("sprintf", FFI.fn([FFI.ptr, FFI.ptr], FFI.int))

    let buffer = FFI.malloc(100)
    sprintf(buffer, "%d + %d = %d", 1, 2, 3)
    let result = FFI.fromCString(buffer)
    assert(result == "1 + 2 = 3")
    FFI.free(buffer)
}

// ============================================================================
// ERRNO HANDLING
// ============================================================================

it("should get errno") {
    let err = FFI.errno()
    assert(err >= 0)
}

it("should set errno") {
    FFI.setErrno(0)
    assert(FFI.errno() == 0)
}

it("should get error string") {
    FFI.setErrno(2)  // ENOENT
    let msg = FFI.strerror(2)
    assert(msg.len() > 0)
}

// ============================================================================
// PLATFORM-SPECIFIC
// ============================================================================

it("should detect platform") {
    let platform = FFI.platform()
    assert(platform == "darwin" or platform == "linux" or platform == "windows")
}

it("should detect architecture") {
    let arch = FFI.arch()
    assert(arch == "x86_64" or arch == "aarch64" or arch == "arm64")
}

it("should detect endianness") {
    let endian = FFI.endianness()
    assert(endian == "little" or endian == "big")
}

// ============================================================================
// LIBRARY SYMBOLS
// ============================================================================

it("should check symbol exists") {
    let lib = FFI.load("libc")
    assert(lib.hasSymbol("strlen") == true)
    assert(lib.hasSymbol("nonexistent_symbol") == false)
}

it("should get symbol address") {
    let lib = FFI.load("libc")
    let addr = lib.symbolAddress("strlen")
    assert(addr != null)
}

// ============================================================================
// DATA CONVERSION
// ============================================================================

it("should convert bytes to struct") {
    let Point = FFI.struct({ x: FFI.int, y: FFI.int })
    let bytes = [0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00]
    let p = FFI.fromBytes(bytes, Point)
    assert(p.x == 1)
    assert(p.y == 2)
}

it("should convert struct to bytes") {
    let Point = FFI.struct({ x: FFI.int, y: FFI.int })
    let p = Point.new({ x: 1, y: 2 })
    let bytes = FFI.toBytes(p)
    assert(bytes.len() == 8)
}
