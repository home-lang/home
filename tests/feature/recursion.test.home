// Recursion Concepts Test Suite
// Testing recursion concepts using iterative implementations

// ============================================================================
// FACTORIAL (ITERATIVE)
// ============================================================================

it("should compute factorial of 0") {
    let mut result = 1;
    let n = 0;
    for (i in 1..(n + 1)) {
        result = result * i;
    }
    assert(result == 1);
}

it("should compute factorial of 1") {
    let mut result = 1;
    let n = 1;
    for (i in 1..(n + 1)) {
        result = result * i;
    }
    assert(result == 1);
}

it("should compute factorial of 5") {
    let mut result = 1;
    let n = 5;
    for (i in 1..(n + 1)) {
        result = result * i;
    }
    assert(result == 120);
}

it("should compute factorial of 6") {
    let mut result = 1;
    let n = 6;
    for (i in 1..(n + 1)) {
        result = result * i;
    }
    assert(result == 720);
}

// ============================================================================
// FIBONACCI (ITERATIVE)
// ============================================================================

it("should compute fibonacci 0") {
    let n = 0;
    let result = if (n == 0) { 0 } else { 1 };
    assert(result == 0);
}

it("should compute fibonacci 1") {
    let n = 1;
    let result = if (n <= 1) { n } else { 0 };
    assert(result == 1);
}

it("should compute fibonacci 6") {
    let n = 6;
    let mut a = 0;
    let mut b = 1;

    if (n == 0) {
        assert(a == 0);
    } else {
        for (i in 2..(n + 1)) {
            let temp = a + b;
            a = b;
            b = temp;
        }
        assert(b == 8);
    }
}

it("should compute fibonacci 10") {
    let n = 10;
    let mut a = 0;
    let mut b = 1;

    for (i in 2..(n + 1)) {
        let temp = a + b;
        a = b;
        b = temp;
    }

    assert(b == 55);
}

// ============================================================================
// SUM TO N (ITERATIVE)
// ============================================================================

it("should compute sum to 0") {
    let mut sum = 0;
    let n = 0;
    for (i in 1..(n + 1)) {
        sum = sum + i;
    }
    assert(sum == 0);
}

it("should compute sum to 5") {
    let mut sum = 0;
    let n = 5;
    for (i in 1..(n + 1)) {
        sum = sum + i;
    }
    assert(sum == 15);
}

it("should compute sum to 10") {
    let mut sum = 0;
    let n = 10;
    for (i in 1..(n + 1)) {
        sum = sum + i;
    }
    assert(sum == 55);
}

it("should compute sum to 100") {
    let mut sum = 0;
    let n = 100;
    for (i in 1..(n + 1)) {
        sum = sum + i;
    }
    assert(sum == 5050);
}

// ============================================================================
// POWER (ITERATIVE)
// ============================================================================

it("should compute power base 2 exp 0") {
    let base = 2;
    let exp = 0;
    let mut result = 1;
    for (i in 0..exp) {
        result = result * base;
    }
    assert(result == 1);
}

it("should compute power base 2 exp 3") {
    let base = 2;
    let exp = 3;
    let mut result = 1;
    for (i in 0..exp) {
        result = result * base;
    }
    assert(result == 8);
}

it("should compute power base 3 exp 4") {
    let base = 3;
    let exp = 4;
    let mut result = 1;
    for (i in 0..exp) {
        result = result * base;
    }
    assert(result == 81);
}

it("should compute power base 2 exp 8") {
    let base = 2;
    let exp = 8;
    let mut result = 1;
    for (i in 0..exp) {
        result = result * base;
    }
    assert(result == 256);
}

// ============================================================================
// GCD (ITERATIVE)
// ============================================================================

it("should compute GCD of 48 and 18") {
    let mut a = 48;
    let mut b = 18;
    while (b != 0) {
        let temp = b;
        b = a % b;
        a = temp;
    }
    assert(a == 6);
}

it("should compute GCD of 54 and 24") {
    let mut a = 54;
    let mut b = 24;
    while (b != 0) {
        let temp = b;
        b = a % b;
        a = temp;
    }
    assert(a == 6);
}

it("should compute GCD of 17 and 5") {
    let mut a = 17;
    let mut b = 5;
    while (b != 0) {
        let temp = b;
        b = a % b;
        a = temp;
    }
    assert(a == 1);
}

it("should compute GCD with zero") {
    let mut a = 0;
    let mut b = 5;
    while (b != 0) {
        let temp = b;
        b = a % b;
        a = temp;
    }
    assert(a == 5);
}

// ============================================================================
// LCM (USING GCD)
// ============================================================================

it("should compute LCM of 4 and 6") {
    let x = 4;
    let y = 6;
    let mut a = x;
    let mut b = y;
    while (b != 0) {
        let temp = b;
        b = a % b;
        a = temp;
    }
    let gcd = a;
    let lcm = (x * y) / gcd;
    assert(lcm == 12);
}

it("should compute LCM of 3 and 5") {
    let x = 3;
    let y = 5;
    let mut a = x;
    let mut b = y;
    while (b != 0) {
        let temp = b;
        b = a % b;
        a = temp;
    }
    let gcd = a;
    let lcm = (x * y) / gcd;
    assert(lcm == 15);
}

// ============================================================================
// COUNT DIGITS
// ============================================================================

it("should count digits of 1") {
    let mut n = 1;
    let mut count = 0;
    if (n == 0) {
        count = 1;
    } else {
        while (n > 0) {
            count = count + 1;
            n = n / 10;
        }
    }
    assert(count == 1);
}

it("should count digits of 123") {
    let mut n = 123;
    let mut count = 0;
    while (n > 0) {
        count = count + 1;
        n = n / 10;
    }
    assert(count == 3);
}

it("should count digits of 9999") {
    let mut n = 9999;
    let mut count = 0;
    while (n > 0) {
        count = count + 1;
        n = n / 10;
    }
    assert(count == 4);
}

// ============================================================================
// DIGIT SUM
// ============================================================================

it("should compute digit sum of 123") {
    let mut n = 123;
    let mut sum = 0;
    while (n > 0) {
        sum = sum + (n % 10);
        n = n / 10;
    }
    assert(sum == 6);
}

it("should compute digit sum of 999") {
    let mut n = 999;
    let mut sum = 0;
    while (n > 0) {
        sum = sum + (n % 10);
        n = n / 10;
    }
    assert(sum == 27);
}

// ============================================================================
// MULTIPLICATION AS REPEATED ADDITION
// ============================================================================

it("should multiply 3 by 4") {
    let a = 3;
    let b = 4;
    let mut result = 0;
    for (i in 0..b) {
        result = result + a;
    }
    assert(result == 12);
}

it("should multiply 5 by 5") {
    let a = 5;
    let b = 5;
    let mut result = 0;
    for (i in 0..b) {
        result = result + a;
    }
    assert(result == 25);
}

// ============================================================================
// ARRAY SUM (SIMULATING RECURSIVE PATTERN)
// ============================================================================

it("should sum array iteratively") {
    let arr = [1, 2, 3, 4, 5];
    let mut sum = 0;
    for (val in arr) {
        sum = sum + val;
    }
    assert(sum == 15);
}

it("should sum empty array") {
    let arr = [];
    let mut sum = 0;
    for (val in arr) {
        sum = sum + val;
    }
    assert(sum == 0);
}

// ============================================================================
// COLLATZ SEQUENCE STEPS
// ============================================================================

it("should compute collatz steps for 1") {
    let mut n = 1;
    let mut steps = 0;
    while (n != 1 or steps == 0) {
        if (n == 1) {
            // Already at 1
        } else if (n % 2 == 0) {
            n = n / 2;
            steps = steps + 1;
        } else {
            n = 3 * n + 1;
            steps = steps + 1;
        }
        if (n == 1) {
            break;
        }
    }
    assert(steps == 0);
}

it("should compute collatz steps for 2") {
    let mut n = 2;
    let mut steps = 0;
    while (n != 1) {
        if (n % 2 == 0) {
            n = n / 2;
        } else {
            n = 3 * n + 1;
        }
        steps = steps + 1;
    }
    assert(steps == 1);
}

it("should compute collatz steps for 4") {
    let mut n = 4;
    let mut steps = 0;
    while (n != 1) {
        if (n % 2 == 0) {
            n = n / 2;
        } else {
            n = 3 * n + 1;
        }
        steps = steps + 1;
    }
    assert(steps == 2);
}

// ============================================================================
// EVEN/ODD (SIMULATING MUTUAL RECURSION)
// ============================================================================

it("should check even numbers") {
    let n = 4;
    let is_even = n % 2 == 0;
    assert(is_even == true);
}

it("should check odd numbers") {
    let n = 5;
    let is_odd = n % 2 == 1;
    assert(is_odd == true);
}

it("should check zero is even") {
    let n = 0;
    let is_even = n % 2 == 0;
    assert(is_even == true);
}
