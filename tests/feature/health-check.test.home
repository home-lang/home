// Health Check Test Suite

// ============================================================================
// BASIC HEALTH CHECKS
// ============================================================================

it("should create health checker") {
    let health = health::Checker::new()
    assert(health != null)
}

it("should register check with function") {
    let health = health::Checker::new()

    // Define check function separately
    fn db_check() {
        return health::Result::healthy()
    }

    health.register("database", db_check)
    assert(health.checks().contains("database"))
}

it("should run health check") {
    let health = health::Checker::new()

    fn always_healthy() {
        return health::Result::healthy()
    }

    health.register("always_healthy", always_healthy)

    let result = health.check("always_healthy")
    assert(result.status == "healthy")
}

it("should run all checks") {
    let health = health::Checker::new()

    fn check1() { return health::Result::healthy() }
    fn check2() { return health::Result::healthy() }

    health.register("check1", check1)
    health.register("check2", check2)

    let results = health.check_all()
    assert(results.overall_status == "healthy")
}

// ============================================================================
// HEALTH RESULT TYPES
// ============================================================================

it("should return healthy result") {
    let result = health::Result::healthy()
    assert(result.status == "healthy")
}

it("should return healthy with details") {
    let details = {
        message: "Database connection pool healthy",
        connections: 10,
        max_connections: 20,
    }
    let result = health::Result::healthy(details)

    assert(result.status == "healthy")
    assert(result.details.connections == 10)
}

it("should return unhealthy result") {
    let result = health::Result::unhealthy("Connection failed")
    assert(result.status == "unhealthy")
    assert(result.message == "Connection failed")
}

it("should return degraded result") {
    let result = health::Result::degraded("High latency detected")
    assert(result.status == "degraded")
}

// ============================================================================
// COMMON CHECKS
// ============================================================================

it("should check database") {
    let health = health::Checker::new()

    let config = {
        connection_string: "postgresql://localhost/db",
        timeout: 5000,
    }
    let check = health::checks::postgres(config)
    health.register("postgres", check)
}

it("should check Redis") {
    let health = health::Checker::new()

    let config = {
        url: "redis://localhost:6379",
        timeout: 1000,
    }
    let check = health::checks::redis(config)
    health.register("redis", check)
}

it("should check HTTP endpoint") {
    let health = health::Checker::new()

    let config = {
        url: "https://api.example.com/health",
        expected_status: 200,
        timeout: 5000,
    }
    let check = health::checks::http(config)
    health.register("api", check)
}

it("should check disk space") {
    let health = health::Checker::new()

    let config = {
        path: "/",
        min_free_bytes: 1024 * 1024 * 100,
    }
    let check = health::checks::disk(config)
    health.register("disk", check)
}

it("should check memory") {
    let health = health::Checker::new()

    let config = {
        max_usage_percent: 90,
    }
    let check = health::checks::memory(config)
    health.register("memory", check)
}

it("should check CPU") {
    let health = health::Checker::new()

    let config = {
        max_usage_percent: 80,
        sample_duration: 1000,
    }
    let check = health::checks::cpu(config)
    health.register("cpu", check)
}

// ============================================================================
// CHECK CONFIGURATION
// ============================================================================

it("should set check timeout via config") {
    let health = health::Checker::new()

    fn check_with_timeout() {
        return health::Result::healthy()
    }

    let config = { timeout: 1000 }
    health.register_with_config("check_with_timeout", check_with_timeout, config)

    // Verify check was registered with config
    assert(health.checks().contains("check_with_timeout"))

    // Run the check - should return result
    let result = health.check("check_with_timeout")
    assert(result.status == "healthy")
}

it("should set check interval via config") {
    let health = health::Checker::new()

    fn periodic_check() {
        return health::Result::healthy()
    }

    let config = { interval: 30000 }
    health.register_with_config("periodic", periodic_check, config)
}

it("should set failure threshold") {
    let health = health::Checker::new()

    fn flaky_check() {
        return health::Result::healthy()
    }

    let config = { failure_threshold: 3 }
    health.register_with_config("flaky", flaky_check, config)
}

// ============================================================================
// LIVENESS VS READINESS
// ============================================================================

it("should distinguish liveness checks") {
    let health = health::Checker::new()

    fn process_check() {
        return health::Result::healthy()
    }

    let config = { check_type: "liveness" }
    health.register_with_config("process", process_check, config)

    let liveness = health.liveness_check()
    assert(liveness.status == "healthy")
}

it("should distinguish readiness checks") {
    let health = health::Checker::new()

    fn db_ready_check() {
        return health::Result::healthy()
    }

    let config = { check_type: "readiness" }
    health.register_with_config("database", db_ready_check, config)

    let readiness = health.readiness_check()
}

it("should support startup checks") {
    let health = health::Checker::new()

    fn init_check() {
        return health::Result::healthy()
    }

    let config = { check_type: "startup" }
    health.register_with_config("initialization", init_check, config)

    let startup = health.startup_check()
}

// ============================================================================
// AGGREGATION
// ============================================================================

it("should aggregate check results") {
    let health = health::Checker::new()

    fn healthy_check() { return health::Result::healthy() }
    fn another_check() { return health::Result::healthy() }

    health.register("check1", healthy_check)
    health.register("check2", another_check)

    // Verify both checks are registered
    let checks = health.checks()
    assert(checks.contains("check1"))
    assert(checks.contains("check2"))

    // Check aggregate returns expected structure
    let aggregate = health.check_all()
    assert(aggregate.overall_status != null)
    assert(aggregate.healthy_count >= 0)
    assert(aggregate.unhealthy_count >= 0)
}

it("should use custom aggregation strategy") {
    let config = {
        aggregation: "any_healthy",
    }
    let health = health::Checker::new(config)

    fn check1() { return health::Result::healthy() }
    fn check2() { return health::Result::healthy() }

    health.register("check1", check1)
    health.register("check2", check2)

    // Verify checks are registered
    assert(health.checks().contains("check1"))
    assert(health.checks().contains("check2"))

    // Aggregate should have expected structure
    let aggregate = health.check_all()
    assert(aggregate.overall_status != null)
}

// ============================================================================
// HTTP ENDPOINT
// ============================================================================

it("should create health endpoint") {
    let health = health::Checker::new()
    let handler = health.http_handler()
    assert(handler != null)
}

it("should return correct status codes") {
    let health = health::Checker::new()

    fn check() { return health::Result::healthy() }
    health.register("check", check)

    let handler = health.http_handler()
    // 200 for healthy
    // 503 for unhealthy
    // 429 for degraded
}

it("should customize endpoint path") {
    let health = health::Checker::new()
    let config = { path: "/healthz" }
    let handler = health.http_handler(config)
}

it("should separate endpoints") {
    let health = health::Checker::new()

    // Kubernetes-style endpoints
    let handlers = health.kubernetes_handlers()
    // handlers.liveness  -> /healthz
    // handlers.readiness -> /ready
    // handlers.startup   -> /startup
}

// ============================================================================
// CACHING
// ============================================================================

it("should cache results") {
    let config = { cache_ttl: 5000 }
    let health = health::Checker::new(config)

    fn expensive_check() {
        return health::Result::healthy()
    }

    health.register("expensive_check", expensive_check)
    // Second call within 5 seconds uses cached result
}

it("should force refresh") {
    let config = { cache_ttl: 60000 }
    let health = health::Checker::new(config)

    fn check() { return health::Result::healthy() }
    health.register("check", check)

    let result = health.check_force("check")
    // Ignores cache
}

// ============================================================================
// CALLBACKS AND HOOKS
// ============================================================================

it("should trigger callback on status change") {
    let health = health::Checker::new()
    let status_changes = []

    fn on_change(check_name, old_status, new_status) {
        status_changes.push({ check_name: check_name, old_status: old_status, new_status: new_status })
    }

    health.on_status_change(on_change)

    fn flaky() { return health::Result::healthy() }
    health.register("flaky", flaky)
}

it("should trigger callback on unhealthy") {
    let health = health::Checker::new()

    fn on_fail(check_name, result) {
        log::error("Health check failed: " + check_name)
    }

    health.on_unhealthy(on_fail)
}

it("should trigger recovery callback") {
    let health = health::Checker::new()

    fn on_recover(check_name) {
        log::info("Health check recovered: " + check_name)
    }

    health.on_recovery(on_recover)
}

// ============================================================================
// METRICS INTEGRATION
// ============================================================================

it("should export metrics") {
    let health = health::Checker::new()

    let metrics = health.metrics()
    assert(metrics.total_checks >= 0)
    assert(metrics.healthy_checks >= 0)
    assert(metrics.check_duration_ms >= 0)
}

it("should integrate with metrics collector") {
    let health = health::Checker::new()
    // Use Registry directly since metrics:: namespace prefix causes parsing issues
    let registry = Registry::new()

    health.register_metrics(registry)
    // Exports: health_check_status, health_check_duration_seconds
}

// ============================================================================
// DEPENDENCIES
// ============================================================================

it("should handle check dependencies") {
    let health = health::Checker::new()

    fn db_check() { return health::Result::healthy() }
    fn cache_check() { return health::Result::healthy() }

    health.register("database", db_check)
    let config = { depends_on: ["database"] }
    health.register_with_config("cache", cache_check, config)

    // Cache check skipped if database is unhealthy
}

it("should run checks in order") {
    let health = health::Checker::new()

    fn first_check() {
        return health::Result::healthy()
    }

    fn second_check() {
        return health::Result::healthy()
    }

    health.register("first", first_check)
    let config = { depends_on: ["first"] }
    health.register_with_config("second", second_check, config)

    // Verify both checks are registered
    let checks = health.checks()
    assert(checks.contains("first"))
    assert(checks.contains("second"))

    // check_all should return without error
    let result = health.check_all()
    assert(result != null)
}

// ============================================================================
// GRACEFUL SHUTDOWN
// ============================================================================

it("should mark as shutting down") {
    let health = health::Checker::new()

    health.start_shutdown()

    let result = health.readiness_check()
    assert(result.status == "unhealthy")
    assert(result.message.contains("shutting down"))
}

it("should delay shutdown for drain") {
    let config = { shutdown_delay: 10000 }
    let health = health::Checker::new(config)

    health.start_shutdown()
    // Waits 10 seconds before reporting unhealthy
}

// ============================================================================
// ASYNC CHECKS
// ============================================================================

it("should run async check") {
    let health = health::Checker::new()

    fn async_check() {
        let response = http::get("https://api.example.com/health")
        if response.status == 200 {
            return health::Result::healthy()
        } else {
            return health::Result::unhealthy("API down")
        }
    }

    health.register_async("async_check", async_check)
}

it("should run checks in parallel") {
    let config = { parallel: true }
    let health = health::Checker::new(config)

    fn check1() { time::sleep(1000); return health::Result::healthy() }
    fn check2() { time::sleep(1000); return health::Result::healthy() }
    fn check3() { time::sleep(1000); return health::Result::healthy() }

    health.register("check1", check1)
    health.register("check2", check2)
    health.register("check3", check3)

    let start = time::now()
    health.check_all()
    let duration = time::now() - start

    assert(duration < 2000)
}

// ============================================================================
// CUSTOM OUTPUT FORMAT
// ============================================================================

it("should output JSON format") {
    let health = health::Checker::new()

    fn test_check() { return health::Result::healthy() }
    health.register("test", test_check)

    let json = health.to_json()
    assert(json.contains("status"))
}

it("should output custom format") {
    let health = health::Checker::new()

    fn formatter(results) {
        return "Status: " + results.overall_status
    }

    let output = health.format(formatter)
}
