// Health Check Test Suite

// ============================================================================
// BASIC HEALTH CHECKS
// ============================================================================

it("should create health checker") {
    let health = Health.Checker.new()
    assert(health != null)
}

it("should register check with function") {
    let health = Health.Checker.new()

    // Define check function separately
    fn db_check() {
        return Health.Result.healthy()
    }

    health.register("database", db_check)
    assert(health.checks().contains("database"))
}

it("should run health check") {
    let health = Health.Checker.new()

    fn always_healthy() {
        return Health.Result.healthy()
    }

    health.register("always_healthy", always_healthy)

    let result = health.check("always_healthy")
    assert(result.status == "healthy")
}

it("should run all checks") {
    let health = Health.Checker.new()

    fn check1() { return Health.Result.healthy() }
    fn check2() { return Health.Result.healthy() }

    health.register("check1", check1)
    health.register("check2", check2)

    let results = health.checkAll()
    assert(results.overallStatus == "healthy")
}

// ============================================================================
// HEALTH RESULT TYPES
// ============================================================================

it("should return healthy result") {
    let result = Health.Result.healthy()
    assert(result.status == "healthy")
}

it("should return healthy with details") {
    let details = {
        message: "Database connection pool healthy",
        connections: 10,
        max_connections: 20,
    }
    let result = Health.Result.healthy(details)

    assert(result.status == "healthy")
    assert(result.details.connections == 10)
}

it("should return unhealthy result") {
    let result = Health.Result.unhealthy("Connection failed")
    assert(result.status == "unhealthy")
    assert(result.message == "Connection failed")
}

it("should return degraded result") {
    let result = Health.Result.degraded("High latency detected")
    assert(result.status == "degraded")
}

// ============================================================================
// COMMON CHECKS
// ============================================================================

it("should check database") {
    let health = Health.Checker.new()

    let config = {
        connection_string: "postgresql://localhost/db",
        timeout: 5000,
    }
    let check = Health.checks.postgres(config)
    health.register("postgres", check)
}

it("should check Redis") {
    let health = Health.Checker.new()

    let config = {
        url: "redis://localhost:6379",
        timeout: 1000,
    }
    let check = Health.checks.redis(config)
    health.register("redis", check)
}

it("should check HTTP endpoint") {
    let health = Health.Checker.new()

    let config = {
        url: "https://api.example.com/health",
        expected_status: 200,
        timeout: 5000,
    }
    let check = Health.checks.http(config)
    health.register("api", check)
}

it("should check disk space") {
    let health = Health.Checker.new()

    let config = {
        path: "/",
        min_free_bytes: 1024 * 1024 * 100,
    }
    let check = Health.checks.disk(config)
    health.register("disk", check)
}

it("should check memory") {
    let health = Health.Checker.new()

    let config = {
        max_usage_percent: 90,
    }
    let check = Health.checks.memory(config)
    health.register("memory", check)
}

it("should check CPU") {
    let health = Health.Checker.new()

    let config = {
        max_usage_percent: 80,
        sample_duration: 1000,
    }
    let check = Health.checks.cpu(config)
    health.register("cpu", check)
}

// ============================================================================
// CHECK CONFIGURATION
// ============================================================================

it("should set check timeout via config") {
    let health = Health.Checker.new()

    fn check_with_timeout() {
        return Health.Result.healthy()
    }

    let config = { timeout: 1000 }
    health.registerWithConfig("check_with_timeout", check_with_timeout, config)

    // Verify check was registered with config
    assert(health.checks().contains("check_with_timeout"))

    // Run the check - should return result
    let result = health.check("check_with_timeout")
    assert(result.status == "healthy")
}

it("should set check interval via config") {
    let health = Health.Checker.new()

    fn periodic_check() {
        return Health.Result.healthy()
    }

    let config = { interval: 30000 }
    health.registerWithConfig("periodic", periodic_check, config)
}

it("should set failure threshold") {
    let health = Health.Checker.new()

    fn flaky_check() {
        return Health.Result.healthy()
    }

    let config = { failure_threshold: 3 }
    health.registerWithConfig("flaky", flaky_check, config)
}

// ============================================================================
// LIVENESS VS READINESS
// ============================================================================

it("should distinguish liveness checks") {
    let health = Health.Checker.new()

    fn process_check() {
        return Health.Result.healthy()
    }

    let config = { check_type: "liveness" }
    health.registerWithConfig("process", process_check, config)

    let liveness = health.livenessCheck()
    assert(liveness.status == "healthy")
}

it("should distinguish readiness checks") {
    let health = Health.Checker.new()

    fn db_ready_check() {
        return Health.Result.healthy()
    }

    let config = { check_type: "readiness" }
    health.registerWithConfig("database", db_ready_check, config)

    let readiness = health.readinessCheck()
}

it("should support startup checks") {
    let health = Health.Checker.new()

    fn init_check() {
        return Health.Result.healthy()
    }

    let config = { check_type: "startup" }
    health.registerWithConfig("initialization", init_check, config)

    let startup = health.startupCheck()
}

// ============================================================================
// AGGREGATION
// ============================================================================

it("should aggregate check results") {
    let health = Health.Checker.new()

    fn healthy_check() { return Health.Result.healthy() }
    fn another_check() { return Health.Result.healthy() }

    health.register("check1", healthy_check)
    health.register("check2", another_check)

    // Verify both checks are registered
    let checks = health.checks()
    assert(checks.contains("check1"))
    assert(checks.contains("check2"))

    // Check aggregate returns expected structure
    let aggregate = health.checkAll()
    assert(aggregate.overallStatus != null)
    assert(aggregate.healthyCount >= 0)
    assert(aggregate.unhealthyCount >= 0)
}

it("should use custom aggregation strategy") {
    let config = {
        aggregation: "any_healthy",
    }
    let health = Health.Checker.new(config)

    fn check1() { return Health.Result.healthy() }
    fn check2() { return Health.Result.healthy() }

    health.register("check1", check1)
    health.register("check2", check2)

    // Verify checks are registered
    assert(health.checks().contains("check1"))
    assert(health.checks().contains("check2"))

    // Aggregate should have expected structure
    let aggregate = health.checkAll()
    assert(aggregate.overallStatus != null)
}

// ============================================================================
// HTTP ENDPOINT
// ============================================================================

it("should create health endpoint") {
    let health = Health.Checker.new()
    let handler = health.httpHandler()
    assert(handler != null)
}

it("should return http handler for healthy status") {
    let health = Health.Checker.new()

    fn check() { return Health.Result.healthy() }
    health.register("check", check)

    let handler = health.httpHandler()
    assert(handler != null)
}

it("should customize endpoint path") {
    let health = Health.Checker.new()
    let config = { path: "/healthz" }
    let handler = health.httpHandler(config)
    assert(handler != null)
}

it("should create kubernetes-style endpoints") {
    let health = Health.Checker.new()
    let handlers = health.kubernetesHandlers()
    assert(handlers != null)
}

// ============================================================================
// CACHING
// ============================================================================

it("should cache results with TTL") {
    let config = { cache_ttl: 5000 }
    let health = Health.Checker.new(config)

    fn expensive_check() {
        return Health.Result.healthy()
    }

    health.register("expensive_check", expensive_check)
    // First call should work
    let result = health.check("expensive_check")
    assert(result.status == "healthy")
}

it("should force refresh ignoring cache") {
    let config = { cache_ttl: 60000 }
    let health = Health.Checker.new(config)

    fn check() { return Health.Result.healthy() }
    health.register("check", check)

    let result = health.checkForce("check")
    assert(result.status == "healthy")
}

// ============================================================================
// CALLBACKS AND HOOKS
// ============================================================================

it("should register status change callback") {
    let health = Health.Checker.new()

    fn on_change(check_name, old_status, new_status) {
        // Callback registered
    }

    health.onStatusChange(on_change)
    assert(health != null)
}

it("should register unhealthy callback") {
    let health = Health.Checker.new()

    fn on_fail(check_name, result) {
        // Callback for failures
    }

    health.onUnhealthy(on_fail)
    assert(health != null)
}

it("should register recovery callback") {
    let health = Health.Checker.new()

    fn on_recover(check_name) {
        // Callback for recovery
    }

    health.onRecovery(on_recover)
    assert(health != null)
}

// ============================================================================
// METRICS INTEGRATION
// ============================================================================

it("should export metrics") {
    let health = Health.Checker.new()

    let metrics = health.metrics()
    assert(metrics.totalChecks >= 0)
    assert(metrics.healthyChecks >= 0)
    assert(metrics.checkDurationMs >= 0)
}

it("should integrate with metrics collector") {
    let health = Health.Checker.new()
    // Use Registry directly
    let registry = Registry.new()

    health.registerMetrics(registry)
    // Exports: health_check_status, health_check_duration_seconds
}

// ============================================================================
// DEPENDENCIES
// ============================================================================

it("should handle check dependencies") {
    let health = Health.Checker.new()

    fn db_check() { return Health.Result.healthy() }
    fn cache_check() { return Health.Result.healthy() }

    health.register("database", db_check)
    let config = { depends_on: ["database"] }
    health.registerWithConfig("cache", cache_check, config)

    // Cache check skipped if database is unhealthy
}

it("should run checks in order") {
    let health = Health.Checker.new()

    fn first_check() {
        return Health.Result.healthy()
    }

    fn second_check() {
        return Health.Result.healthy()
    }

    health.register("first", first_check)
    let config = { depends_on: ["first"] }
    health.registerWithConfig("second", second_check, config)

    // Verify both checks are registered
    let checks = health.checks()
    assert(checks.contains("first"))
    assert(checks.contains("second"))

    // check_all should return without error
    let result = health.checkAll()
    assert(result != null)
}

// ============================================================================
// GRACEFUL SHUTDOWN
// ============================================================================

it("should mark as shutting down") {
    let health = Health.Checker.new()

    health.startShutdown()

    let result = health.readinessCheck()
    assert(result.status == "unhealthy")
    assert(result.message.contains("shutting down"))
}

it("should support shutdown delay configuration") {
    let config = { shutdown_delay: 10000 }
    let health = Health.Checker.new(config)
    assert(health != null)
    health.startShutdown()
    assert(health != null)
}

// ============================================================================
// ASYNC CHECKS
// ============================================================================

it("should register async check") {
    let health = Health.Checker.new()

    fn async_check() {
        return Health.Result.healthy()
    }

    health.registerAsync("async_check", async_check)
    assert(health != null)
}

it("should run checks in parallel") {
    let config = { parallel: true }
    let health = Health.Checker.new(config)

    fn check1() { Time.sleep(1000); return Health.Result.healthy() }
    fn check2() { Time.sleep(1000); return Health.Result.healthy() }
    fn check3() { Time.sleep(1000); return Health.Result.healthy() }

    health.register("check1", check1)
    health.register("check2", check2)
    health.register("check3", check3)

    let start = Time.now()
    health.checkAll()
    let duration = Time.now() - start

    assert(duration < 2000)
}

// ============================================================================
// CUSTOM OUTPUT FORMAT
// ============================================================================

it("should output JSON format") {
    let health = Health.Checker.new()

    fn test_check() { return Health.Result.healthy() }
    health.register("test", test_check)

    let json = health.toJson()
    assert(json.contains("status"))
}

it("should support custom formatter") {
    let health = Health.Checker.new()

    fn formatter(results) {
        return "Status: " + results.overallStatus
    }

    let output = health.format(formatter)
    assert(health != null)
}
