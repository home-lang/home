// Event Emitter Test Suite

// ============================================================================
// BASIC EVENT EMISSION
// ============================================================================

it("should create event emitter") {
    let emitter = event::Emitter::new();
    assert(emitter != null);
}

it("should emit event") {
    let emitter = event::Emitter::new();
    let called = false;

    emitter.on("test", || {
        called = true;
    });

    emitter.emit("test");
    assert(called == true);
}

it("should pass data to handler") {
    let emitter = event::Emitter::new();
    let received = null;

    emitter.on("data", |data| {
        received = data;
    });

    emitter.emit("data", { value: 42 });
    assert(received["value"] == 42);
}

// ============================================================================
// MULTIPLE LISTENERS
// ============================================================================

it("should call multiple listeners") {
    let emitter = event::Emitter::new();
    let count = 0;

    emitter.on("event", || count += 1);
    emitter.on("event", || count += 1);
    emitter.on("event", || count += 1);

    emitter.emit("event");
    assert(count == 3);
}

it("should call listeners in order") {
    let emitter = event::Emitter::new();
    let order = [];

    emitter.on("event", || order.push(1));
    emitter.on("event", || order.push(2));
    emitter.on("event", || order.push(3));

    emitter.emit("event");
    assert(order == [1, 2, 3]);
}

// ============================================================================
// ONCE LISTENERS
// ============================================================================

it("should fire once listener only once") {
    let emitter = event::Emitter::new();
    let count = 0;

    emitter.once("event", || count += 1);

    emitter.emit("event");
    emitter.emit("event");
    emitter.emit("event");

    assert(count == 1);
}

it("should mix once and on listeners") {
    let emitter = event::Emitter::new();
    let once_count = 0;
    let on_count = 0;

    emitter.once("event", || once_count += 1);
    emitter.on("event", || on_count += 1);

    emitter.emit("event");
    emitter.emit("event");

    assert(once_count == 1);
    assert(on_count == 2);
}

// ============================================================================
// REMOVING LISTENERS
// ============================================================================

it("should remove specific listener") {
    let emitter = event::Emitter::new();
    let count = 0;

    let handler = || count += 1;
    emitter.on("event", handler);
    emitter.emit("event");
    emitter.off("event", handler);
    emitter.emit("event");

    assert(count == 1);
}

it("should remove all listeners for event") {
    let emitter = event::Emitter::new();
    let count = 0;

    emitter.on("event", || count += 1);
    emitter.on("event", || count += 1);

    emitter.remove_all_listeners("event");
    emitter.emit("event");

    assert(count == 0);
}

it("should remove all listeners") {
    let emitter = event::Emitter::new();
    let count = 0;

    emitter.on("event1", || count += 1);
    emitter.on("event2", || count += 1);

    emitter.remove_all_listeners();
    emitter.emit("event1");
    emitter.emit("event2");

    assert(count == 0);
}

// ============================================================================
// LISTENER COUNT
// ============================================================================

it("should count listeners") {
    let emitter = event::Emitter::new();

    emitter.on("event", || {});
    emitter.on("event", || {});

    assert(emitter.listener_count("event") == 2);
}

it("should return zero for no listeners") {
    let emitter = event::Emitter::new();
    assert(emitter.listener_count("event") == 0);
}

it("should list event names") {
    let emitter = event::Emitter::new();

    emitter.on("event1", || {});
    emitter.on("event2", || {});

    let names = emitter.event_names();
    assert(names.contains("event1"));
    assert(names.contains("event2"));
}

// ============================================================================
// PREPEND LISTENERS
// ============================================================================

it("should prepend listener") {
    let emitter = event::Emitter::new();
    let order = [];

    emitter.on("event", || order.push(1));
    emitter.prepend("event", || order.push(0));

    emitter.emit("event");
    assert(order == [0, 1]);
}

it("should prepend once listener") {
    let emitter = event::Emitter::new();
    let order = [];

    emitter.on("event", || order.push(1));
    emitter.prepend_once("event", || order.push(0));

    emitter.emit("event");
    emitter.emit("event");

    assert(order == [0, 1, 1]);
}

// ============================================================================
// ERROR HANDLING
// ============================================================================

it("should emit error event") {
    let emitter = event::Emitter::new();
    let error_received = false;

    emitter.on("error", |err| {
        error_received = true;
    });

    emitter.emit("error", Error::new("test error"));
    assert(error_received == true);
}

it("should throw on unhandled error") {
    let emitter = event::Emitter::new();
    // Without error handler, emitting error should throw
}

// ============================================================================
// MAX LISTENERS
// ============================================================================

it("should set max listeners") {
    let emitter = event::Emitter::new();
    emitter.set_max_listeners(5);
    assert(emitter.max_listeners() == 5);
}

it("should warn on too many listeners") {
    let emitter = event::Emitter::new();
    emitter.set_max_listeners(2);

    emitter.on("event", || {});
    emitter.on("event", || {});
    // Third listener should warn
    emitter.on("event", || {});
}

// ============================================================================
// ASYNC EVENTS
// ============================================================================

it("should emit async event") {
    let emitter = event::Emitter::new();
    let completed = false;

    emitter.on("async", async || {
        await sleep(10.milliseconds);
        completed = true;
    });

    await emitter.emit_async("async");
    assert(completed == true);
}

it("should wait for all async handlers") {
    let emitter = event::Emitter::new();
    let results = [];

    emitter.on("event", async || {
        await sleep(20.milliseconds);
        results.push(1);
    });

    emitter.on("event", async || {
        await sleep(10.milliseconds);
        results.push(2);
    });

    await emitter.emit_async("event");
    assert(results.len() == 2);
}

// ============================================================================
// WILDCARD EVENTS
// ============================================================================

it("should match wildcard pattern") {
    let emitter = event::WildcardEmitter::new();
    let received = [];

    emitter.on("user.*", |event| {
        received.push(event);
    });

    emitter.emit("user.created", {});
    emitter.emit("user.updated", {});
    emitter.emit("user.deleted", {});

    assert(received.len() == 3);
}

it("should match deep wildcard") {
    let emitter = event::WildcardEmitter::new();
    let count = 0;

    emitter.on("api.**", || count += 1);

    emitter.emit("api.users.create", {});
    emitter.emit("api.orders.list", {});

    assert(count == 2);
}

// ============================================================================
// NAMESPACED EVENTS
// ============================================================================

it("should use namespaced events") {
    let emitter = event::Emitter::new();
    let count = 0;

    emitter.on("click.button", || count += 1);
    emitter.on("click.link", || count += 1);

    emitter.emit("click.button");
    assert(count == 1);
}

it("should remove by namespace") {
    let emitter = event::Emitter::new();
    let count = 0;

    emitter.on("event.ns1", || count += 1);
    emitter.on("event.ns2", || count += 1);

    emitter.off_namespace("ns1");
    emitter.emit("event.ns1");
    emitter.emit("event.ns2");

    assert(count == 1);
}

// ============================================================================
// EVENT PRIORITY
// ============================================================================

it("should respect listener priority") {
    let emitter = event::PriorityEmitter::new();
    let order = [];

    emitter.on("event", priority: 1, || order.push("low"));
    emitter.on("event", priority: 10, || order.push("high"));
    emitter.on("event", priority: 5, || order.push("medium"));

    emitter.emit("event");
    assert(order == ["high", "medium", "low"]);
}

// ============================================================================
// STOP PROPAGATION
// ============================================================================

it("should stop propagation") {
    let emitter = event::Emitter::new();
    let order = [];

    emitter.on("event", |e| {
        order.push(1);
        e.stop_propagation();
    });

    emitter.on("event", || order.push(2));

    emitter.emit("event");
    assert(order == [1]);
}

// ============================================================================
// EVENT OBJECT
// ============================================================================

it("should provide event metadata") {
    let emitter = event::Emitter::new();
    let event_name = null;
    let event_time = null;

    emitter.on("test", |e| {
        event_name = e.name;
        event_time = e.timestamp;
    });

    emitter.emit("test");
    assert(event_name == "test");
    assert(event_time != null);
}

// ============================================================================
// PIPE EVENTS
// ============================================================================

it("should pipe events to another emitter") {
    let source = event::Emitter::new();
    let target = event::Emitter::new();
    let received = false;

    source.pipe("data", target);
    target.on("data", || received = true);

    source.emit("data");
    assert(received == true);
}

// ============================================================================
// GLOBAL EVENT BUS
// ============================================================================

it("should use global event bus") {
    event::global().on("app:ready", || {});
    event::global().emit("app:ready");
}

// ============================================================================
// TYPED EVENTS
// ============================================================================

it("should use typed events") {
    struct UserCreatedEvent {
        user_id: int,
        name: string,
    }

    let emitter = event::TypedEmitter::new();
    let received = null;

    emitter.on[UserCreatedEvent](|e| {
        received = e;
    });

    emitter.emit(UserCreatedEvent { user_id: 1, name: "Alice" });
    assert(received.name == "Alice");
}

