// Comprehensions Test Suite
// Tests array comprehensions and generator expressions

// ============================================================================
// BASIC ARRAY COMPREHENSIONS
// ============================================================================

it("should create array with simple comprehension") {
    let arr = [x for x in 0..5];
    assert(arr.len() == 5);
    assert(arr[0] == 0);
    assert(arr[4] == 4);
}

it("should transform elements in comprehension") {
    let arr = [x * 2 for x in 0..5];
    assert(arr[0] == 0);
    assert(arr[1] == 2);
    assert(arr[2] == 4);
    assert(arr[3] == 6);
    assert(arr[4] == 8);
}

it("should filter elements in comprehension") {
    let arr = [x for x in 0..10 if x % 2 == 0];
    assert(arr.len() == 5);
    assert(arr[0] == 0);
    assert(arr[1] == 2);
    assert(arr[2] == 4);
}

it("should transform and filter") {
    let arr = [x * x for x in 0..10 if x % 2 == 1];
    assert(arr.len() == 5);
    assert(arr[0] == 1);   // 1*1
    assert(arr[1] == 9);   // 3*3
    assert(arr[2] == 25);  // 5*5
    assert(arr[3] == 49);  // 7*7
    assert(arr[4] == 81);  // 9*9
}

// ============================================================================
// COMPREHENSION WITH EXISTING ARRAY
// ============================================================================

it("should comprehend from existing array") {
    let source = [1, 2, 3, 4, 5];
    let doubled = [x * 2 for x in source];
    assert(doubled.len() == 5);
    assert(doubled[0] == 2);
    assert(doubled[4] == 10);
}

it("should filter from existing array") {
    let source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let evens = [x for x in source if x % 2 == 0];
    assert(evens.len() == 5);
    assert(evens[0] == 2);
    assert(evens[4] == 10);
}

it("should transform strings in comprehension") {
    let names = ["alice", "bob", "charlie"];
    let upper = [name.to_upper() for name in names];
    assert(upper[0] == "ALICE");
    assert(upper[1] == "BOB");
    assert(upper[2] == "CHARLIE");
}

// ============================================================================
// NESTED COMPREHENSIONS
// ============================================================================

it("should create nested array with comprehension") {
    let matrix = [[i * j for j in 0..3] for i in 0..3];
    assert(matrix[0][0] == 0);
    assert(matrix[1][1] == 1);
    assert(matrix[2][2] == 4);
}

it("should flatten with nested comprehension") {
    let pairs = [[i, j] for i in 0..2 for j in 0..2];
    assert(pairs.len() == 4);
}

it("should create cartesian product") {
    let xs = [1, 2];
    let ys = [3, 4];
    let product = [(x, y) for x in xs for y in ys];
    assert(product.len() == 4);
    assert(product[0] == (1, 3));
    assert(product[1] == (1, 4));
    assert(product[2] == (2, 3));
    assert(product[3] == (2, 4));
}

// ============================================================================
// COMPREHENSION WITH COMPLEX EXPRESSIONS
// ============================================================================

it("should use complex expression in comprehension") {
    let arr = [x * x + 2 * x + 1 for x in 0..5];  // (x+1)^2
    assert(arr[0] == 1);   // 1
    assert(arr[1] == 4);   // 4
    assert(arr[2] == 9);   // 9
    assert(arr[3] == 16);  // 16
    assert(arr[4] == 25);  // 25
}

it("should use function call in comprehension") {
    fn square(x: i32): i32 { return x * x; }
    let arr = [square(x) for x in 1..6];
    assert(arr[0] == 1);
    assert(arr[1] == 4);
    assert(arr[2] == 9);
    assert(arr[3] == 16);
    assert(arr[4] == 25);
}

it("should use method call in comprehension") {
    let strings = ["hello", "world", "test"];
    let lengths = [s.len() for s in strings];
    assert(lengths[0] == 5);
    assert(lengths[1] == 5);
    assert(lengths[2] == 4);
}

// ============================================================================
// COMPREHENSION WITH CONDITIONALS
// ============================================================================

it("should use ternary in comprehension") {
    let arr = [if (x % 2 == 0) { x } else { -x } for x in 0..5];
    assert(arr[0] == 0);
    assert(arr[1] == -1);
    assert(arr[2] == 2);
    assert(arr[3] == -3);
    assert(arr[4] == 4);
}

it("should use complex filter condition") {
    let arr = [x for x in 0..100 if x % 3 == 0 and x % 5 == 0];
    assert(arr[0] == 0);
    assert(arr[1] == 15);
    assert(arr[2] == 30);
    assert(arr[3] == 45);
}

it("should use or condition in filter") {
    let arr = [x for x in 0..20 if x % 3 == 0 or x % 5 == 0];
    assert(arr.contains(0));
    assert(arr.contains(3));
    assert(arr.contains(5));
    assert(arr.contains(15));
}

// ============================================================================
// COMPREHENSION WITH STRUCTS
// ============================================================================

struct Point { x: i32, y: i32 }

it("should create structs in comprehension") {
    let points = [Point { x: i, y: i * 2 } for i in 0..3];
    assert(points[0].x == 0);
    assert(points[0].y == 0);
    assert(points[1].x == 1);
    assert(points[1].y == 2);
    assert(points[2].x == 2);
    assert(points[2].y == 4);
}

it("should extract from structs in comprehension") {
    let points = [Point { x: 1, y: 10 }, Point { x: 2, y: 20 }, Point { x: 3, y: 30 }];
    let ys = [p.y for p in points];
    assert(ys[0] == 10);
    assert(ys[1] == 20);
    assert(ys[2] == 30);
}

it("should filter structs in comprehension") {
    let points = [Point { x: i, y: i * 2 } for i in 0..10];
    let filtered = [p for p in points if p.x > 5];
    assert(filtered.len() == 4);
    assert(filtered[0].x == 6);
}

// ============================================================================
// COMPREHENSION WITH ENUMS
// ============================================================================

enum Status {
    Active(i32),
    Inactive
}

it("should create enums in comprehension") {
    let statuses = [Status.Active(i) for i in 1..4];
    let first = match (statuses[0]) {
        Status.Active(n) => n,
        Status.Inactive => 0,
    };
    assert(first == 1);
}

// ============================================================================
// COMPREHENSION WITH TUPLES
// ============================================================================

it("should create tuples in comprehension") {
    let pairs = [(i, i * i) for i in 0..5];
    assert(pairs[0] == (0, 0));
    assert(pairs[1] == (1, 1));
    assert(pairs[2] == (2, 4));
    assert(pairs[3] == (3, 9));
    assert(pairs[4] == (4, 16));
}

it("should destructure tuples in comprehension") {
    let pairs = [(1, 2), (3, 4), (5, 6)];
    let sums = [a + b for (a, b) in pairs];
    assert(sums[0] == 3);
    assert(sums[1] == 7);
    assert(sums[2] == 11);
}

// ============================================================================
// SET COMPREHENSION
// ============================================================================

it("should create set with comprehension") {
    let set = {x % 5 for x in 0..20};
    assert(set.len() == 5);
    assert(set.contains(0));
    assert(set.contains(1));
    assert(set.contains(2));
    assert(set.contains(3));
    assert(set.contains(4));
}

// ============================================================================
// MAP/DICT COMPREHENSION
// ============================================================================

it("should create map with comprehension") {
    let map = {to_string(i): i * i for i in 1..4};
    assert(map["1"] == 1);
    assert(map["2"] == 4);
    assert(map["3"] == 9);
}

it("should filter map comprehension") {
    let map = {to_string(i): i for i in 1..10 if i % 2 == 0};
    assert(map.len() == 4);
    assert(map["2"] == 2);
    assert(map["4"] == 4);
    assert(map.contains_key("1") == false);
}

it("should transform map keys and values") {
    let source = {"a": 1, "b": 2, "c": 3};
    let transformed = {k.to_upper(): v * 10 for (k, v) in source};
    assert(transformed["A"] == 10);
    assert(transformed["B"] == 20);
    assert(transformed["C"] == 30);
}

// ============================================================================
// GENERATOR EXPRESSIONS
// ============================================================================

it("should use generator expression lazily") {
    let gen = (x * 2 for x in 0..1000000);
    let first = gen.next();
    assert(first == Some(0));
    let second = gen.next();
    assert(second == Some(2));
}

it("should collect generator to array") {
    let gen = (x for x in 0..5);
    let arr = gen.collect();
    assert(arr.len() == 5);
}

it("should filter in generator") {
    let gen = (x for x in 0..10 if x % 2 == 0);
    let arr = gen.collect();
    assert(arr.len() == 5);
    assert(arr[0] == 0);
    assert(arr[4] == 8);
}

// ============================================================================
// COMPREHENSION EDGE CASES
// ============================================================================

it("should handle empty range comprehension") {
    let arr = [x for x in 0..0];
    assert(arr.len() == 0);
}

it("should handle filter that removes all") {
    let arr = [x for x in 0..10 if x > 100];
    assert(arr.len() == 0);
}

it("should handle single element comprehension") {
    let arr = [x for x in 0..1];
    assert(arr.len() == 1);
    assert(arr[0] == 0);
}

it("should handle comprehension with negative range") {
    let arr = [x for x in -5..0];
    assert(arr.len() == 5);
    assert(arr[0] == -5);
    assert(arr[4] == -1);
}

it("should handle index and element") {
    let source = ["a", "b", "c"];
    let indexed = [(i, s) for (i, s) in source.enumerate()];
    assert(indexed[0] == (0, "a"));
    assert(indexed[1] == (1, "b"));
    assert(indexed[2] == (2, "c"));
}

// ============================================================================
// COMPREHENSION PERFORMANCE PATTERNS
// ============================================================================

it("should chain comprehensions") {
    let arr = [x * 2 for x in [y + 1 for y in 0..5]];
    assert(arr[0] == 2);   // (0+1)*2
    assert(arr[1] == 4);   // (1+1)*2
    assert(arr[2] == 6);   // (2+1)*2
}

it("should use comprehension result directly") {
    let sum = [x for x in 0..5].reduce(0, |acc, x| acc + x);
    assert(sum == 10);
}

it("should filter then transform") {
    let result = [x * x for x in [y for y in 0..10 if y % 2 == 0]];
    assert(result[0] == 0);
    assert(result[1] == 4);
    assert(result[2] == 16);
    assert(result[3] == 36);
    assert(result[4] == 64);
}

// ============================================================================
// STRING COMPREHENSIONS
// ============================================================================

it("should build string array from chars") {
    let s = "hello";
    let chars = [c for c in s.chars()];
    assert(chars.len() == 5);
    assert(chars[0] == 'h');
    assert(chars[4] == 'o');
}

it("should filter chars") {
    let s = "a1b2c3";
    let letters = [c for c in s.chars() if c.is_alpha()];
    assert(letters.len() == 3);
    assert(letters[0] == 'a');
    assert(letters[1] == 'b');
    assert(letters[2] == 'c');
}

// ============================================================================
// COMPREHENSION WITH MULTIPLE CONDITIONS
// ============================================================================

it("should use multiple if conditions") {
    let arr = [x for x in 0..100 if x > 10 if x < 20 if x % 2 == 0];
    assert(arr.len() == 4);
    assert(arr[0] == 12);
    assert(arr[1] == 14);
    assert(arr[2] == 16);
    assert(arr[3] == 18);
}

// ============================================================================
// COMPREHENSION IN FUNCTIONS
// ============================================================================

fn generate_squares(n: i32): [i32] {
    return [x * x for x in 0..n];
}

it("should use comprehension in function") {
    let squares = generate_squares(5);
    assert(squares[0] == 0);
    assert(squares[1] == 1);
    assert(squares[2] == 4);
    assert(squares[3] == 9);
    assert(squares[4] == 16);
}

fn filter_positives(arr: [i32]): [i32] {
    return [x for x in arr if x > 0];
}

it("should filter with comprehension in function") {
    let result = filter_positives([-1, 0, 1, 2, -3, 4]);
    assert(result.len() == 3);
    assert(result[0] == 1);
    assert(result[1] == 2);
    assert(result[2] == 4);
}

// ============================================================================
// COMPREHENSION WITH LET BINDINGS
// ============================================================================

it("should use let binding in comprehension") {
    let arr = [y for x in 0..5 let y = x * x + 1];
    assert(arr[0] == 1);
    assert(arr[1] == 2);
    assert(arr[2] == 5);
    assert(arr[3] == 10);
    assert(arr[4] == 17);
}

it("should use multiple let bindings") {
    let arr = [z for x in 1..4 let y = x * 2 let z = y + 1];
    assert(arr[0] == 3);   // 1*2+1
    assert(arr[1] == 5);   // 2*2+1
    assert(arr[2] == 7);   // 3*2+1
}

