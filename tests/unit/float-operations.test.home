// Floating Point Operations Unit Tests

// ============================================================================
// BASIC ARITHMETIC
// ============================================================================

it("should add floats") {
    assert((1.5 + 2.5) == 4.0);
    assert((0.1 + 0.2) > 0.29);  // Floating point approximation
    assert((0.1 + 0.2) < 0.31);
}

it("should subtract floats") {
    assert((5.5 - 2.5) == 3.0);
    assert((1.0 - 0.3) > 0.69);
    assert((1.0 - 0.3) < 0.71);
}

it("should multiply floats") {
    assert((2.5 * 4.0) == 10.0);
    assert((0.5 * 0.5) == 0.25);
    assert((3.0 * -2.0) == -6.0);
}

it("should divide floats") {
    assert((10.0 / 4.0) == 2.5);
    assert((1.0 / 3.0) > 0.333);
    assert((1.0 / 3.0) < 0.334);
}

// ============================================================================
// SPECIAL VALUES
// ============================================================================

it("should handle positive zero") {
    let z = 0.0;
    assert(z == 0.0);
    assert(z >= 0.0);
}

it("should handle negative zero") {
    let nz = -0.0;
    assert(nz == 0.0);  // Negative zero equals positive zero
    assert(nz == -0.0);
}

it("should handle infinity") {
    let inf = 1.0 / 0.0;
    assert(inf > 1000000.0);
    assert(inf == inf);
}

it("should handle negative infinity") {
    let neg_inf = -1.0 / 0.0;
    assert(neg_inf < -1000000.0);
}

it("should handle NaN") {
    let nan = 0.0 / 0.0;
    assert(nan != nan);  // NaN is not equal to itself
}

// ============================================================================
// COMPARISON OPERATIONS
// ============================================================================

it("should compare floats with less than") {
    assert(1.5 < 2.0);
    assert(-1.0 < 0.0);
    assert(0.0 < 0.001);
}

it("should compare floats with greater than") {
    assert(2.0 > 1.5);
    assert(0.0 > -1.0);
    assert(0.001 > 0.0);
}

it("should compare floats with equality") {
    assert(1.5 == 1.5);
    assert(0.0 == -0.0);
}

it("should handle approximate equality") {
    let a = 0.1 + 0.2;
    let b = 0.3;
    let epsilon = 0.0001;
    assert((a - b).abs() < epsilon);
}

// ============================================================================
// MATH FUNCTIONS
// ============================================================================

it("should compute absolute value") {
    assert((-5.5).abs() == 5.5);
    assert((5.5).abs() == 5.5);
    assert((0.0).abs() == 0.0);
}

it("should compute floor") {
    assert((3.7).floor() == 3.0);
    assert((3.2).floor() == 3.0);
    assert((-3.7).floor() == -4.0);
}

it("should compute ceiling") {
    assert((3.2).ceil() == 4.0);
    assert((3.7).ceil() == 4.0);
    assert((-3.2).ceil() == -3.0);
}

it("should compute round") {
    assert((3.4).round() == 3.0);
    assert((3.5).round() == 4.0);
    assert((3.6).round() == 4.0);
    assert((-3.5).round() == -4.0);
}

it("should compute truncate") {
    assert((3.7).trunc() == 3.0);
    assert((-3.7).trunc() == -3.0);
}

it("should compute square root") {
    assert((4.0).sqrt() == 2.0);
    assert((9.0).sqrt() == 3.0);
    assert((2.0).sqrt() > 1.41);
    assert((2.0).sqrt() < 1.42);
}

it("should compute power") {
    assert((2.0).pow(3.0) == 8.0);
    assert((2.0).pow(0.5) > 1.41);  // Square root
    assert((10.0).pow(2.0) == 100.0);
}

it("should compute exponential") {
    assert((0.0).exp() == 1.0);
    assert((1.0).exp() > 2.71);
    assert((1.0).exp() < 2.72);
}

it("should compute natural logarithm") {
    assert((1.0).ln() == 0.0);
    let e = (1.0).exp();
    assert(e.ln() > 0.99);
    assert(e.ln() < 1.01);
}

it("should compute log base 10") {
    assert((10.0).log10() == 1.0);
    assert((100.0).log10() == 2.0);
    assert((1000.0).log10() == 3.0);
}

it("should compute log base 2") {
    assert((2.0).log2() == 1.0);
    assert((8.0).log2() == 3.0);
    assert((16.0).log2() == 4.0);
}

// ============================================================================
// TRIGONOMETRIC FUNCTIONS
// ============================================================================

it("should compute sine") {
    assert((0.0).sin() == 0.0);
    let pi = 3.14159265359;
    assert((pi).sin().abs() < 0.0001);  // sin(pi) ≈ 0
    assert((pi / 2.0).sin() > 0.99);    // sin(pi/2) = 1
}

it("should compute cosine") {
    assert((0.0).cos() == 1.0);
    let pi = 3.14159265359;
    assert((pi).cos() < -0.99);         // cos(pi) = -1
    assert((pi / 2.0).cos().abs() < 0.0001);  // cos(pi/2) ≈ 0
}

it("should compute tangent") {
    assert((0.0).tan() == 0.0);
    let pi = 3.14159265359;
    assert((pi / 4.0).tan() > 0.99);    // tan(pi/4) = 1
    assert((pi / 4.0).tan() < 1.01);
}

// ============================================================================
// CONVERSION
// ============================================================================

it("should convert int to float") {
    let i = 42;
    let f = i.to_float();
    assert(f == 42.0);
}

it("should convert float to int (truncate)") {
    assert((3.7).to_int() == 3);
    assert((-3.7).to_int() == -3);
    assert((0.9).to_int() == 0);
}

it("should parse float from string") {
    assert("3.14".parse_float() == 3.14);
    assert("-2.5".parse_float() == -2.5);
    assert("0.0".parse_float() == 0.0);
}

it("should format float to string") {
    assert((3.14).to_string().starts_with("3.14"));
    assert((-2.5).to_string() == "-2.5");
}

// ============================================================================
// EDGE CASES
// ============================================================================

it("should handle very small numbers") {
    let small = 0.0000001;
    assert(small > 0.0);
    assert(small * 1000000 > 0.09);
}

it("should handle very large numbers") {
    let large = 1e10;
    assert(large == 10000000000.0);
    assert(large / 1e5 == 100000.0);
}

it("should handle subnormal numbers") {
    let tiny = 1e-300;
    assert(tiny > 0.0);
    assert(tiny * 1e300 > 0.5);
}

// ============================================================================
// FLOATING POINT PRECISION
// ============================================================================

it("should accumulate without excessive error") {
    let mut sum = 0.0;
    for (_ in 0..1000) {
        sum = sum + 0.001;
    }
    assert(sum > 0.99);
    assert(sum < 1.01);
}

it("should use Kahan summation for precision") {
    fn kahan_sum(arr: [f64]): f64 {
        let mut sum = 0.0;
        let mut c = 0.0;  // Compensation for lost low-order bits
        for (x in arr) {
            let y = x - c;
            let t = sum + y;
            c = (t - sum) - y;
            sum = t;
        }
        return sum;
    }

    let values = [0.1, 0.2, 0.3, 0.4];
    let result = kahan_sum(values);
    assert(result > 0.99);
    assert(result < 1.01);
}

// ============================================================================
// OPERATOR PRECEDENCE
// ============================================================================

it("should follow operator precedence") {
    assert((2.0 + 3.0 * 4.0) == 14.0);
    assert(((2.0 + 3.0) * 4.0) == 20.0);
    assert((10.0 - 2.0 / 2.0) == 9.0);
}

it("should handle mixed int and float") {
    assert((2 + 3.0) == 5.0);
    assert((10.0 / 4) == 2.5);
    assert((3 * 2.5) == 7.5);
}
