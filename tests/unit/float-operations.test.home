// Floating Point Operations Unit Tests

// ============================================================================
// BASIC ARITHMETIC
// ============================================================================

it("should add floats") {
    assert((1.5 + 2.5) == 4.0);
    assert((0.1 + 0.2) > 0.29);  // Floating point approximation
    assert((0.1 + 0.2) < 0.31);
}

it("should subtract floats") {
    assert((5.5 - 2.5) == 3.0);
    assert((1.0 - 0.3) > 0.69);
    assert((1.0 - 0.3) < 0.71);
}

it("should multiply floats") {
    assert((2.5 * 4.0) == 10.0);
    assert((0.5 * 0.5) == 0.25);
    assert((3.0 * -2.0) == -6.0);
}

it("should divide floats") {
    assert((10.0 / 4.0) == 2.5);
    assert((1.0 / 3.0) > 0.333);
    assert((1.0 / 3.0) < 0.334);
}

// ============================================================================
// SPECIAL VALUES
// ============================================================================

it("should handle positive zero") {
    let z = 0.0;
    assert(z == 0.0);
    assert(z >= 0.0);
}

it("should handle negative zero") {
    let nz = -0.0;
    assert(nz == 0.0);  // Negative zero equals positive zero
}

it("should handle very large float values") {
    let large = 1.0e100;
    assert(large > 1000000.0);
    assert(large == large);
}

it("should handle very small float values") {
    let tiny = 1.0e-100;
    assert(tiny > 0.0);
    assert(tiny < 0.00001);
}

// ============================================================================
// COMPARISON OPERATIONS
// ============================================================================

it("should compare floats with less than") {
    assert(1.5 < 2.0);
    assert(-1.0 < 0.0);
    assert(0.0 < 0.001);
}

it("should compare floats with greater than") {
    assert(2.0 > 1.5);
    assert(0.0 > -1.0);
    assert(0.001 > 0.0);
}

it("should compare floats with equality") {
    assert(1.5 == 1.5);
    assert(0.0 == -0.0);
}

it("should handle approximate equality") {
    let a = 0.1 + 0.2;
    let b = 0.3;
    let epsilon = 0.0001;
    let diff = a - b;
    // Check both positive and negative difference
    assert(diff < epsilon);
    assert(diff > -epsilon);
}

// ============================================================================
// NEGATION
// ============================================================================

it("should negate floats") {
    let x = 5.5;
    assert(-x == -5.5);
    assert(-(-x) == 5.5);
    assert(-0.0 == 0.0);
}

it("should handle negative floats in expressions") {
    assert((-2.0 * 3.0) == -6.0);
    assert((-2.0 * -3.0) == 6.0);
    assert((10.0 / -2.0) == -5.0);
}

// ============================================================================
// EDGE CASES
// ============================================================================

it("should handle very small numbers") {
    let small = 0.0000001;
    assert(small > 0.0);
    assert(small * 1000000 > 0.09);
}

it("should handle very large numbers") {
    let large = 1e10;
    assert(large == 10000000000.0);
    assert(large / 1e5 == 100000.0);
}

// ============================================================================
// OPERATOR PRECEDENCE
// ============================================================================

it("should follow operator precedence") {
    assert((2.0 + 3.0 * 4.0) == 14.0);
    assert(((2.0 + 3.0) * 4.0) == 20.0);
    assert((10.0 - 2.0 / 2.0) == 9.0);
}

it("should handle mixed int and float") {
    assert((2 + 3.0) == 5.0);
    assert((10.0 / 4) == 2.5);
    assert((3 * 2.5) == 7.5);
}

// ============================================================================
// FLOAT LITERALS
// ============================================================================

it("should parse scientific notation") {
    assert(1e3 == 1000.0);
    assert(1.5e2 == 150.0);
    assert(2.5e-1 == 0.25);
}

it("should handle decimal literals") {
    assert(0.5 == 0.5);
    assert(.5 == 0.5);
    assert(1. == 1.0);
}
