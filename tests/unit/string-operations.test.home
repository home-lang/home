// String Operations Unit Tests

// ============================================================================
// STRING CREATION
// ============================================================================

it("should create empty string") {
    let s = "";
    assert(s.len() == 0);
    assert(s == "");
}

it("should create string from literal") {
    let s = "hello";
    assert(s == "hello");
    assert(s.len() == 5);
}

it("should create multiline string") {
    let s = "line1
line2
line3";
    assert(s.contains("line1"));
    assert(s.contains("line2"));
}

// ============================================================================
// STRING CONCATENATION
// ============================================================================

it("should concatenate strings") {
    let a = "hello";
    let b = "world";
    let c = a + " " + b;
    assert(c == "hello world");
}

it("should concatenate empty strings") {
    let a = "";
    let b = "test";
    assert((a + b) == "test");
    assert((b + a) == "test");
    assert((a + a) == "");
}

it("should concatenate multiple strings") {
    let result = "a" + "b" + "c" + "d" + "e";
    assert(result == "abcde");
}

// ============================================================================
// STRING INDEXING
// ============================================================================

it("should index single character") {
    let s = "hello";
    assert(s[0] == 'h');
    assert(s[1] == 'e');
    assert(s[4] == 'o');
}

it("should index with negative") {
    let s = "hello";
    assert(s[-1] == 'o');
    assert(s[-2] == 'l');
    assert(s[-5] == 'h');
}

// ============================================================================
// STRING SLICING
// ============================================================================

it("should slice from start") {
    let s = "hello world";
    assert(s[0..5] == "hello");
}

it("should slice to end") {
    let s = "hello world";
    assert(s[6..11] == "world");
}

it("should slice middle") {
    let s = "hello world";
    assert(s[3..8] == "lo wo");
}

it("should slice with implicit start") {
    let s = "hello";
    assert(s[..3] == "hel");
}

it("should slice with implicit end") {
    let s = "hello";
    assert(s[2..] == "llo");
}

it("should slice entire string") {
    let s = "hello";
    assert(s[..] == "hello");
}

// ============================================================================
// STRING COMPARISON
// ============================================================================

it("should compare equal strings") {
    assert("hello" == "hello");
    assert("" == "");
}

it("should compare unequal strings") {
    assert("hello" != "world");
    assert("hello" != "Hello");
    assert("hello" != "hello ");
}

it("should compare lexicographically") {
    assert("apple" < "banana");
    assert("abc" < "abd");
    assert("aa" < "aaa");
}

// ============================================================================
// CASE CONVERSION
// ============================================================================

it("should convert to uppercase") {
    assert("hello".upper() == "HELLO");
    assert("Hello World".upper() == "HELLO WORLD");
    assert("HELLO".upper() == "HELLO");
    assert("123abc".upper() == "123ABC");
}

it("should convert to lowercase") {
    assert("HELLO".lower() == "hello");
    assert("Hello World".lower() == "hello world");
    assert("hello".lower() == "hello");
    assert("123ABC".lower() == "123abc");
}

it("should capitalize") {
    assert("hello".capitalize() == "Hello");
    assert("HELLO".capitalize() == "Hello");
    assert("hello world".capitalize() == "Hello world");
}

it("should title case") {
    assert("hello world".title() == "Hello World");
    assert("HELLO WORLD".title() == "Hello World");
}

// ============================================================================
// WHITESPACE HANDLING
// ============================================================================

it("should trim both sides") {
    assert("  hello  ".trim() == "hello");
    assert("\t\nhello\t\n".trim() == "hello");
    assert("hello".trim() == "hello");
}

it("should trim left") {
    assert("  hello".trim_start() == "hello");
    assert("hello  ".trim_start() == "hello  ");
}

it("should trim right") {
    assert("hello  ".trim_end() == "hello");
    assert("  hello".trim_end() == "  hello");
}

// ============================================================================
// SEARCH OPERATIONS
// ============================================================================

it("should find substring") {
    let s = "hello world";
    assert(s.find("world") == Some(6));
    assert(s.find("hello") == Some(0));
    assert(s.find("xyz") == None);
}

it("should find last occurrence") {
    let s = "hello hello";
    assert(s.rfind("hello") == Some(6));
}

it("should count occurrences") {
    assert("banana".count("a") == 3);
    assert("banana".count("na") == 2);
    assert("banana".count("x") == 0);
}

// ============================================================================
// CHECKING OPERATIONS
// ============================================================================

it("should check if empty") {
    assert("".is_empty() == true);
    assert(" ".is_empty() == false);
    assert("hello".is_empty() == false);
}

it("should check if blank") {
    assert("".is_blank() == true);
    assert("   ".is_blank() == true);
    assert("\t\n".is_blank() == true);
    assert("hello".is_blank() == false);
}

it("should check if alphanumeric") {
    assert("abc123".is_alphanumeric() == true);
    assert("hello".is_alphanumeric() == true);
    assert("123".is_alphanumeric() == true);
    assert("hello world".is_alphanumeric() == false);
}

it("should check if alphabetic") {
    assert("hello".is_alphabetic() == true);
    assert("Hello".is_alphabetic() == true);
    assert("hello123".is_alphabetic() == false);
}

it("should check if numeric") {
    assert("123".is_numeric() == true);
    assert("123.45".is_numeric() == false);
    assert("12a".is_numeric() == false);
}

// ============================================================================
// PADDING
// ============================================================================

it("should pad left") {
    assert("hello".pad_start(10, ' ') == "     hello");
    assert("42".pad_start(5, '0') == "00042");
    assert("hello".pad_start(3, ' ') == "hello");
}

it("should pad right") {
    assert("hello".pad_end(10, ' ') == "hello     ");
    assert("hello".pad_end(3, ' ') == "hello");
}

it("should center") {
    assert("hi".center(6, ' ') == "  hi  ");
    assert("hello".center(7, '-') == "-hello-");
}

// ============================================================================
// REPETITION
// ============================================================================

it("should repeat string") {
    assert("ab".repeat(3) == "ababab");
    assert("x".repeat(5) == "xxxxx");
    assert("hello".repeat(0) == "");
    assert("hello".repeat(1) == "hello");
}

// ============================================================================
// JOINING
// ============================================================================

it("should join array with separator") {
    let parts = ["a", "b", "c"];
    assert(parts.join(", ") == "a, b, c");
    assert(parts.join("") == "abc");
    assert(parts.join("-") == "a-b-c");
}

it("should join empty array") {
    let empty: [string] = [];
    assert(empty.join(", ") == "");
}

it("should join single element") {
    let single = ["hello"];
    assert(single.join(", ") == "hello");
}

// ============================================================================
// BYTE OPERATIONS
// ============================================================================

it("should get bytes") {
    let s = "ABC";
    let bytes = s.as_bytes();
    assert(bytes[0] == 65);  // 'A'
    assert(bytes[1] == 66);  // 'B'
    assert(bytes[2] == 67);  // 'C'
}

it("should create from bytes") {
    let bytes = [72, 105];  // "Hi"
    let s = string::from_bytes(bytes);
    assert(s == "Hi");
}

// ============================================================================
// FORMAT STRING
// ============================================================================

it("should format with placeholders") {
    let name = "Alice";
    let age = 30;
    let s = "Name: {}, Age: {}".format(name, age);
    assert(s == "Name: Alice, Age: 30");
}

it("should format with named placeholders") {
    let s = "Hello, {name}!".format(name: "World");
    assert(s == "Hello, World!");
}

// ============================================================================
// ESCAPE SEQUENCES
// ============================================================================

it("should handle newline escape") {
    let s = "line1\nline2";
    assert(s.contains("\n"));
    assert(s.split("\n").len() == 2);
}

it("should handle tab escape") {
    let s = "col1\tcol2";
    assert(s.contains("\t"));
}

it("should handle quote escape") {
    let s = "say \"hello\"";
    assert(s.contains("\""));
}

it("should handle backslash escape") {
    let s = "path\\to\\file";
    assert(s.contains("\\"));
}

// ============================================================================
// UNICODE
// ============================================================================

it("should handle unicode characters") {
    let s = "Hello, ä¸–ç•Œ!";
    assert(s.len() > 7);  // Byte length
    assert(s.contains("ä¸–ç•Œ"));
}

it("should handle emoji") {
    let s = "Hello ðŸ‘‹";
    assert(s.contains("ðŸ‘‹"));
}

// ============================================================================
// CHAINING
// ============================================================================

it("should chain multiple operations") {
    let s = "  HELLO WORLD  ";
    let result = s.trim().lower().replace("world", "rust");
    assert(result == "hello rust");
}

it("should chain with conditionals") {
    let input = "  Test  ";
    let clean = input.trim();
    let result = if (clean.len() > 0) { clean.lower() } else { "empty" };
    assert(result == "test");
}
