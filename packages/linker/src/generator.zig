// Home Programming Language - Linker Script Generator
// Generates linker scripts from high-level definitions

const std = @import("std");
const linker = @import("linker.zig");
const memory = @import("memory.zig");
const section = @import("section.zig");
const symbol = @import("symbol.zig");
const validator = @import("validator.zig");

pub const GeneratorOptions = struct {
    validate: bool = true,
    include_comments: bool = true,
    verbose: bool = false,
};

pub const Generator = struct {
    allocator: std.mem.Allocator,
    options: GeneratorOptions,

    pub fn init(allocator: std.mem.Allocator, options: GeneratorOptions) Generator {
        return .{
            .allocator = allocator,
            .options = options,
        };
    }

    // Generate complete linker script
    pub fn generate(
        self: *Generator,
        writer: anytype,
        regions: []const memory.MemoryRegion,
        sections: []const section.Section,
        symbols: []const symbol.Symbol,
    ) !void {
        // Validate if requested
        if (self.options.validate) {
            var val = validator.Validator.init(self.allocator);
            defer val.deinit();

            const result = try val.validate(regions, sections, symbols);
            defer result.deinit();

            if (!result.valid) {
                std.debug.print("Validation failed with {d} errors:\n", .{result.errors.len});
                for (result.errors) |err| {
                    std.debug.print("  ERROR: {s}\n", .{err});
                }
                return error.ValidationFailed;
            }

            if (self.options.verbose and result.warnings.len > 0) {
                std.debug.print("Validation warnings ({d}):\n", .{result.warnings.len});
                for (result.warnings) |warn| {
                    std.debug.print("  {any}\n", .{warn});
                }
            }
        }

        // Generate script
        try self.writeHeader(writer);
        try self.writeMemoryRegions(writer, regions);
        try self.writeSections(writer, sections, symbols);
        try self.writeFooter(writer);
    }

    fn writeHeader(self: *Generator, writer: anytype) !void {
        if (self.options.include_comments) {
            try writer.writeAll("/* Linker script generated by Home OS Linker Control */\n");
            try writer.writeAll("/* DO NOT EDIT MANUALLY */\n\n");
        }

        try writer.writeAll("OUTPUT_FORMAT(\"elf64-x86-64\")\n");
        try writer.writeAll("OUTPUT_ARCH(i386:x86-64)\n");
        try writer.writeAll("ENTRY(_start)\n\n");
    }

    fn writeMemoryRegions(self: *Generator, writer: anytype, regions: []const memory.MemoryRegion) !void {
        if (regions.len == 0) return;

        if (self.options.include_comments) {
            try writer.writeAll("/* Memory Layout */\n");
        }

        try writer.writeAll("MEMORY\n{\n");

        for (regions) |region| {
            // Format attributes
            var attrs_buf: [16]u8 = undefined;
            var attrs_len: usize = 0;

            if (region.attributes.readable) {
                attrs_buf[attrs_len] = 'r';
                attrs_len += 1;
            }
            if (region.attributes.writable) {
                attrs_buf[attrs_len] = 'w';
                attrs_len += 1;
            }
            if (region.attributes.executable) {
                attrs_buf[attrs_len] = 'x';
                attrs_len += 1;
            }

            const attrs = if (attrs_len > 0) attrs_buf[0..attrs_len] else "r";

            try writer.print("  {s} ({s}) : ORIGIN = 0x{x:0>16}, LENGTH = 0x{x}\n", .{
                region.name,
                attrs,
                region.base,
                region.size,
            });
        }

        try writer.writeAll("}\n\n");
    }

    fn writeSections(
        self: *Generator,
        writer: anytype,
        sections: []const section.Section,
        symbols: []const symbol.Symbol,
    ) !void {
        if (self.options.include_comments) {
            try writer.writeAll("/* Section Layout */\n");
        }

        try writer.writeAll("SECTIONS\n{\n");

        // Write sections
        for (sections) |sect| {
            try self.writeSection(writer, sect);
        }

        // Write symbols
        if (symbols.len > 0) {
            if (self.options.include_comments) {
                try writer.writeAll("\n  /* Symbols */\n");
            }
            for (symbols) |sym| {
                try self.writeSymbol(writer, sym);
            }
        }

        try writer.writeAll("}\n");
    }

    fn writeSection(self: *Generator, writer: anytype, sect: section.Section) !void {
        if (self.options.include_comments) {
            try writer.print("\n  /* {s} section */\n", .{sect.name});
        }

        try writer.print("  {s}", .{sect.name});

        if (sect.vma) |vma| {
            try writer.print(" 0x{x:0>16}", .{vma});
        }

        try writer.print(" : ALIGN({d})", .{sect.alignment.toBytes()});

        if (sect.region) |region| {
            try writer.writeAll("\n  {\n");

            // Add input sections
            const wildcard = switch (sect.section_type) {
                .Text => "*(.text .text.*)",
                .Rodata => "*(.rodata .rodata.*)",
                .Data => "*(.data .data.*)",
                .Bss => "*(.bss .bss.*)",
                .TData => "*(.tdata .tdata.*)",
                .Tbss => "*(.tbss .tbss.*)",
                .Init => "*(.init)",
                .Fini => "*(.fini)",
                .Debug => "*(.debug*)",
                .Custom => "*",
            };

            try writer.print("    {s}\n", .{wildcard});
            try writer.print("  }} > {s}", .{region});

            if (sect.lma) |lma| {
                try writer.print(" AT(0x{x:0>16})", .{lma});
            }

            try writer.writeAll("\n\n");
        } else {
            try writer.writeAll("\n  {\n");
            try writer.writeAll("    /* Empty section */\n");
            try writer.writeAll("  }\n\n");
        }
    }

    fn writeSymbol(self: *Generator, writer: anytype, sym: symbol.Symbol) !void {
        _ = self;

        try writer.writeAll("  ");

        // Visibility prefix
        const vis_prefix = switch (sym.visibility) {
            .Local => "",
            .Global => "PROVIDE(",
            .Weak => "PROVIDE(",
            .Hidden => "HIDDEN(",
            .Protected => "PROTECTED(",
            .Internal => "INTERNAL(",
        };

        const vis_suffix = switch (sym.visibility) {
            .Local => "",
            else => ")",
        };

        try writer.print("{s}{s} = ", .{ vis_prefix, sym.name });

        if (sym.value) |value| {
            try writer.print("0x{x:0>16}", .{value});
        } else if (sym.section) |sect| {
            if (std.mem.endsWith(u8, sym.name, "_start")) {
                try writer.print("ADDR({s})", .{sect});
            } else if (std.mem.endsWith(u8, sym.name, "_end")) {
                try writer.print("ADDR({s}) + SIZEOF({s})", .{ sect, sect });
            } else {
                try writer.print("ADDR({s})", .{sect});
            }
        } else {
            try writer.writeAll(".");
        }

        try writer.print(";{s}\n", .{vis_suffix});
    }

    fn writeFooter(self: *Generator, writer: anytype) !void {
        if (self.options.include_comments) {
            try writer.writeAll("\n/* Discard sections */\n");
        }

        try writer.writeAll("/DISCARD/ :\n");
        try writer.writeAll("{\n");
        try writer.writeAll("  *(.comment)\n");
        try writer.writeAll("  *(.note*)\n");
        try writer.writeAll("  *(.eh_frame)\n");
        try writer.writeAll("}\n");
    }

    // Generate to file
    pub fn generateToFile(
        self: *Generator,
        path: []const u8,
        regions: []const memory.MemoryRegion,
        sections: []const section.Section,
        symbols: []const symbol.Symbol,
    ) !void {
        const file = try std.fs.cwd().createFile(path, .{});
        defer file.close();

        try self.generate(file.writer(), regions, sections, symbols);
    }

    // Generate to string
    pub fn generateToString(
        self: *Generator,
        regions: []const memory.MemoryRegion,
        sections: []const section.Section,
        symbols: []const symbol.Symbol,
    ) ![]const u8 {
        var list = std.ArrayList(u8){};
        errdefer list.deinit(self.allocator);

        try self.generate(list.writer(self.allocator), regions, sections, symbols);

        return list.toOwnedSlice(self.allocator);
    }
};

// Quick generation helpers
pub fn generateKernelScript(
    allocator: std.mem.Allocator,
    layout: linker.MemoryLayout,
    base_addr: u64,
) ![]const u8 {
    var generator = Generator.init(allocator, .{});

    // Create regions based on layout
    var regions_list = std.ArrayList(memory.MemoryRegion){};
    defer regions_list.deinit(allocator);

    switch (layout) {
        .Kernel => {
            try regions_list.append(allocator, memory.MemoryRegion.init(
                "kernel",
                base_addr,
                0x4000_0000, // 1GB
                .{
                    .readable = true,
                    .writable = true,
                    .executable = true,
                    .cacheable = true,
                },
            ));
        },
        .HigherHalf => {
            const regions = memory.StandardRegions.x86_64_higher_half();
            try regions_list.appendSlice(allocator, &regions);
        },
        else => return error.UnsupportedLayout,
    }

    // Create standard sections
    var sections_list = std.ArrayList(section.Section){};
    defer sections_list.deinit(allocator);

    const std_sections = section.StandardSections.kernel_sections();
    var vma = base_addr;

    for (std_sections) |sect| {
        vma = sect.alignment.alignAddress(vma);
        try sections_list.append(allocator,
            sect.withVma(vma).withRegion("kernel"),
        );
        vma += 4096; // Assume 4KB minimum per section
    }

    // Create standard symbols
    const syms = try symbol.KernelSymbols.standard_symbols(allocator);
    defer allocator.free(syms);

    return try generator.generateToString(
        regions_list.items,
        sections_list.items,
        syms,
    );
}

// Tests
test "generator basic" {
    const testing = std.testing;

    var generator = Generator.init(testing.allocator, .{ .validate = false });

    var output = std.ArrayList(u8){};
    defer output.deinit(testing.allocator);

    const regions = [_]memory.MemoryRegion{
        memory.MemoryRegion.init("kernel", 0x1000, 0x100000, .{
            .readable = true,
            .writable = true,
            .executable = true,
        }),
    };

    const sections = [_]section.Section{
        section.StandardSections.text().withVma(0x1000).withRegion("kernel"),
    };

    const symbols = [_]symbol.Symbol{
        symbol.Symbol.init("_start", .Func, .Global).withSection(".text"),
    };

    try generator.generate(output.writer(testing.allocator), &regions, &sections, &symbols);

    const script = output.items;
    try testing.expect(script.len > 0);
    try testing.expect(std.mem.indexOf(u8, script, "MEMORY") != null);
    try testing.expect(std.mem.indexOf(u8, script, "SECTIONS") != null);
}

test "generate kernel script" {
    const testing = std.testing;

    const script = try generateKernelScript(
        testing.allocator,
        .Kernel,
        0x10_0000,
    );
    defer testing.allocator.free(script);

    try testing.expect(script.len > 0);
    try testing.expect(std.mem.indexOf(u8, script, "OUTPUT_FORMAT") != null);
    try testing.expect(std.mem.indexOf(u8, script, "ENTRY(_start)") != null);
    try testing.expect(std.mem.indexOf(u8, script, ".text") != null);
    try testing.expect(std.mem.indexOf(u8, script, ".rodata") != null);
    try testing.expect(std.mem.indexOf(u8, script, ".data") != null);
    try testing.expect(std.mem.indexOf(u8, script, ".bss") != null);
}

test "generate with validation" {
    const testing = std.testing;

    var generator = Generator.init(testing.allocator, .{ .validate = true });

    var output = std.ArrayList(u8){};
    defer output.deinit(testing.allocator);

    const regions = [_]memory.MemoryRegion{
        memory.MemoryRegion.init("kernel", 0x1000, 0x100000, .{
            .readable = true,
            .writable = true,
            .executable = true,
        }),
    };

    const sections = [_]section.Section{
        section.StandardSections.text().withVma(0x1000).withRegion("kernel"),
        section.StandardSections.rodata().withVma(0x5000).withRegion("kernel"),
        section.StandardSections.data().withVma(0x9000).withRegion("kernel"),
        section.StandardSections.bss().withVma(0xd000).withRegion("kernel"),
    };

    const symbols = [_]symbol.Symbol{};

    try generator.generate(output.writer(testing.allocator), &regions, &sections, &symbols);

    try testing.expect(output.items.len > 0);
}

test "generate to string" {
    const testing = std.testing;

    var generator = Generator.init(testing.allocator, .{ .validate = false });

    const regions = [_]memory.MemoryRegion{
        memory.MemoryRegion.init("kernel", 0x1000, 0x100000, .{}),
    };

    const sections = [_]section.Section{
        section.StandardSections.text().withVma(0x1000).withRegion("kernel"),
    };

    const symbols = [_]symbol.Symbol{};

    const script = try generator.generateToString(&regions, &sections, &symbols);
    defer testing.allocator.free(script);

    try testing.expect(script.len > 0);
}
