const std = @import("std");
const builtin = @import("builtin");
const ast = @import("ast");

/// LLVM IR Code Generator for Ion
///
/// This module generates LLVM IR from Home AST, enabling:
/// - Advanced optimizations (inlining, constant folding, dead code elimination)
/// - Vectorization (SIMD)
/// - Link-time optimization (LTO)
/// - Profile-guided optimization (PGO)
/// - Target-specific optimizations for multiple architectures
///
/// LLVM IR is emitted as text format that can be:
/// 1. Compiled with 'llc' to native assembly
/// 2. Optimized with 'opt' (LLVM optimizer)
/// 3. Linked with 'llvm-link' for whole-program optimization
pub const LLVMCodegen = struct {
    allocator: std.mem.Allocator,
    program: *const ast.Program,
    output: std.ArrayList(u8),

    // Symbol tables
    globals: std.StringHashMap(TypeInfo),
    locals: std.StringHashMap(LocalInfo),
    functions: std.StringHashMap(FunctionInfo),
    structs: std.StringHashMap(StructInfo),

    // Code generation state
    current_function: ?[]const u8,
    label_counter: usize,
    temp_counter: usize,
    string_literals: std.ArrayList(StringLiteral),

    pub const TypeInfo = struct {
        llvm_type: []const u8,
        size: usize,
        is_pointer: bool,
    };

    pub const LocalInfo = struct {
        name: []const u8,
        llvm_name: []const u8, // %0, %1, etc
        type_info: TypeInfo,
    };

    pub const FunctionInfo = struct {
        name: []const u8,
        return_type: []const u8,
        param_types: []const []const u8,
        is_external: bool,
    };

    pub const StructInfo = struct {
        name: []const u8,
        fields: []const FieldType,
        size: usize,
    };

    pub const FieldType = struct {
        name: []const u8,
        llvm_type: []const u8,
        offset: usize,
    };

    pub const StringLiteral = struct {
        id: usize,
        content: []const u8,
    };

    pub fn init(allocator: std.mem.Allocator, program: *const ast.Program) LLVMCodegen {
        return .{
            .allocator = allocator,
            .program = program,
            .output = std.ArrayList(u8).init(allocator),
            .globals = std.StringHashMap(TypeInfo).init(allocator),
            .locals = std.StringHashMap(LocalInfo).init(allocator),
            .functions = std.StringHashMap(FunctionInfo).init(allocator),
            .structs = std.StringHashMap(StructInfo).init(allocator),
            .current_function = null,
            .label_counter = 0,
            .temp_counter = 0,
            .string_literals = std.ArrayList(StringLiteral).init(allocator),
        };
    }

    pub fn deinit(self: *LLVMCodegen) void {
        self.output.deinit();
        self.globals.deinit();
        self.locals.deinit();
        self.functions.deinit();
        self.structs.deinit();
        self.string_literals.deinit();
    }

    /// Generate LLVM IR for the entire program
    pub fn generate(self: *LLVMCodegen) ![]const u8 {
        // Emit LLVM module header
        try self.emitHeader();

        // Declare external functions (libc, etc)
        try self.emitExternalDeclarations();

        // Emit string literals as global constants
        try self.emitStringLiterals();

        // Generate code for all top-level declarations
        for (self.program.body) |stmt| {
            try self.generateStmt(stmt);
        }

        return try self.output.toOwnedSlice();
    }

    fn emitHeader(self: *LLVMCodegen) !void {
        const writer = self.output.writer();
        try writer.writeAll("; Generated by Home Compiler - LLVM IR Backend\n");

        // Get target triple based on current platform
        const target_triple = getTargetTriple();
        const target_datalayout = getDataLayout();

        try writer.print("; Target: {s}\n", .{target_triple});
        try writer.print("target datalayout = \"{s}\"\n", .{target_datalayout});
        try writer.print("target triple = \"{s}\"\n\n", .{target_triple});
    }

    /// Get the target triple for the current platform
    fn getTargetTriple() []const u8 {
        const arch = @tagName(builtin.cpu.arch);
        const os = @tagName(builtin.os.tag);

        // Map Zig architecture names to LLVM architecture names
        const llvm_arch = if (std.mem.eql(u8, arch, "x86_64"))
            "x86_64"
        else if (std.mem.eql(u8, arch, "aarch64"))
            "aarch64"
        else if (std.mem.eql(u8, arch, "arm"))
            "arm"
        else if (std.mem.eql(u8, arch, "riscv64"))
            "riscv64"
        else
            arch;

        // Map Zig OS names to LLVM OS/environment
        const llvm_os = if (std.mem.eql(u8, os, "linux"))
            "unknown-linux-gnu"
        else if (std.mem.eql(u8, os, "windows"))
            "pc-windows-msvc"
        else if (std.mem.eql(u8, os, "macos"))
            "apple-macosx"
        else if (std.mem.eql(u8, os, "freebsd"))
            "unknown-freebsd"
        else if (std.mem.eql(u8, os, "openbsd"))
            "unknown-openbsd"
        else
            "unknown-unknown";

        // Common combinations
        if (builtin.os.tag == .windows and builtin.cpu.arch == .x86_64) {
            return "x86_64-pc-windows-msvc";
        } else if (builtin.os.tag == .linux and builtin.cpu.arch == .x86_64) {
            return "x86_64-unknown-linux-gnu";
        } else if (builtin.os.tag == .macos and builtin.cpu.arch == .x86_64) {
            return "x86_64-apple-macosx";
        } else if (builtin.os.tag == .macos and builtin.cpu.arch == .aarch64) {
            return "aarch64-apple-macosx";
        } else if (builtin.os.tag == .windows and builtin.cpu.arch == .aarch64) {
            return "aarch64-pc-windows-msvc";
        } else if (builtin.os.tag == .linux and builtin.cpu.arch == .aarch64) {
            return "aarch64-unknown-linux-gnu";
        } else {
            // Generic fallback
            var buffer: [128]u8 = undefined;
            const result = std.fmt.bufPrint(&buffer, "{s}-{s}", .{ llvm_arch, llvm_os }) catch "unknown-unknown-unknown";
            return result;
        }
    }

    /// Get the data layout for the current platform
    fn getDataLayout() []const u8 {
        if (builtin.os.tag == .windows and builtin.cpu.arch == .x86_64) {
            // Windows x64 uses a different data layout
            return "e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128";
        } else if (builtin.os.tag == .linux and builtin.cpu.arch == .x86_64) {
            // Linux x64
            return "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128";
        } else if (builtin.os.tag == .macos and builtin.cpu.arch == .x86_64) {
            // macOS x64
            return "e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128";
        } else if (builtin.cpu.arch == .aarch64) {
            // ARM64 (generic)
            return "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128";
        } else {
            // Generic fallback - little endian, default alignment
            return "e-m:e-i64:64-f80:128-n8:16:32:64-S128";
        }
    }

    fn emitExternalDeclarations(self: *LLVMCodegen) !void {
        const writer = self.output.writer();

        // Declare common libc functions
        try writer.writeAll("; External function declarations\n");
        try writer.writeAll("declare i32 @printf(i8*, ...)\n");
        try writer.writeAll("declare i8* @malloc(i64)\n");
        try writer.writeAll("declare void @free(i8*)\n");
        try writer.writeAll("declare i8* @memcpy(i8*, i8*, i64)\n");
        try writer.writeAll("declare i32 @memcmp(i8*, i8*, i64)\n");
        try writer.writeAll("declare i64 @strlen(i8*)\n\n");

        // Register external functions in symbol table
        try self.functions.put("printf", .{
            .name = "printf",
            .return_type = "i32",
            .param_types = &[_][]const u8{"i8*"},
            .is_external = true,
        });
    }

    fn emitStringLiterals(self: *LLVMCodegen) !void {
        const writer = self.output.writer();

        if (self.string_literals.items.len > 0) {
            try writer.writeAll("; String literals\n");
            for (self.string_literals.items) |str_lit| {
                try writer.print("@.str.{d} = private unnamed_addr constant [{d} x i8] c\"{}\\00\"\n", .{
                    str_lit.id,
                    str_lit.content.len + 1,
                    std.zig.fmtEscapes(str_lit.content),
                });
            }
            try writer.writeAll("\n");
        }
    }

    fn generateStmt(self: *LLVMCodegen, stmt: ast.Stmt) !void {
        switch (stmt) {
            .FnDecl => |fn_decl| try self.generateFunction(fn_decl),
            .StructDecl => |struct_decl| try self.generateStruct(struct_decl),
            .LetDecl => |let_decl| try self.generateLetDecl(let_decl),
            .ReturnStmt => |ret_stmt| try self.generateReturn(ret_stmt),
            .IfStmt => |if_stmt| try self.generateIf(if_stmt),
            .WhileStmt => |while_stmt| try self.generateWhile(while_stmt),
            .ExprStmt => |expr| try self.generateExprStmt(expr),
            else => {}, // Other statements handled as needed
        }
    }

    fn generateFunction(self: *LLVMCodegen, fn_decl: *ast.FnDecl) !void {
        const writer = self.output.writer();

        self.current_function = fn_decl.name;
        self.temp_counter = 0;
        self.label_counter = 0;
        self.locals.clearRetainingCapacity();

        // Function signature
        const return_type = try self.mapTypeToLLVM(fn_decl.return_type);
        try writer.print("define {s} @{s}(", .{ return_type, fn_decl.name });

        // Parameters
        for (fn_decl.params, 0..) |param, i| {
            if (i > 0) try writer.writeAll(", ");
            const param_type = try self.mapTypeToLLVM(param.type_name);
            try writer.print("{s} %{s}", .{ param_type, param.name });

            // Track parameter in locals
            try self.locals.put(param.name, .{
                .name = param.name,
                .llvm_name = try std.fmt.allocPrint(self.allocator, "%{s}", .{param.name}),
                .type_info = .{
                    .llvm_type = param_type,
                    .size = 8,
                    .is_pointer = false,
                },
            });
        }

        try writer.writeAll(") {\n");
        try writer.writeAll("entry:\n");

        // Generate function body
        if (fn_decl.body) |body| {
            try self.generateBlockStmt(body);
        }

        try writer.writeAll("}\n\n");

        self.current_function = null;
    }

    fn generateStruct(self: *LLVMCodegen, struct_decl: *ast.StructDecl) !void {
        const writer = self.output.writer();

        // Define struct type
        try writer.print("%struct.{s} = type {{ ", .{struct_decl.name});

        for (struct_decl.fields, 0..) |field, i| {
            if (i > 0) try writer.writeAll(", ");
            const field_type = try self.mapTypeToLLVM(field.type_name);
            try writer.writeAll(field_type);
        }

        try writer.writeAll(" }\n");
    }

    fn generateLetDecl(self: *LLVMCodegen, let_decl: *ast.LetDecl) !void {
        const writer = self.output.writer();

        if (let_decl.value) |value| {
            // Generate initialization expression
            const value_reg = try self.generateExpr(value);

            // Allocate stack space for variable
            const temp = try self.getNextTemp();
            errdefer self.allocator.free(temp);

            const var_type = try self.mapTypeToLLVM(let_decl.type_name);
            try writer.print("  {s} = alloca {s}\n", .{ temp, var_type });

            // Store initial value
            try writer.print("  store {s} {s}, {s}* {s}\n", .{
                var_type,
                value_reg,
                var_type,
                temp,
            });

            // Track variable
            try self.locals.put(let_decl.name, .{
                .name = let_decl.name,
                .llvm_name = temp,
                .type_info = .{
                    .llvm_type = var_type,
                    .size = 8,
                    .is_pointer = true,
                },
            });
        }
    }

    fn generateReturn(self: *LLVMCodegen, ret_stmt: *ast.ReturnStmt) !void {
        const writer = self.output.writer();

        if (ret_stmt.value) |value| {
            const value_reg = try self.generateExpr(value);
            const value_type = try self.getExprType(value);
            try writer.print("  ret {s} {s}\n", .{ value_type, value_reg });
        } else {
            try writer.writeAll("  ret void\n");
        }
    }

    fn generateIf(self: *LLVMCodegen, if_stmt: *ast.IfStmt) !void {
        const writer = self.output.writer();

        // Generate condition
        const cond_reg = try self.generateExpr(if_stmt.condition);

        // Create labels
        const then_label = try self.getNextLabel("then");
        errdefer self.allocator.free(then_label);

        const else_label = try self.getNextLabel("else");
        errdefer self.allocator.free(else_label);

        const end_label = try self.getNextLabel("end");
        errdefer self.allocator.free(end_label);

        // Branch based on condition
        if (if_stmt.else_branch) |_| {
            try writer.print("  br i1 {s}, label %{s}, label %{s}\n", .{
                cond_reg,
                then_label,
                else_label,
            });
        } else {
            try writer.print("  br i1 {s}, label %{s}, label %{s}\n", .{
                cond_reg,
                then_label,
                end_label,
            });
        }

        // Then branch
        try writer.print("{s}:\n", .{then_label});
        try self.generateBlockStmt(if_stmt.then_branch);
        try writer.print("  br label %{s}\n", .{end_label});

        // Else branch (if exists)
        if (if_stmt.else_branch) |else_branch| {
            try writer.print("{s}:\n", .{else_label});
            try self.generateBlockStmt(else_branch);
            try writer.print("  br label %{s}\n", .{end_label});
        }

        // End label
        try writer.print("{s}:\n", .{end_label});
    }

    fn generateWhile(self: *LLVMCodegen, while_stmt: *ast.WhileStmt) !void {
        const writer = self.output.writer();

        const cond_label = try self.getNextLabel("while.cond");
        const body_label = try self.getNextLabel("while.body");
        const end_label = try self.getNextLabel("while.end");

        // Jump to condition
        try writer.print("  br label %{s}\n", .{cond_label});

        // Condition block
        try writer.print("{s}:\n", .{cond_label});
        const cond_reg = try self.generateExpr(while_stmt.condition);
        try writer.print("  br i1 {s}, label %{s}, label %{s}\n", .{
            cond_reg,
            body_label,
            end_label,
        });

        // Body block
        try writer.print("{s}:\n", .{body_label});
        try self.generateBlockStmt(while_stmt.body);
        try writer.print("  br label %{s}\n", .{cond_label});

        // End block
        try writer.print("{s}:\n", .{end_label});
    }

    fn generateBlockStmt(self: *LLVMCodegen, block: *ast.BlockStmt) !void {
        for (block.statements) |stmt| {
            try self.generateStmt(stmt);
        }
    }

    fn generateExprStmt(self: *LLVMCodegen, expr: *ast.Expr) !void {
        _ = try self.generateExpr(expr);
    }

    fn generateExpr(self: *LLVMCodegen, expr: *ast.Expr) ![]const u8 {
        return switch (expr.*) {
            .IntegerLiteral => |lit| try std.fmt.allocPrint(self.allocator, "{d}", .{lit.value}),
            .BooleanLiteral => |lit| try std.fmt.allocPrint(self.allocator, "{}", .{lit.value}),
            .Identifier => |id| blk: {
                const local = self.locals.get(id.name) orelse return error.UndefinedVariable;
                const temp = try self.getNextTemp();
                const writer = self.output.writer();
                try writer.print("  {s} = load {s}, {s}* {s}\n", .{
                    temp,
                    local.type_info.llvm_type,
                    local.type_info.llvm_type,
                    local.llvm_name,
                });
                break :blk temp;
            },
            .BinaryExpr => |bin| try self.generateBinaryExpr(bin),
            .CallExpr => |call| try self.generateCall(call),
            else => try std.fmt.allocPrint(self.allocator, "%unknown", .{}),
        };
    }

    fn generateBinaryExpr(self: *LLVMCodegen, bin_expr: *ast.BinaryExpr) ![]const u8 {
        const writer = self.output.writer();

        const left = try self.generateExpr(bin_expr.left);
        const right = try self.generateExpr(bin_expr.right);
        const result = try self.getNextTemp();

        const op = switch (bin_expr.operator) {
            .Plus => "add",
            .Minus => "sub",
            .Star => "mul",
            .Slash => "sdiv",
            .Percent => "srem",
            .EqualEqual => "icmp eq",
            .BangEqual => "icmp ne",
            .Less => "icmp slt",
            .LessEqual => "icmp sle",
            .Greater => "icmp sgt",
            .GreaterEqual => "icmp sge",
            else => "add", // fallback
        };

        const result_type = if (std.mem.startsWith(u8, op, "icmp")) "i1" else "i64";
        try writer.print("  {s} = {s} i64 {s}, {s}\n", .{ result, op, left, right });

        _ = result_type;
        return result;
    }

    fn generateCall(self: *LLVMCodegen, call_expr: *ast.CallExpr) ![]const u8 {
        const writer = self.output.writer();
        const result = try self.getNextTemp();
        errdefer self.allocator.free(result);

        // Get callee name
        const callee_name = switch (call_expr.callee.*) {
            .Identifier => |id| id.name,
            else => return error.InvalidCallTarget,
        };

        // Generate arguments
        var args = std.ArrayList([]const u8).init(self.allocator);
        errdefer args.deinit();
        defer args.deinit();

        for (call_expr.arguments) |arg| {
            const arg_reg = try self.generateExpr(arg);
            try args.append(arg_reg);
        }

        // Emit call
        const func_info = self.functions.get(callee_name) orelse return error.UndefinedFunction;
        try writer.print("  {s} = call {s} @{s}(", .{ result, func_info.return_type, callee_name });

        for (args.items, 0..) |arg, i| {
            if (i > 0) try writer.writeAll(", ");
            try writer.print("i64 {s}", .{arg});
        }

        try writer.writeAll(")\n");

        return result;
    }

    fn mapTypeToLLVM(self: *LLVMCodegen, type_name: []const u8) ![]const u8 {
        _ = self;

        return if (std.mem.eql(u8, type_name, "i32") or
            std.mem.eql(u8, type_name, "i64") or
            std.mem.eql(u8, type_name, "int"))
            "i64"
        else if (std.mem.eql(u8, type_name, "f32"))
            "float"
        else if (std.mem.eql(u8, type_name, "f64"))
            "double"
        else if (std.mem.eql(u8, type_name, "bool"))
            "i1"
        else if (std.mem.eql(u8, type_name, "void"))
            "void"
        else if (std.mem.eql(u8, type_name, "str"))
            "i8*"
        else
            "i64"; // default
    }

    fn getExprType(self: *LLVMCodegen, expr: *ast.Expr) ![]const u8 {
        _ = self;
        _ = expr;
        return "i64"; // Simplified - would need type inference
    }

    fn getNextTemp(self: *LLVMCodegen) ![]const u8 {
        const temp = try std.fmt.allocPrint(self.allocator, "%{d}", .{self.temp_counter});
        errdefer self.allocator.free(temp);
        self.temp_counter += 1;
        return temp;
    }

    fn getNextLabel(self: *LLVMCodegen, prefix: []const u8) ![]const u8 {
        const label = try std.fmt.allocPrint(self.allocator, "{s}.{d}", .{ prefix, self.label_counter });
        errdefer self.allocator.free(label);
        self.label_counter += 1;
        return label;
    }
};

/// Optimization pass manager
pub const OptimizationPasses = struct {
    level: OptLevel,

    pub const OptLevel = enum {
        None, // -O0
        Less, // -O1
        Default, // -O2
        Aggressive, // -O3
        Size, // -Os
        SizeZ, // -Oz
    };

    pub fn init(level: OptLevel) OptimizationPasses {
        return .{ .level = level };
    }

    /// Get LLVM opt command line flags
    pub fn getOptFlags(self: OptimizationPasses, allocator: std.mem.Allocator) ![]const u8 {
        return switch (self.level) {
            .None => try allocator.dupe(u8, "-O0"),
            .Less => try allocator.dupe(u8, "-O1"),
            .Default => try allocator.dupe(u8, "-O2"),
            .Aggressive => try allocator.dupe(u8, "-O3"),
            .Size => try allocator.dupe(u8, "-Os"),
            .SizeZ => try allocator.dupe(u8, "-Oz"),
        };
    }

    /// Common optimization passes
    pub const Passes = enum {
        // Function passes
        mem2reg, // Promote memory to register
        instcombine, // Combine instructions
        simplifycfg, // Simplify control flow
        dce, // Dead code elimination
        dse, // Dead store elimination
        inline, // Function inlining
        gvn, // Global value numbering
        sccp, // Sparse conditional constant propagation

        // Loop passes
        loop_unroll, // Unroll loops
        loop_vectorize, // Vectorize loops
        licm, // Loop-invariant code motion

        // Link-time optimizations
        globalopt, // Global variable optimization
        ipsccp, // Interprocedural SCCP
        deadargelim, // Dead argument elimination
    };
};
